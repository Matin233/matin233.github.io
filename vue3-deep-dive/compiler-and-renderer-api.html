<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>编译器和渲染器 API | HiDoc</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.0e123b58.css" as="style"><link rel="preload" href="/assets/js/app.fe03ab5e.js" as="script"><link rel="preload" href="/assets/js/2.1f5ff3fb.js" as="script"><link rel="preload" href="/assets/js/3.c3ea9630.js" as="script"><link rel="prefetch" href="/assets/js/10.9768c84c.js"><link rel="prefetch" href="/assets/js/11.a026e0a2.js"><link rel="prefetch" href="/assets/js/12.dabf57c8.js"><link rel="prefetch" href="/assets/js/13.c77aa622.js"><link rel="prefetch" href="/assets/js/14.280e0fc5.js"><link rel="prefetch" href="/assets/js/15.0e1e201b.js"><link rel="prefetch" href="/assets/js/16.a396a055.js"><link rel="prefetch" href="/assets/js/17.b7d94a0d.js"><link rel="prefetch" href="/assets/js/18.1fcf8e89.js"><link rel="prefetch" href="/assets/js/19.70c96dc8.js"><link rel="prefetch" href="/assets/js/20.57a7fb21.js"><link rel="prefetch" href="/assets/js/21.b4eb4bc0.js"><link rel="prefetch" href="/assets/js/22.35179f79.js"><link rel="prefetch" href="/assets/js/23.576e6489.js"><link rel="prefetch" href="/assets/js/24.9dd3f0ff.js"><link rel="prefetch" href="/assets/js/25.0cf8dc8f.js"><link rel="prefetch" href="/assets/js/26.afc031d5.js"><link rel="prefetch" href="/assets/js/27.429d522c.js"><link rel="prefetch" href="/assets/js/28.6486f2ff.js"><link rel="prefetch" href="/assets/js/29.86dde356.js"><link rel="prefetch" href="/assets/js/30.db155db7.js"><link rel="prefetch" href="/assets/js/31.000152f7.js"><link rel="prefetch" href="/assets/js/32.e62c80dc.js"><link rel="prefetch" href="/assets/js/33.b844c11a.js"><link rel="prefetch" href="/assets/js/34.6835e5f5.js"><link rel="prefetch" href="/assets/js/35.6327d166.js"><link rel="prefetch" href="/assets/js/36.aed4243f.js"><link rel="prefetch" href="/assets/js/37.643994a2.js"><link rel="prefetch" href="/assets/js/38.e008e751.js"><link rel="prefetch" href="/assets/js/39.e28e6619.js"><link rel="prefetch" href="/assets/js/4.d6136eb3.js"><link rel="prefetch" href="/assets/js/40.19f07b7b.js"><link rel="prefetch" href="/assets/js/41.30210dbb.js"><link rel="prefetch" href="/assets/js/5.df510ea4.js"><link rel="prefetch" href="/assets/js/6.50a4a862.js"><link rel="prefetch" href="/assets/js/7.a4dc71d5.js"><link rel="prefetch" href="/assets/js/8.05521ae8.js"><link rel="prefetch" href="/assets/js/9.32319f64.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e123b58.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HiDoc</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vue3-deep-dive/intro" class="sidebar-heading clickable open"><span>Vue3 Deep Dive</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue3-deep-dive/intro.html" class="sidebar-link">介绍</a></li><li><a href="/vue3-deep-dive/rendering-mechanism.html" class="sidebar-link">渲染机制</a></li><li><a href="/vue3-deep-dive/use-render-function.html" class="sidebar-link">使用渲染函数</a></li><li><a href="/vue3-deep-dive/compiler-and-renderer-api.html" aria-current="page" class="active sidebar-link">编译器和渲染器 API</a></li><li><a href="/vue3-deep-dive/creating-a-mount-function.html" class="sidebar-link">创建 Mount 函数</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="编译器和渲染器-api"><a href="#编译器和渲染器-api" class="header-anchor">#</a> 编译器和渲染器 API</h1> <p>这就是我们所说的模板浏览器（https://vue-next-template-explorer.netlify.app）</p> <p><img src="/assets/img/image-20211020103309960.965d3fee.png" alt="image-20211020103309960"></p> <p>我们在 Vue 2 也有一个，但是 Vue 3 模板浏览器功能更加丰富。</p> <p>如您所见，左边是源模板，右边是生成的渲染函数代码。</p> <p>在开发过程中，实际上我用这个来调试编译器，所以如果我有什么事情不能如愿，我只是在源模板中粘贴，我可以直接看到代码生成了什么，看看出了什么问题。</p> <p>如果我们看一下模板浏览器，这里有很多选择：</p> <p><img src="/assets/img/image-20211020104322430.2d1f7f23.png" alt="image-20211020104322430"></p> <p>所以我们可以启用某些类型的优化，例如：</p> <p>如果我们有一个嵌套的 div，这个 div 是完全静态的，你可以打开这个（hoistStatic），然后看它是否确实被从渲染函数中提升，以便可以在每个渲染器上重用它。</p> <p><img src="/assets/img/image-20211020104504519.96dbda96.png" alt="image-20211020104504519"></p> <p>所以每次组件更新时，这个渲染函数将被调用。一旦一个节点被提升，它就会被创建一次。在渲染函数之外，在以后的每一次渲染中，它将在这里重新使用。这有两个好处：</p> <p>首先是避免重新创建对象，然后扔掉。另一个好处是在我们的模式算法中，当你看到两个节点在同一位置时，在严格平等的情况下，我们可以跳过它。因为我们知道它永远不会改变。所以，是的，有很多有趣的优化。</p> <p>我们做的另一个有趣的优化：</p> <p>当你有一个点击侦听器，我们可以注意到我们绑定了 click 侦听器，编译器会生成一个补丁标志。</p> <p><img src="/assets/img/image-20211020105234367.3d7048e9.png" alt="image-20211020105234367"></p> <p>这个节点有动态 props 需要修补一下，以及动态 props 的名称，需要修补的是 onClick。通常使用简单的虚拟 DOM 渲染算法。</p> <p>不管有多少东西在 div 自身上，这整个对象必须作为一个整体来 diff。</p> <p><img src="/assets/img/image-20211020105412743.cb60c8c7.png" alt="image-20211020105412743"></p> <p>所以即使从模板中我们可以看到，这个 ID 实际上是静态的，永远不会改变。</p> <p>我们还需要穿过整个对象，只是为了确保它不会改变，因为运行时没有足够的信息来推断。</p> <p>但是，使用 Vue 3 的编译器，这个补丁（PROPS）和这个数组（<code>[&quot;onClick&quot;]</code>）结合在一起，为运行时提供足够的信息。</p> <p>好吧，所以有些 props 会改变的，但唯一可能改变的是 onClick，因为它和暴露在外的东西结合在一起，所以你可以决定在某个时间改变它。</p> <p>我们可以跳过此 props 上的对象枚举，忽略那些已经被编译器推断永远不会改变的 props。</p> <p>确切地说，这些是编译器生成的提示，以帮助运行时更高效，在手动编写的渲染函数中，这不是一件容易的事。因为分析 JavaScript 比分析模板困难得多。</p> <p>我们现在看到的是是生成的渲染函数，相比你自己写的代码总是更加的冗长。因为编译器总是优先考虑更加优化，更加明确。</p> <p>我们一会儿就会看到，这里有很多便利。当你自己使用 API 时，我们所提供的使它更容易和更流畅。</p> <p>所以我们看看这个点击处理程序：</p> <p><img src="/assets/img/image-20211020105412743.cb60c8c7.png" alt="image-20211020105412743"></p> <p>现在我们知道在这个节点上，每次被更新或被 diff。我们需要看一下 onClick 以确保它不会改变。但在很多情况下，当你绑定一个事件监听器。实际上，您并不打算更改事件处理程序。所以当你用 Vue3 时，有一个选项（cacheHandlers）是默认打开的。</p> <p><img src="/assets/img/image-20211020110836170.b1527719.png" alt="image-20211020110836170"></p> <p>注意我们使用了一些智能 JavaScript 来缓存事件处理程序：我们把它变成一个内联函数，并在第一次渲染时将其缓存。因此在后续渲染中，我们将始终使用同一个内联处理程序，所以我们总是传递相同的函数，但是里面的函数会访问 ctx.onClick。它保证它总是最新的函数被调用。</p> <p>我们可以注意到补丁标志，onClick 数组不见了。这意味着现在这个 vnode，当我们试图修补它时，它实际上并不需要被修补，因为这是静态的。当它被调用时，此事件处理程序已缓存，它总是指向最新的 onClick。所以即使 onClick 下面发生了变化，我们不需要对 vnode 本身做任何事情，我们只找到了一次相同的事件处理程序，我们可以忘掉它。在修补过程中，现在可以完全跳过整个节点，这是另一个层次的优化。</p> <p>这一点尤其重要，因为在组件上如果要将事件处理程序添加到组件中，我们防止子组件不必要地重新渲染的最常见情况之一是指使用类似这里的内联事件处理程序。</p> <p><img src="/assets/img/image-20211020113134456.87436ef9.png" alt="image-20211020113134456"></p> <p>或者当你写 foo 的时候，你给它一个参数，这也是一个隐式的内联处理程序。</p> <p><img src="/assets/img/image-20211020113425643.65905c70.png" alt="image-20211020113425643"></p> <p>所以所有这些在 Vue 2 中，对于这个组件，即使什么都没有改变，它仍然会导致子组件在父组件重新渲染时重新渲染。在大型应用中，这会引起连锁效应。因为你在向下传递函数，在每次渲染时，都会创建一个新的内联函数。会导致所有这些收到那个 prop 的子组件重新渲染。</p> <p>所以在 Vue 3 中使用句柄缓存，这基本上减少了很大的面积的，在大型组件树中发生不必要的渲染，所以这也是一个不错的性能改进。</p> <p>事实上，这也是 React 中一个很常见的陷阱。这就是为什么 React 中有一个名为 useMemo 的 API，或者叫 useCallback ，它们几乎是一样的。为了防止子组件重新渲染，允许开发人员手动缓存像这样的事件处理程序。</p> <p>但是在 Vue 3 中有了模板，我们可以为用户自动完成，所以你不需要去想它。</p> <blockquote><p>块和 vnode 有什么区别？</p></blockquote> <p>让我们回到这个例子：</p> <p>我们看到根 div 被创建了，就像块一样。所以我们有一个这样的临时结构，在右边，我们看到它被提升了，但我们暂时不要担心。</p> <p><img src="/assets/img/image-20211020114105266.63079d5b.png" alt="image-20211020114105266"></p> <p>想象一下这是一个手动写的非优化虚拟 DOM 树，在更新时，你要确保 DOM 结构是一致的。如果这是手动编写的，那么运行时就没有信息了。关于这个 DOM 树结构是否稳定，它不能做出任何假设，因为节点顺序可能已经改变，或者这个可以从 div 变成 p，对吗？</p> <p>当它是 JavaScript 时，任何事情都可能发生，所以运行时必须格外小心，它必须检查每个节点以确保它没有变成别的东西。如果有 props 的话就要把所有的 props 都区分开来，确保 props 没有改变。</p> <p>说到孩子（children）...</p> <p><img src="/assets/img/image-20211020114354115.218b2d45.png" alt="image-20211020114354115"></p> <p>事实上，它必须区分两个子数组以确保他们没有四处走动，或者没有新的孩子加入，或者孩子被删除。</p> <p>为了清楚起见，我们指向的是 HTML 代码，但实际上是一个虚拟 DOM 结构，看起来像 JSON。它是一堆 JavaScript 对象。</p> <p>如果我们有一个渲染函数并且我们要复制我们刚才看到的这个模板，我们最终会得到这样的结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
            <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token string">'hello'</span><span class="token punctuation">)</span>
        <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此，您可以想象最终的底层数据结构，可能看起来更像这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> vdom <span class="token operator">=</span> <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token punctuation">[</span>
        tag<span class="token operator">:</span> <span class="token string">'div'</span><span class="token punctuation">,</span>
        children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>
        	tag<span class="token operator">:</span> <span class="token string">'span'</span><span class="token punctuation">,</span>
        	children<span class="token operator">:</span> <span class="token string">'hello'</span>
        <span class="token punctuation">}</span><span class="token punctuation">]</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以当我们调用这个生成的 JavaScript 结构，看起来像这样简单的结构。</p> <p>渲染器的工作，更新时，它将有两个快照。像这样的虚拟 DOM 树，它的某些部分可能已经改变了。</p> <p>例如，从“hello”更新到“msg”。如果我们不提供更多的提示，渲染器并不真正知道发生了什么变化。所以它必须经过一个相对暴力的算法，以递归方式遍历整棵树，比较旧节点和新节点找出什么改变了。</p> <p>一般来说，在大多数情况下够快了。对于中型应用程序，您可能不会注意到任何性能瓶颈。因为现代 JavaScript 引擎处理普通对象优化得很好了。</p> <p>但是，当你有一个大型应用程序时，当你开始注意到最终这些小的迭代成本加起来。比如，当你点击某个东西时，也许你的应用程序中会有 10 个组件同时被触发再更新。这就是 JavaScript 成本开始增加的时候，这可能阻塞或卡顿你的应用程序。</p> <p>所以这就是人们开始了解如何手动优化组件树，避免不必要的重新渲染，这就是 Vue 的优势所在。所以我们添加了一些提示，以及如何实现这一目标的优化。</p> <p>让我们回到块。</p> <p><img src="/assets/img/image-20211020114354115.218b2d45.png" alt="image-20211020114354115"></p> <p>在这里，我们可以看到。但这可能不是一个完美的例子。因为这棵树实际上是静止的，所以被提升。</p> <p>但是想象一下，让我们在这里加一点信息。</p> <p><img src="/assets/img/image-20211020162949531.7d537075.png" alt="image-20211020162949531"></p> <p>这会使这部分变为动态，整棵树都不能被提升。因为它里面有动态的东西。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span><span class="token punctuation">{</span> msg <span class="token punctuation">}</span><span class="token punctuation">}</span>
</code></pre></div><p>但是，理想情况下，当我们看模板时，我们知道这个 div 不会改变。唯一可能改变的事实上就是这个 span。</p> <p>事实上，如果我在其他区域添加一些不相关的节点，作为人类，我们可以立即在整个模板中看到这一点——只有这个东西（span）可以改变，但是如果没有编译器生成的提示，虚拟 DOM 渲染器只看到 JavaScript 树，它不知道哪个部分会改变，所以编译器的工作就是提供这些信息。</p> <p>所以运行时可以说：“好吧，看看你给我的数据，我知道我可以跳过很多不必要的工作，直接跳到这（span）上面去。”</p> <p>我们的方法是用 block。我们将模板的根变成我们所称的块，注意这里有一个 openBlock 调用。</p> <p><img src="/assets/img/image-20211020163746061.a417a278.png" alt="image-20211020163746061"></p> <p>所以当块打开时，所有表达式，所有的孩子都会被评估。</p> <p>当当前块打开时，所以这是一种 JavaScript 骗术。但想法是，当你创建这样一个节点时，因为它是动态的，它有我们称之为补丁标志的东西。补丁标志表示此节点是动态的，它应该被跟踪。当我们说tracked时，这个节点就会被添加到当前打开的 block 作为动态节点。</p> <p>所以在整个调用之后，这个根 div 将有一个额外的属性称为动态子节点，它将只包含此节点。</p> <p>我们还有完整的结构，通过正常的子层级，但是每个块都有一个额外的数组，只跟踪其中的动态节点，这个可以任意深。</p> <p>如果你有一个非常复杂的 DOM 结构，但不管有多复杂，在一个扁平数组中块将只跟踪动态节点。所以当它到达那个块时，通过虚拟 DOM 跟踪，它到达块。块告诉我们，这正是可能改变的。</p> <p>我们让编译器在生成的虚拟 DOM 树中去直接为我们编码信息，所以这些是当你只是手工写的时候，你通常得不到的额外信息。</p> <p>我们可能需要做其他事情。当你有一个指令，比如 v-if，这就是我们所说的结构指令，因为它可能会改变节点结构。当这个被切换时，整个 div 就会从树上消失。所以，对于这个根 block，它再也不能对此做出安全的假设了。</p> <p><img src="/assets/img/image-20211020165250727.ee3537a6.png" alt="image-20211020165250727"></p> <p>相反，我们把这个完整的 if 部分变成一个块。这个块作为其父块的动态子级被跟踪了。</p> <p>所以我们有嵌套的块和每个块，将在扁平数组中跟踪它自己的动态子对象。</p> <p>现在，因为在我们的整个模板中，模板中可能有数百个 DOM 节点，但通常你只会有一些这样的 v-if 和 v -for。所以，我们基本上还是需要遍历块树。</p> <p>然而，大多数情况下是扁平数组迭代而不是去 diff 和比较检查潜在的节点移动，所以效率更高。我们也基本上减少了递归的数量，在大多数情况下减少一个数量级，因为不必检查每个 vnode 的变化。</p> <p>我现在就去找 block，而且关于值内部可能发生的变化，我还有其他信息。</p> <p>对于每个节点，补丁标志本身还编码了关于你需要在这个节点上做什么样的工作的信息。</p> <p>例如，这个文本标志意味着，当你试图区分这个节点时，你只需要检查它的文本内容，你不必担心它的 props，将所有这些结合起来，编译器将真正生成一个运行时渲染函数，它允许运行时利用所有这些提示，做尽可能少的工作。</p> <p>让我们考虑一下虚拟 DOM 渲染 API 看起来是什么样的。</p> <p>你要做的第一件事就是我们需要有 h 函数本身，以及 h 函数的特征会是像 tag，props，children。</p> <p>我们也想要一些我们称之为挂载函数的东西，所以 mount 会接收我们所说的 vnode，也就是每次调用的结果。还有一个容器，容器只是 DOM 元素，我们可以把东西放进去。</p> <p>现在，如果我们页面上有一个 ID 为 app 的 div，如果在 Vue 中直接使用虚拟 dom API，这是您通常会编写的代码：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">function</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token parameter">tag<span class="token punctuation">,</span> props<span class="token punctuation">,</span> children</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
    
<span class="token keyword">function</span> <span class="token function">mount</span><span class="token punctuation">(</span><span class="token parameter">vnode<span class="token punctuation">,</span> container</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
    
<span class="token keyword">const</span> vdom <span class="token operator">=</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">class</span><span class="token operator">:</span> <span class="token string">'red'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
    <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">mount</span><span class="token punctuation">(</span>vdom<span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'app'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>所以我们希望能够创造虚拟 DOM 的快照，使用 h 函数，然后我们可以加载虚拟的 DOM 树变成了真正的 DOM 节点。</p> <p>看到他们出现在这里，这会给你一个想法。作为一个顶层或基层的角度，Vue 内部的事情是如何运作的。所以，很明显，这个例子会有很多边缘情况，我们就忽略了。</p> <p>是的，为了得到一个想法，它应该如何工作，整个要点就是得到一个非常非常小的版本。</p> <p>如果你想要一个好的挑战，就试试看吧。然后在下一课中，我们将向您展示 Evan 将如何实现。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue3-deep-dive/use-render-function.html" class="prev">
        使用渲染函数
      </a></span> <span class="next"><a href="/vue3-deep-dive/creating-a-mount-function.html">
        创建 Mount 函数
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.fe03ab5e.js" defer></script><script src="/assets/js/2.1f5ff3fb.js" defer></script><script src="/assets/js/3.c3ea9630.js" defer></script>
  </body>
</html>
