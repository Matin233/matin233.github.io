<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>创建 Mount 函数 | HiDoc</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.0e123b58.css" as="style"><link rel="preload" href="/assets/js/app.fe03ab5e.js" as="script"><link rel="preload" href="/assets/js/2.1f5ff3fb.js" as="script"><link rel="preload" href="/assets/js/4.d6136eb3.js" as="script"><link rel="prefetch" href="/assets/js/10.9768c84c.js"><link rel="prefetch" href="/assets/js/11.a026e0a2.js"><link rel="prefetch" href="/assets/js/12.dabf57c8.js"><link rel="prefetch" href="/assets/js/13.c77aa622.js"><link rel="prefetch" href="/assets/js/14.280e0fc5.js"><link rel="prefetch" href="/assets/js/15.0e1e201b.js"><link rel="prefetch" href="/assets/js/16.a396a055.js"><link rel="prefetch" href="/assets/js/17.b7d94a0d.js"><link rel="prefetch" href="/assets/js/18.1fcf8e89.js"><link rel="prefetch" href="/assets/js/19.70c96dc8.js"><link rel="prefetch" href="/assets/js/20.57a7fb21.js"><link rel="prefetch" href="/assets/js/21.b4eb4bc0.js"><link rel="prefetch" href="/assets/js/22.35179f79.js"><link rel="prefetch" href="/assets/js/23.576e6489.js"><link rel="prefetch" href="/assets/js/24.9dd3f0ff.js"><link rel="prefetch" href="/assets/js/25.0cf8dc8f.js"><link rel="prefetch" href="/assets/js/26.afc031d5.js"><link rel="prefetch" href="/assets/js/27.429d522c.js"><link rel="prefetch" href="/assets/js/28.6486f2ff.js"><link rel="prefetch" href="/assets/js/29.86dde356.js"><link rel="prefetch" href="/assets/js/3.c3ea9630.js"><link rel="prefetch" href="/assets/js/30.db155db7.js"><link rel="prefetch" href="/assets/js/31.000152f7.js"><link rel="prefetch" href="/assets/js/32.e62c80dc.js"><link rel="prefetch" href="/assets/js/33.b844c11a.js"><link rel="prefetch" href="/assets/js/34.6835e5f5.js"><link rel="prefetch" href="/assets/js/35.6327d166.js"><link rel="prefetch" href="/assets/js/36.aed4243f.js"><link rel="prefetch" href="/assets/js/37.643994a2.js"><link rel="prefetch" href="/assets/js/38.e008e751.js"><link rel="prefetch" href="/assets/js/39.e28e6619.js"><link rel="prefetch" href="/assets/js/40.19f07b7b.js"><link rel="prefetch" href="/assets/js/41.30210dbb.js"><link rel="prefetch" href="/assets/js/5.df510ea4.js"><link rel="prefetch" href="/assets/js/6.50a4a862.js"><link rel="prefetch" href="/assets/js/7.a4dc71d5.js"><link rel="prefetch" href="/assets/js/8.05521ae8.js"><link rel="prefetch" href="/assets/js/9.32319f64.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0e123b58.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HiDoc</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vue3-deep-dive/intro" class="sidebar-heading clickable open"><span>Vue3 Deep Dive</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vue3-deep-dive/intro.html" class="sidebar-link">介绍</a></li><li><a href="/vue3-deep-dive/rendering-mechanism.html" class="sidebar-link">渲染机制</a></li><li><a href="/vue3-deep-dive/use-render-function.html" class="sidebar-link">使用渲染函数</a></li><li><a href="/vue3-deep-dive/compiler-and-renderer-api.html" class="sidebar-link">编译器和渲染器 API</a></li><li><a href="/vue3-deep-dive/creating-a-mount-function.html" aria-current="page" class="active sidebar-link">创建 Mount 函数</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="创建-mount-函数"><a href="#创建-mount-函数" class="header-anchor">#</a> 创建 Mount 函数</h1> <p>第一件事就是 h 函数。很简单，因为我们真的只是把三个参数放进一个对象。更有趣的是，我们如何在这里实现这个挂载函数。现在有很多假设，我们只是想让这更简单。</p> <p>首先让我们假设一切都是一个元素。第二件事是，我们还假设调用参数总是一样的顺序，所以如果你没有任何 props，您必须显式地传递 null。</p> <p>我们知道我们假设这总是一个元素节点。所以 vnode.tag 会告诉我们它是什么样的元素。所以当我们挂载一个虚拟 DOM 树时，我们正在创建相应的真实 DOM 节点。</p> <p><img src="/assets/img/image-20211022155021550.7bf290b6.png" alt="image-20211022155021550"></p> <p>现在，我们接下来要做的就是把它插入容器。中间有一些事情我们还需要处理，包括 props 和 children，所以如果 vnode 有 props，我们得反复检查 props 把它们分别放在元素上作为 DOM property 或 attribute。</p> <p><img src="/assets/img/image-20211022155926502.e58a55da.png" alt="image-20211022155926502"></p> <p>在实际执行中，我们必须考虑很多事情，例如检查是否应该设置作为 property 或 attribute 或者是一个事件监听者。但为了简单起见，我们假设一切都是 attribute，如果你有一个 id，它就会作为元素的 attribute 或者一个 class 被设置，在这种情况下，我们这里确实有一个 class。</p> <p><img src="/assets/img/image-20211022160650529.77278ab7.png" alt="image-20211022160650529"></p> <p>如果我们有孩子，我们再次做一个假设。我们假设孩子是一个字符串或虚拟节点数组，这样可以使我们的算法更容易处理。</p> <p>我们会说如果<code>vnode.children</code>等于字符串。如果我们有 child 在这里，我们能做的是...但是如果我们有一个 vNode 数组，这里我们知道这只能是子 vnode。这是我们可以进行一点递归的区域，因为我们已经有了挂载功能。所以我们可以说<code>mount(child)</code>，child 是 vnode。然后我们需要给它一个容器，是我们刚刚创建的元素，现在我们已经完成了一个非常基本的挂载功能。</p> <p><img src="/assets/img/image-20211022162056467.81797cc5.png" alt="image-20211022162056467"></p> <p>以上就是 mount 的部分了。</p> <p>下一个练习是关于 patch 的部分，即更新虚拟 DOM。</p> <p>对于要构建的应用程序，最初的挂载就是创造一些东西。以前没有以及随后的更新，我们希望尽可能多地重用。所以我们只修改其中的内容，而不是重新创建它们。</p> <p>所以如果我们有一个叫 patch 的东西。patch 函数将接收我们称之为n1，n2。n1 代表旧的虚拟 DOM，之前的快照，基本上表示当前屏幕上的内容。n2 将是新的快照，它代表了我们希望屏幕更新的内容。</p> <p>是的，所以这是我们的工作，或者是 patch 函数的工作——找出它需要执行的，将屏幕更新到所需的状态的，最小数量的 DOM 操作。</p> <p>我们已经渲染了原始组件，它渲染了一次模板，把它变成了虚拟 DOM，然后一个响应式属性被更新，所以它触发了重新渲染，重新生成另一个表示形式虚拟 DOM。</p> <p>现在我们有两个虚拟 DOM，我们需要对两者进行比较。</p> <p>这是另一个快照</p> <p><img src="/assets/img/image-20211022163832340.ca9f72be.png" alt="image-20211022163832340"></p> <p>想象一下我们点击按钮，按钮改变了我们的组件状态。基本上说这个类现在应该是绿色的，并且应该修改这段文字。</p> <p>我们希望 DOM 反映更新后的状态，所以它（patch）将执行所有的需要更新的 DOM 操作</p> <p>所以在我们这么做之前，我们需要对我们的算法做些小小的改变。</p> <p><img src="/assets/img/image-20211022164146732.ff9b6c56.png" alt="image-20211022164146732"></p> <p>我们存储了相应的实际 DOM 元素到 vnode 本身，所以现在当你看到以前的 vDOM 时，您可以使用<code>.el</code>访问旧的真实 DOM 树。所以有了这个改变，我们应该把一切都准备好了。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vue3-deep-dive/compiler-and-renderer-api.html" class="prev">
        编译器和渲染器 API
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.fe03ab5e.js" defer></script><script src="/assets/js/2.1f5ff3fb.js" defer></script><script src="/assets/js/4.d6136eb3.js" defer></script>
  </body>
</html>
