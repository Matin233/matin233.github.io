(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{413:function(t,s,a){"use strict";a.r(s);var n=a(44),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"渲染机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染机制"}},[t._v("#")]),t._v(" 渲染机制")]),t._v(" "),a("p",[t._v("拥有虚拟 DOM 层有一些好处。最重要的是，它让组件的渲染逻辑完全从真实 DOM 中解耦，并让它更直接地重用框架的运行时。")]),t._v(" "),a("p",[t._v("在其他环境中，例如，Vue 允许第三方开发人员创建自定义渲染解决方案，目标不仅仅是浏览器，也包括 iOS 和 Android 等原生环境，也可以使用 API 创建自定义渲染器直接渲染到 WebGL 而不是 DOM 节点。")]),t._v(" "),a("p",[t._v("所以，在 Vue 2 中我们实际上已经有了这种能力。但是，我们在 Vue 2 中提供的 API 没有正式记录。并且需要分叉源代码，所以对开发这些定制解决方案的开发人员来说，维护代码成为了很大的负担。")]),t._v(" "),a("p",[t._v("在 Vue 3 中，我们让自定义渲染器 API 成为一等公民，因此开发人员可以直接拉取 Vue 运行时核心作为依赖项，然后利用自定义渲染器 API 构建自己的自定义渲染器。事实上，我们已经有了早期用户报告他们已经使用 Vue 3 API 成功地构建了一个 WebGL 渲染器。")]),t._v(" "),a("p",[t._v("关于虚拟 DOM 的另一个重要方面是它提供了能力，以编程方式构造、检查、克隆以及操作所需的 DOM结构。在实际返回渲染引擎之前，你可以利用 JavaScript 的全部能力。")]),t._v(" "),a("p",[t._v("现在，这个能力很重要。因为总会有某些情况下，在 UI 编程中，使用模板语法会有一些限制。你只需要一种有充分灵活性的合适的编程语言来表达潜在的逻辑。")]),t._v(" "),a("p",[t._v("在日常 UI 开发中，这种情况实际上是相当罕见的。但当你在创作一个库或编写 UI 组件套件供第三方开发者使用的时候，这种情况更常见。")]),t._v(" "),a("p",[t._v("让我们想象一下一个像复杂类型的顶部框这样的组件，或者一个与一堆文本相关联的输入框。这些类型的组件通常包含很少的标记，但它们将包含很多交互逻辑。")]),t._v(" "),a("p",[t._v("在这些情况下，模板语法有时候会限制你更容易地表达潜在的逻辑，或者有时候你会发现自己在模板中加入了很多逻辑，但你在 JavaScript 中还是有很多逻辑。而 render 函数允许你把这些逻辑组合在一个地方。你通常不需要想太多，在 99% 的情况模板会完成你要做的事下你只需要写出 HTML 就好了，但偶尔你可能想做些更可控的事情，在这种情况下，你需要编写一个渲染函数。")]),t._v(" "),a("p",[t._v("Vue 2 中的渲染函数如下所示：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("h")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("h")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        attrs"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        on"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            click"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("onClick\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这是组件定义中的一个选项，相比于提供一个 template 选项，你可以为组件提供一个渲染函数。在 Vue 2 中，你会得到 h 参数。我们之前说过的，直接作为渲染函数的参数。你可以用它来创造虚拟 DOM 节点，简称 vnode。")]),t._v(" "),a("p",[t._v("vnode 接受第一个参数是类型，所以我们在这里创建一个 div。第二个参数是一个对象，包含 vnode 上的所有数据或属性。")]),t._v(" "),a("p",[t._v("在 Vue 2 中，API有点冗长。从某种意义上说，你必须指明传递给节点的绑定类型。")]),t._v(" "),a("p",[t._v("例如，如果要绑定属性，你必须把它嵌套在 attrs 对象下。如果要绑定事件侦听器，你得把它列在 on 下面。")]),t._v(" "),a("p",[t._v("第三个参数是这个 vnode 的子节点，所以直接传递一个字符串，是一个方便的 API，表明此节点只包含文本子节点，但它也可以是数组，包含更多子节点，所以你可以在这里有一个数组，并且嵌套了更多的嵌套 h 调用。")]),t._v(" "),a("p",[t._v("现在，我们改变了 API。目标是在 Vue 3 中简化它。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" h "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vue'")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("h")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'div'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        id"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        onClick"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("onClick\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("第一个显著的变化是，我们现在有了一个扁平的 props 结构。在这个意义上，当你调用h时，第二个参数现在总是一个扁平的对象，你可以直接给它传递一个属性。")]),t._v(" "),a("p",[t._v("这里我们只是给它一个 ID，按惯例监听器以 on 开头，所以任何带 on 的都会自动绑定为一个监听器，所以你不必考虑太多嵌套的问题。")]),t._v(" "),a("p",[t._v("在大多数情况下，你也不需要思考是应将其作为 attribute 绑定，还是 DOM 属性绑定，因为 Vue 将智能地，找出为你做这件事的最好方法。")]),t._v(" "),a("p",[t._v("实际上，我们检查这个 key 是否存在在原生 DOM 中作为属性。如果存在，我们会将其设置为 property，如果它不存在，我们将它设置为一个 attribute，到目前为止在实践中效果良好。")]),t._v(" "),a("p",[t._v("render API 的另一项改动是 h 函数。helper 现在是全局导入的，直接从 Vue 本身。这个变化主要来自一种挫折感。")]),t._v(" "),a("p",[t._v("在 Vue 2 中，因为 h 函数绑定到当前组件实例。所以当你想拆分一个大的渲染函数变成小一点的时候，你必须把这个 h 函数一路传递给这些分割函数。但有了全局引入的 h 函数。你导入一次就可以分割你的渲染函数，在同一个文件里分割多少个都行，就不用考虑这个问题。")])])}),[],!1,null,null,null);s.default=e.exports}}]);