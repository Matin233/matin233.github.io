(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],c=e[1],l=e[2],d=0,p=[];d<s.length;d++)i=s[d],Object.prototype.hasOwnProperty.call(o,i)&&o[i]&&p.push(o[i][0]),o[i]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(n[r]=c[r]);for(u&&u(e);p.length;)p.shift()();return a.push.apply(a,l||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var c=t[s];0!==o[c]&&(r=!1)}r&&(a.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},o={1:0},a=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=o[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=o[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"1f5ff3fb",3:"c3ea9630",4:"d6136eb3",5:"df510ea4",6:"50a4a862",7:"a4dc71d5",8:"05521ae8",9:"32319f64",10:"9768c84c",11:"a026e0a2",12:"dabf57c8",13:"c77aa622",14:"280e0fc5",15:"0e1e201b",16:"a396a055",17:"b7d94a0d",18:"1fcf8e89",19:"70c96dc8",20:"57a7fb21",21:"b4eb4bc0",22:"35179f79",23:"576e6489",24:"9dd3f0ff",25:"0cf8dc8f",26:"afc031d5",27:"429d522c",28:"6486f2ff",29:"86dde356",30:"db155db7",31:"000152f7",32:"e62c80dc",33:"b844c11a",34:"6835e5f5",35:"6327d166",36:"aed4243f",37:"643994a2",38:"e008e751",39:"e28e6619",40:"19f07b7b",41:"30210dbb"}[n]+".js"}(n);var c=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(l);var t=o[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;c.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",c.name="ChunkLoadError",c.type=r,c.request=a,t[1](c)}o[n]=void 0}};var l=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=e,s=s.slice();for(var l=0;l<s.length;l++)e(s[l]);var u=c;a.push([189,0]),t()}([function(n,e,t){var r=t(3),o=t(26).f,a=t(12),i=t(18),s=t(73),c=t(117),l=t(104);n.exports=function(n,e){var t,u,d,p,f,m=n.target,h=n.global,v=n.stat;if(t=h?r:v?r[m]||s(m,{}):(r[m]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(f=o(t,u))&&f.value:t[u],!l(h?u:m+(v?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;c(p,d)}(n.sham||d&&d.sham)&&a(p,"sham",!0),i(t,u,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(3),o=t(50),a=t(7),i=t(52),s=t(75),c=t(112),l=o("wks"),u=r.Symbol,d=c?u:u&&u.withoutSetter||i;n.exports=function(n){return a(l,n)&&(s||"string"==typeof l[n])||(s&&a(u,n)?l[n]=u[n]:l[n]=d("Symbol."+n)),l[n]}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n))throw TypeError(String(n)+" is not an object");return n}},function(n,e,t){var r=t(1);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(10),o={}.hasOwnProperty;n.exports=Object.hasOwn||function(n,e){return o.call(r(n),e)}},function(n,e,t){var r=t(6),o=t(110),a=t(5),i=t(51),s=Object.defineProperty;e.f=r?s:function(n,e,t){if(a(n),e=i(e,!0),a(t),o)try{return s(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(83),o=t(18),a=t(201);r||o(Object.prototype,"toString",a,{unsafe:!0})},function(n,e,t){var r=t(23);n.exports=function(n){return Object(r(n))}},function(n,e,t){"use strict";var r=t(107).charAt,o=t(24),a=t(116),i=o.set,s=o.getterFor("String Iterator");a(String,"String",(function(n){i(this,{type:"String Iterator",string:String(n),index:0})}),(function(){var n,e=s(this),t=e.string,o=e.index;return o>=t.length?{value:void 0,done:!0}:(n=r(t,o),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(6),o=t(8),a=t(32);n.exports=r?function(n,e,t){return o.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var r=t(46),o=Math.min;n.exports=function(n){return n>0?o(r(n),9007199254740991):0}},function(n,e,t){var r=t(36),o=t(23);n.exports=function(n){return r(o(n))}},function(n,e,t){var r=t(3),o=t(129),a=t(102),i=t(12),s=t(2),c=s("iterator"),l=s("toStringTag"),u=a.values;for(var d in o){var p=r[d],f=p&&p.prototype;if(f){if(f[c]!==u)try{i(f,c,u)}catch(n){f[c]=u}if(f[l]||i(f,l,d),o[d])for(var m in a)if(f[m]!==a[m])try{i(f,m,a[m])}catch(n){f[m]=a[m]}}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(140),o="object"==typeof self&&self&&self.Object===Object&&self,a=r||o||Function("return this")();n.exports=a},function(n,e,t){var r=t(3),o=t(12),a=t(7),i=t(73),s=t(79),c=t(24),l=c.get,u=c.enforce,d=String(String).split("String");(n.exports=function(n,e,t,s){var c,l=!!s&&!!s.unsafe,p=!!s&&!!s.enumerable,f=!!s&&!!s.noTargetGet;"function"==typeof t&&("string"!=typeof e||a(t,"name")||o(t,"name",e),(c=u(t)).source||(c.source=d.join("string"==typeof e?e:""))),n!==r?(l?!f&&n[e]&&(p=!0):delete n[e],p?n[e]=t:o(n,e,t)):p?n[e]=t:i(e,t)})(Function.prototype,"toString",(function(){return"function"==typeof this&&l(this).source||s(this)}))},function(n,e,t){var r=t(111),o=t(3),a=function(n){return"function"==typeof n?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n])||a(o[n]):r[n]&&r[n][e]||o[n]&&o[n][e]}},function(n,e){n.exports=!1},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(String(n)+" is not a function");return n}},function(n,e,t){var r=t(228),o=t(231);n.exports=function(n,e){var t=o(n,e);return r(t)?t:void 0}},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on "+n);return n}},function(n,e,t){var r,o,a,i=t(190),s=t(3),c=t(4),l=t(12),u=t(7),d=t(72),p=t(54),f=t(38),m=s.WeakMap;if(i||d.state){var h=d.state||(d.state=new m),v=h.get,g=h.has,x=h.set;r=function(n,e){if(g.call(h,n))throw new TypeError("Object already initialized");return e.facade=n,x.call(h,n,e),e},o=function(n){return v.call(h,n)||{}},a=function(n){return g.call(h,n)}}else{var y=p("state");f[y]=!0,r=function(n,e){if(u(n,y))throw new TypeError("Object already initialized");return e.facade=n,l(n,y,e),e},o=function(n){return u(n,y)?n[y]:{}},a=function(n){return u(n,y)}}n.exports={set:r,get:o,has:a,enforce:function(n){return a(n)?o(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=o(e)).type!==n)throw TypeError("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r,o=t(5),a=t(169),i=t(78),s=t(38),c=t(115),l=t(74),u=t(54),d=u("IE_PROTO"),p=function(){},f=function(n){return"<script>"+n+"<\/script>"},m=function(){try{r=document.domain&&new ActiveXObject("htmlfile")}catch(n){}var n,e;m=r?function(n){n.write(f("")),n.close();var e=n.parentWindow.Object;return n=null,e}(r):((e=l("iframe")).style.display="none",c.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(f("document.F=Object")),n.close(),n.F);for(var t=i.length;t--;)delete m.prototype[i[t]];return m()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=o(n),t=new p,p.prototype=null,t[d]=n):t=m(),void 0===e?t:a(t,e)}},function(n,e,t){var r=t(6),o=t(80),a=t(32),i=t(14),s=t(51),c=t(7),l=t(110),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=i(n),e=s(e,!0),l)try{return u(n,e)}catch(n){}if(c(n,e))return a(!o.f.call(n,e),n[e])}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e,t){"use strict";var r=t(0),o=t(30).filter;r({target:"Array",proto:!0,forced:!t(58)("filter")},{filter:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(48),o=t(36),a=t(10),i=t(13),s=t(108),c=[].push,l=function(n){var e=1==n,t=2==n,l=3==n,u=4==n,d=6==n,p=7==n,f=5==n||d;return function(m,h,v,g){for(var x,y,b=a(m),w=o(b),k=r(h,v,3),S=i(w.length),C=0,T=g||s,j=e?T(m,S):t||p?T(m,0):void 0;S>C;C++)if((f||C in w)&&(y=k(x=w[C],C,b),n))if(e)j[C]=y;else if(y)switch(n){case 3:return!0;case 5:return x;case 6:return C;case 2:c.call(j,x)}else switch(n){case 4:return!1;case 7:c.call(j,x)}return d?-1:l||u?u:j}};n.exports={forEach:l(0),map:l(1),filter:l(2),some:l(3),every:l(4),find:l(5),findIndex:l(6),filterOut:l(7)}},function(n,e,t){"use strict";var r=t(1);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(28);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){"use strict";var r=t(0),o=t(3),a=t(19),i=t(20),s=t(6),c=t(75),l=t(112),u=t(1),d=t(7),p=t(33),f=t(4),m=t(5),h=t(10),v=t(14),g=t(51),x=t(32),y=t(25),b=t(53),w=t(69),k=t(207),S=t(81),C=t(26),T=t(8),j=t(80),_=t(12),M=t(18),A=t(50),I=t(54),O=t(38),P=t(52),L=t(2),E=t(135),D=t(136),z=t(47),$=t(24),R=t(30).forEach,F=I("hidden"),N=L("toPrimitive"),B=$.set,W=$.getterFor("Symbol"),H=Object.prototype,V=o.Symbol,U=a("JSON","stringify"),q=C.f,X=T.f,J=k.f,G=j.f,K=A("symbols"),Y=A("op-symbols"),Q=A("string-to-symbol-registry"),Z=A("symbol-to-string-registry"),nn=A("wks"),en=o.QObject,tn=!en||!en.prototype||!en.prototype.findChild,rn=s&&u((function(){return 7!=y(X({},"a",{get:function(){return X(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=q(H,e);r&&delete H[e],X(n,e,t),r&&n!==H&&X(H,e,r)}:X,on=function(n,e){var t=K[n]=y(V.prototype);return B(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},an=l?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof V},sn=function(n,e,t){n===H&&sn(Y,e,t),m(n);var r=g(e,!0);return m(t),d(K,r)?(t.enumerable?(d(n,F)&&n[F][r]&&(n[F][r]=!1),t=y(t,{enumerable:x(0,!1)})):(d(n,F)||X(n,F,x(1,{})),n[F][r]=!0),rn(n,r,t)):X(n,r,t)},cn=function(n,e){m(n);var t=v(e),r=b(t).concat(pn(t));return R(r,(function(e){s&&!ln.call(t,e)||sn(n,e,t[e])})),n},ln=function(n){var e=g(n,!0),t=G.call(this,e);return!(this===H&&d(K,e)&&!d(Y,e))&&(!(t||!d(this,e)||!d(K,e)||d(this,F)&&this[F][e])||t)},un=function(n,e){var t=v(n),r=g(e,!0);if(t!==H||!d(K,r)||d(Y,r)){var o=q(t,r);return!o||!d(K,r)||d(t,F)&&t[F][r]||(o.enumerable=!0),o}},dn=function(n){var e=J(v(n)),t=[];return R(e,(function(n){d(K,n)||d(O,n)||t.push(n)})),t},pn=function(n){var e=n===H,t=J(e?Y:v(n)),r=[];return R(t,(function(n){!d(K,n)||e&&!d(H,n)||r.push(K[n])})),r};(c||(M((V=function(){if(this instanceof V)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=P(n),t=function(n){this===H&&t.call(Y,n),d(this,F)&&d(this[F],e)&&(this[F][e]=!1),rn(this,e,x(1,n))};return s&&tn&&rn(H,e,{configurable:!0,set:t}),on(e,n)}).prototype,"toString",(function(){return W(this).tag})),M(V,"withoutSetter",(function(n){return on(P(n),n)})),j.f=ln,T.f=sn,C.f=un,w.f=k.f=dn,S.f=pn,E.f=function(n){return on(L(n),n)},s&&(X(V.prototype,"description",{configurable:!0,get:function(){return W(this).description}}),i||M(H,"propertyIsEnumerable",ln,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:V}),R(b(nn),(function(n){D(n)})),r({target:"Symbol",stat:!0,forced:!c},{for:function(n){var e=String(n);if(d(Q,e))return Q[e];var t=V(e);return Q[e]=t,Z[t]=e,t},keyFor:function(n){if(!an(n))throw TypeError(n+" is not a symbol");if(d(Z,n))return Z[n]},useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(n,e){return void 0===e?y(n):cn(y(n),e)},defineProperty:sn,defineProperties:cn,getOwnPropertyDescriptor:un}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:dn,getOwnPropertySymbols:pn}),r({target:"Object",stat:!0,forced:u((function(){S.f(1)}))},{getOwnPropertySymbols:function(n){return S.f(h(n))}}),U)&&r({target:"JSON",stat:!0,forced:!c||u((function(){var n=V();return"[null]"!=U([n])||"{}"!=U({a:n})||"{}"!=U(Object(n))}))},{stringify:function(n,e,t){for(var r,o=[n],a=1;arguments.length>a;)o.push(arguments[a++]);if(r=e,(f(e)||void 0!==n)&&!an(n))return p(e)||(e=function(n,e){if("function"==typeof r&&(e=r.call(this,n,e)),!an(e))return e}),o[1]=e,U.apply(null,o)}});V.prototype[N]||_(V.prototype,N,V.prototype.valueOf),z(V,"Symbol"),O[F]=!0},function(n,e,t){var r=t(41),o=t(213),a=t(214),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?o(n):a(n)}},function(n,e,t){var r=t(1),o=t(28),a="".split;n.exports=r((function(){return!Object("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?a.call(n,""):Object(n)}:Object},function(n,e,t){var r,o,a=t(3),i=t(76),s=a.process,c=s&&s.versions,l=c&&c.v8;l?o=(r=l.split("."))[0]<4?1:r[0]+r[1]:i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(o=r[1]),n.exports=o&&+o},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){"use strict";var r=t(0),o=t(6),a=t(3),i=t(7),s=t(4),c=t(8).f,l=t(117),u=a.Symbol;if(o&&"function"==typeof u&&(!("description"in u.prototype)||void 0!==u().description)){var d={},p=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof p?new u(n):void 0===n?u():u(n);return""===n&&(d[e]=!0),e};l(p,u);var f=p.prototype=u.prototype;f.constructor=p;var m=f.toString,h="Symbol(test)"==String(u("test")),v=/^Symbol\((.*)\)[^)]+$/;c(f,"description",{configurable:!0,get:function(){var n=s(this)?this.valueOf():this,e=m.call(n);if(i(d,n))return"";var t=h?e.slice(7,-1):e.replace(v,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:p})}},function(n,e,t){var r=t(17).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(101);var r=t(43);t(34),t(40),t(9),t(59),t(11),t(15),t(137);var o=t(65);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(o.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";function r(n,e,t,r,o,a,i,s){var c,l="function"==typeof n?n.options:n;if(e&&(l.render=e,l.staticRenderFns=t,l._compiled=!0),r&&(l.functional=!0),a&&(l._scopeId="data-v-"+a),i?(c=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),o&&o.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},l._ssrRegister=c):o&&(c=s?function(){o.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:o),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(n,e){return c.call(e),u(n,e)}}else{var d=l.beforeCreate;l.beforeCreate=d?[].concat(d,c):[c]}return{exports:n,options:l}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(0),o=t(71);r({target:"RegExp",proto:!0,forced:/./.exec!==o},{exec:o})},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},function(n,e,t){var r=t(8).f,o=t(7),a=t(2)("toStringTag");n.exports=function(n,e,t){n&&!o(n=t?n:n.prototype,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e,t){var r=t(21);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 0:return function(){return n.call(e)};case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,o){return n.call(e,t,r,o)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){"use strict";var r=t(0),o=t(4),a=t(33),i=t(114),s=t(13),c=t(14),l=t(57),u=t(2),d=t(58)("slice"),p=u("species"),f=[].slice,m=Math.max;r({target:"Array",proto:!0,forced:!d},{slice:function(n,e){var t,r,u,d=c(this),h=s(d.length),v=i(n,h),g=i(void 0===e?h:e,h);if(a(d)&&("function"!=typeof(t=d.constructor)||t!==Array&&!a(t.prototype)?o(t)&&null===(t=t[p])&&(t=void 0):t=void 0,t===Array||void 0===t))return f.call(d,v,g);for(r=new(void 0===t?Array:t)(m(g-v,0)),u=0;v<g;v++,u++)v in d&&l(r,u,d[v]);return r.length=u,r}})},function(n,e,t){var r=t(20),o=t(72);(n.exports=function(n,e){return o[n]||(o[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.15.2",mode:r?"pure":"global",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})},function(n,e,t){var r=t(4);n.exports=function(n,e){if(!r(n))return n;var t,o;if(e&&"function"==typeof(t=n.toString)&&!r(o=t.call(n)))return o;if("function"==typeof(t=n.valueOf)&&!r(o=t.call(n)))return o;if(!e&&"function"==typeof(t=n.toString)&&!r(o=t.call(n)))return o;throw TypeError("Can't convert object to primitive value")}},function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol("+String(void 0===n?"":n)+")_"+(++t+r).toString(36)}},function(n,e,t){var r=t(113),o=t(78);n.exports=Object.keys||function(n){return r(n,o)}},function(n,e,t){var r=t(50),o=t(52),a=r("keys");n.exports=function(n){return a[n]||(a[n]=o(n))}},function(n,e,t){var r=t(28),o=t(3);n.exports="process"==r(o.process)},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(9);function r(n,e,t,r,o,a,i){try{var s=n[a](i),c=s.value}catch(n){return void t(n)}s.done?e(c):Promise.resolve(c).then(r,o)}function o(n){return function(){var e=this,t=arguments;return new Promise((function(o,a){var i=n.apply(e,t);function s(n){r(i,o,a,s,c,"next",n)}function c(n){r(i,o,a,s,c,"throw",n)}s(void 0)}))}}},function(n,e,t){"use strict";var r=t(51),o=t(8),a=t(32);n.exports=function(n,e,t){var i=r(e);i in n?o.f(n,i,a(0,t)):n[i]=t}},function(n,e,t){var r=t(1),o=t(2),a=t(37),i=o("species");n.exports=function(n){return a>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){t(136)("iterator")},function(n,e,t){var r=t(218),o=t(219),a=t(220),i=t(221),s=t(222);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(142);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(22)(Object,"create");n.exports=r},function(n,e,t){var r=t(240);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(92);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(49),t(9),t(84),t(137),t(11);var r=t(43);function o(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,o;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(o="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function o(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=o(n,r.minimum,1),t.status=1===n?null:n;var c=t.render(!e),l=c.querySelector(r.barSelector),u=r.speed,d=r.easing;return c.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(l,function(n,e,t){var o;return(o="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,o}(n,u,d)),1===n?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*o(Math.random()*e,.1,.95)),e=o(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var o,i=e.querySelector(r.barSelector),c=n?"-100":a(t.status||0),u=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(o=e.querySelector(r.spinnerSelector))&&p(o),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,o=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);o--;)if((r=n[o]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,o,a=arguments;if(2==a.length)for(t in e)void 0!==(o=e[t])&&e.hasOwnProperty(t)&&r(n,t,o);else r(n,a[1],a[2])}}();function c(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function l(n,e){var t=d(n),r=t+e;c(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);c(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=o)},function(n,e,t){"use strict";var r=t(0),o=t(30).map;r({target:"Array",proto:!0,forced:!t(58)("map")},{map:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(166),o=t(1),a=t(5),i=t(13),s=t(46),c=t(23),l=t(174),u=t(209),d=t(167),p=t(2)("replace"),f=Math.max,m=Math.min,h="$0"==="a".replace(/./,"$0"),v=!!/./[p]&&""===/./[p]("a","$0");r("replace",(function(n,e,t){var r=v?"$":"$0";return[function(n,t){var r=c(this),o=null==n?void 0:n[p];return void 0!==o?o.call(n,r,t):e.call(String(r),n,t)},function(n,o){if("string"==typeof o&&-1===o.indexOf(r)&&-1===o.indexOf("$<")){var c=t(e,this,n,o);if(c.done)return c.value}var p=a(this),h=String(n),v="function"==typeof o;v||(o=String(o));var g=p.global;if(g){var x=p.unicode;p.lastIndex=0}for(var y=[];;){var b=d(p,h);if(null===b)break;if(y.push(b),!g)break;""===String(b[0])&&(p.lastIndex=l(h,i(p.lastIndex),x))}for(var w,k="",S=0,C=0;C<y.length;C++){b=y[C];for(var T=String(b[0]),j=f(m(s(b.index),h.length),0),_=[],M=1;M<b.length;M++)_.push(void 0===(w=b[M])?w:String(w));var A=b.groups;if(v){var I=[T].concat(_,j,h);void 0!==A&&I.push(A);var O=String(o.apply(void 0,I))}else O=u(T,h,j,_,A,o);j>=S&&(k+=h.slice(S,j)+O,S=j+T.length)}return k+h.slice(S)}]}),!!o((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!h||v)},function(n,e,t){var r=t(113),o=t(78).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,o)}},function(n,e,t){var r=t(5),o=t(191);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),o(a),e?n.call(t,a):t.__proto__=a,t}}():void 0)},function(n,e,t){"use strict";var r,o,a=t(172),i=t(173),s=t(50),c=t(25),l=t(24).get,u=t(184),d=t(185),p=RegExp.prototype.exec,f=s("native-string-replace",String.prototype.replace),m=p,h=(r=/a/,o=/b*/g,p.call(r,"a"),p.call(o,"a"),0!==r.lastIndex||0!==o.lastIndex),v=i.UNSUPPORTED_Y||i.BROKEN_CARET,g=void 0!==/()??/.exec("")[1];(h||g||v||u||d)&&(m=function(n){var e,t,r,o,i,s,u,d=this,x=l(d),y=x.raw;if(y)return y.lastIndex=d.lastIndex,e=m.call(y,n),d.lastIndex=y.lastIndex,e;var b=x.groups,w=v&&d.sticky,k=a.call(d),S=d.source,C=0,T=n;if(w&&(-1===(k=k.replace("y","")).indexOf("g")&&(k+="g"),T=String(n).slice(d.lastIndex),d.lastIndex>0&&(!d.multiline||d.multiline&&"\n"!==n[d.lastIndex-1])&&(S="(?: "+S+")",T=" "+T,C++),t=new RegExp("^(?:"+S+")",k)),g&&(t=new RegExp("^"+S+"$(?!\\s)",k)),h&&(r=d.lastIndex),o=p.call(w?t:d,T),w?o?(o.input=o.input.slice(C),o[0]=o[0].slice(C),o.index=d.lastIndex,d.lastIndex+=o[0].length):d.lastIndex=0:h&&o&&(d.lastIndex=d.global?o.index+o[0].length:r),g&&o&&o.length>1&&f.call(o[0],t,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(o[i]=void 0)})),o&&b)for(o.groups=s=c(null),i=0;i<b.length;i++)s[(u=b[i])[0]]=o[u[1]];return o}),n.exports=m},function(n,e,t){var r=t(3),o=t(73),a=r["__core-js_shared__"]||o("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(3),o=t(12);n.exports=function(n,e){try{o(r,n,e)}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(3),o=t(4),a=r.document,i=o(a)&&o(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},function(n,e,t){var r=t(37),o=t(1);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r=t(19);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(14),o=t(13),a=t(114),i=function(n){return function(e,t,i){var s,c=r(e),l=o(c.length),u=a(i,l);if(n&&t!=t){for(;l>u;)if((s=c[u++])!=s)return!0}else for(;l>u;u++)if((n||u in c)&&c[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(72),o=Function.toString;"function"!=typeof r.inspectSource&&(r.inspectSource=function(n){return o.call(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,o=Object.getOwnPropertyDescriptor,a=o&&!r.call({1:2},1);e.f=a?function(n){var e=o(this,n);return!!e&&e.enumerable}:r},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(7),o=t(10),a=t(54),i=t(120),s=a("IE_PROTO"),c=Object.prototype;n.exports=i?Object.getPrototypeOf:function(n){return n=o(n),r(n,s)?n[s]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?c:null}},function(n,e,t){var r={};r[t(2)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r=t(6),o=t(8).f,a=Function.prototype,i=a.toString,s=/^\s*function ([^ (]*)/;r&&!("name"in a)&&o(a,"name",{configurable:!0,get:function(){try{return i.call(this).match(s)[1]}catch(n){return""}}})},function(n,e,t){var r=t(212),o=t(27),a=Object.prototype,i=a.hasOwnProperty,s=a.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(n){return o(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=c},function(n,e,t){var r=t(22)(t(17),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(232),o=t(239),a=t(241),i=t(242),s=t(243);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(16),o=t(92),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,i=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(i.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(35),o=t(27);n.exports=function(n){return"symbol"==typeof n||o(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(101);t(34),t(40),t(9),t(59),t(11),t(15);var r=t(65);function o(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,o,a=[],i=!0,s=!1;try{for(t=t.call(n);!(i=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);i=!0);}catch(n){s=!0,o=n}finally{try{i||null==t.return||t.return()}finally{if(s)throw o}}return a}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(0),o=t(30).some;r({target:"Array",proto:!0,forced:!t(31)("some")},{some:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),o=t(10),a=t(53);r({target:"Object",stat:!0,forced:t(1)((function(){a(1)}))},{keys:function(n){return a(o(n))}})},function(n,e,t){"use strict";var r=t(0),o=t(133);r({target:"Array",proto:!0,forced:[].forEach!=o},{forEach:o})},function(n,e,t){var r=t(3),o=t(129),a=t(133),i=t(12);for(var s in o){var c=r[s],l=c&&c.prototype;if(l&&l.forEach!==a)try{i(l,"forEach",a)}catch(n){l.forEach=a}}},function(n,e,t){var r=t(105),o=t(39),a=t(2)("iterator");n.exports=function(n){if(null!=n)return n[a]||n["@@iterator"]||o[r(n)]}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},o=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function c(n,e,t,r){var o=e&&e.prototype instanceof d?e:d,a=Object.create(o.prototype),i=new S(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(o,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===o)throw a;return T()}for(t.method=o,t.arg=a;;){var i=t.delegate;if(i){var s=b(i,t);if(s){if(s===u)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var c=l(n,e,t);if("normal"===c.type){if(r=t.done?"completed":"suspendedYield",c.arg===u)continue;return{value:c.arg,done:t.done}}"throw"===c.type&&(r="completed",t.method="throw",t.arg=c.arg)}}}(n,t,i),a}function l(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=c;var u={};function d(){}function p(){}function f(){}var m={};m[o]=function(){return this};var h=Object.getPrototypeOf,v=h&&h(h(C([])));v&&v!==e&&t.call(v,o)&&(m=v);var g=f.prototype=d.prototype=Object.create(m);function x(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(o,a){function i(){return new e((function(r,i){!function r(o,a,i,s){var c=l(n[o],n,a);if("throw"!==c.type){var u=c.arg,d=u.value;return d&&"object"==typeof d&&t.call(d,"__await")?e.resolve(d.__await).then((function(n){r("next",n,i,s)}),(function(n){r("throw",n,i,s)})):e.resolve(d).then((function(n){u.value=n,i(u)}),(function(n){return r("throw",n,i,s)}))}s(c.arg)}(o,a,r,i)}))}return r=r?r.then(i,i):i()}}function b(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,b(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=l(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var o=r.arg;return o?o.done?(e[n.resultName]=o.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function S(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function C(n){if(n){var e=n[o];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:T}}function T(){return{value:void 0,done:!0}}return p.prototype=g.constructor=f,f.constructor=p,p.displayName=s(f,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,f):(n.__proto__=f,s(n,i,"GeneratorFunction")),n.prototype=Object.create(g),n},n.awrap=function(n){return{__await:n}},x(y.prototype),y.prototype[a]=function(){return this},n.AsyncIterator=y,n.async=function(e,t,r,o,a){void 0===a&&(a=Promise);var i=new y(c(e,t,r,o),a);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},x(g),s(g,i,"Generator"),g[o]=function(){return this},g.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=C,S.prototype={constructor:S,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],i=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),c=t.call(a,"finallyLoc");if(s&&c){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&t.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var a=o;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var i=a?a.completion:{};return i.type=n,i.arg=e,a?(this.method="next",this.next=a.finallyLoc,u):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var o=r.arg;k(t)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:C(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}},n}(n.exports);try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){t(0)({target:"Array",stat:!0},{isArray:t(33)})},function(n,e,t){"use strict";var r=t(14),o=t(103),a=t(39),i=t(24),s=t(116),c=i.set,l=i.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){c(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=l(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values"),a.Arguments=a.Array,o("keys"),o("values"),o("entries")},function(n,e,t){var r=t(2),o=t(25),a=t(8),i=r("unscopables"),s=Array.prototype;null==s[i]&&a.f(s,i,{configurable:!0,value:o(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var r=t(1),o=/#|\.prototype\./,a=function(n,e){var t=s[i(n)];return t==l||t!=c&&("function"==typeof e?r(e):!!e)},i=a.normalize=function(n){return String(n).replace(o,".").toLowerCase()},s=a.data={},c=a.NATIVE="N",l=a.POLYFILL="P";n.exports=a},function(n,e,t){var r=t(83),o=t(28),a=t(2)("toStringTag"),i="Arguments"==o(function(){return arguments}());n.exports=r?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),a))?t:i?o(e):"Object"==(r=o(e))&&"function"==typeof e.callee?"Arguments":r}},function(n,e,t){var r=t(5),o=t(21),a=t(2)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[a])?e:o(t)}},function(n,e,t){var r=t(46),o=t(23),a=function(n){return function(e,t){var a,i,s=String(o(e)),c=r(t),l=s.length;return c<0||c>=l?n?"":void 0:(a=s.charCodeAt(c))<55296||a>56319||c+1===l||(i=s.charCodeAt(c+1))<56320||i>57343?n?s.charAt(c):a:n?s.slice(c,c+2):i-56320+(a-55296<<10)+65536}};n.exports={codeAt:a(!1),charAt:a(!0)}},function(n,e,t){var r=t(4),o=t(33),a=t(2)("species");n.exports=function(n,e){var t;return o(n)&&("function"!=typeof(t=n.constructor)||t!==Array&&!o(t.prototype)?r(t)&&null===(t=t[a])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===e?0:e)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(6),o=t(1),a=t(74);n.exports=!r&&!o((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(3);n.exports=r},function(n,e,t){var r=t(75);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(7),o=t(14),a=t(77).indexOf,i=t(38);n.exports=function(n,e){var t,s=o(n),c=0,l=[];for(t in s)!r(i,t)&&r(s,t)&&l.push(t);for(;e.length>c;)r(s,t=e[c++])&&(~a(l,t)||l.push(t));return l}},function(n,e,t){var r=t(46),o=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?o(t+e,0):a(t,e)}},function(n,e,t){var r=t(19);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(0),o=t(178),a=t(82),i=t(70),s=t(47),c=t(12),l=t(18),u=t(2),d=t(20),p=t(39),f=t(119),m=f.IteratorPrototype,h=f.BUGGY_SAFARI_ITERATORS,v=u("iterator"),g=function(){return this};n.exports=function(n,e,t,u,f,x,y){o(t,e,u);var b,w,k,S=function(n){if(n===f&&M)return M;if(!h&&n in j)return j[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},C=e+" Iterator",T=!1,j=n.prototype,_=j[v]||j["@@iterator"]||f&&j[f],M=!h&&_||S(f),A="Array"==e&&j.entries||_;if(A&&(b=a(A.call(new n)),m!==Object.prototype&&b.next&&(d||a(b)===m||(i?i(b,m):"function"!=typeof b[v]&&c(b,v,g)),s(b,C,!0,!0),d&&(p[C]=g))),"values"==f&&_&&"values"!==_.name&&(T=!0,M=function(){return _.call(this)}),d&&!y||j[v]===M||c(j,v,M),p[e]=M,f)if(w={values:S("values"),keys:x?M:S("keys"),entries:S("entries")},y)for(k in w)(h||T||!(k in j))&&l(j,k,w[k]);else r({target:e,proto:!0,forced:h||T},w);return w}},function(n,e,t){var r=t(7),o=t(118),a=t(26),i=t(8);n.exports=function(n,e){for(var t=o(e),s=i.f,c=a.f,l=0;l<t.length;l++){var u=t[l];r(n,u)||s(n,u,c(e,u))}}},function(n,e,t){var r=t(19),o=t(69),a=t(81),i=t(5);n.exports=r("Reflect","ownKeys")||function(n){var e=o.f(i(n)),t=a.f;return t?e.concat(t(n)):e}},function(n,e,t){"use strict";var r,o,a,i=t(1),s=t(82),c=t(12),l=t(7),u=t(2),d=t(20),p=u("iterator"),f=!1;[].keys&&("next"in(a=[].keys())?(o=s(s(a)))!==Object.prototype&&(r=o):f=!0);var m=null==r||i((function(){var n={};return r[p].call(n)!==n}));m&&(r={}),d&&!m||l(r,p)||c(r,p,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:f}},function(n,e,t){var r=t(1);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(3);n.exports=r.Promise},function(n,e,t){var r=t(2),o=t(39),a=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(o.Array===n||i[a]===n)}},function(n,e,t){var r=t(5);n.exports=function(n){var e=n.return;if(void 0!==e)return r(e.call(n)).value}},function(n,e,t){var r=t(2)("iterator"),o=!1;try{var a=0,i={next:function(){return{done:!!a++}},return:function(){o=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!o)return!1;var t=!1;try{var a={};a[r]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){var r,o,a,i=t(3),s=t(1),c=t(48),l=t(115),u=t(74),d=t(126),p=t(55),f=i.location,m=i.setImmediate,h=i.clearImmediate,v=i.process,g=i.MessageChannel,x=i.Dispatch,y=0,b={},w=function(n){if(b.hasOwnProperty(n)){var e=b[n];delete b[n],e()}},k=function(n){return function(){w(n)}},S=function(n){w(n.data)},C=function(n){i.postMessage(n+"",f.protocol+"//"+f.host)};m&&h||(m=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return b[++y]=function(){("function"==typeof n?n:Function(n)).apply(void 0,e)},r(y),y},h=function(n){delete b[n]},p?r=function(n){v.nextTick(k(n))}:x&&x.now?r=function(n){x.now(k(n))}:g&&!d?(a=(o=new g).port2,o.port1.onmessage=S,r=c(a.postMessage,a,1)):i.addEventListener&&"function"==typeof postMessage&&!i.importScripts&&f&&"file:"!==f.protocol&&!s(C)?(r=C,i.addEventListener("message",S,!1)):r="onreadystatechange"in u("script")?function(n){l.appendChild(u("script")).onreadystatechange=function(){l.removeChild(this),w(n)}}:function(n){setTimeout(k(n),0)}),n.exports={set:m,clear:h}},function(n,e,t){var r=t(76);n.exports=/(?:iphone|ipod|ipad).*applewebkit/i.test(r)},function(n,e,t){var r=t(5),o=t(4),a=t(128);n.exports=function(n,e){if(r(n),o(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(21),o=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new o(n)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(0),o=t(1),a=t(10),i=t(82),s=t(120);r({target:"Object",stat:!0,forced:o((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(a(n))}})},function(n,e,t){var r=t(171);n.exports=function(n){if(r(n))throw TypeError("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(2)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(30).forEach,o=t(31)("forEach");n.exports=o?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(1);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(2);e.f=r},function(n,e,t){var r=t(111),o=t(7),a=t(135),i=t(8).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});o(e,n)||i(e,n,{value:a.f(n)})}},function(n,e,t){var r=t(0),o=t(183);r({target:"Array",stat:!0,forced:!t(124)((function(n){Array.from(n)}))},{from:o})},function(n,e,t){t(0)({target:"Object",stat:!0,sham:!t(6)},{create:t(25)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,o=n.length;++t<r;)n[o+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(60),o=t(223),a=t(224),i=t(225),s=t(226),c=t(227);function l(n){var e=this.__data__=new r(n);this.size=e.size}l.prototype.clear=o,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=s,l.prototype.set=c,n.exports=l},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(35),o=t(87);n.exports=function(n){if(!o(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(244),o=t(27);n.exports=function n(e,t,a,i,s){return e===t||(null==e||null==t||!o(e)&&!o(t)?e!=e&&t!=t:r(e,t,a,i,n,s))}},function(n,e,t){var r=t(147),o=t(247),a=t(148);n.exports=function(n,e,t,i,s,c){var l=1&t,u=n.length,d=e.length;if(u!=d&&!(l&&d>u))return!1;var p=c.get(n),f=c.get(e);if(p&&f)return p==e&&f==n;var m=-1,h=!0,v=2&t?new r:void 0;for(c.set(n,e),c.set(e,n);++m<u;){var g=n[m],x=e[m];if(i)var y=l?i(x,g,m,e,n,c):i(g,x,m,n,e,c);if(void 0!==y){if(y)continue;h=!1;break}if(v){if(!o(e,(function(n,e){if(!a(v,e)&&(g===n||s(g,n,t,i,c)))return v.push(e)}))){h=!1;break}}else if(g!==x&&!s(g,x,t,i,c)){h=!1;break}}return c.delete(n),c.delete(e),h}},function(n,e,t){var r=t(88),o=t(245),a=t(246);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=o,i.prototype.has=a,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(257),o=t(263),a=t(153);n.exports=function(n){return a(n)?r(n):o(n)}},function(n,e,t){(function(n){var r=t(17),o=t(259),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=i&&i.exports===a?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||o;n.exports=c}).call(this,t(109)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(260),o=t(261),a=t(262),i=a&&a.isTypedArray,s=i?o(i):r;n.exports=s},function(n,e,t){var r=t(143),o=t(90);n.exports=function(n){return null!=n&&o(n.length)&&!r(n)}},function(n,e,t){var r=t(22)(t(17),"Set");n.exports=r},function(n,e,t){var r=t(87);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(158),o=t(64);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[o(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(16),o=t(91),a=t(274),i=t(277);n.exports=function(n,e){return r(n)?n:o(n,e)?[n]:a(i(n))}},function(n,e,t){t(0)({target:"Object",stat:!0},{setPrototypeOf:t(70)})},function(n,e,t){var r=t(0),o=t(19),a=t(21),i=t(5),s=t(4),c=t(25),l=t(306),u=t(1),d=o("Reflect","construct"),p=u((function(){function n(){}return!(d((function(){}),[],n)instanceof n)})),f=!u((function(){d((function(){}))})),m=p||f;r({target:"Reflect",stat:!0,forced:m,sham:m},{construct:function(n,e){a(n),i(e);var t=arguments.length<3?n:a(arguments[2]);if(f&&!p)return d(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(l.apply(n,r))}var o=t.prototype,u=c(s(o)?o:Object.prototype),m=Function.apply.call(n,u,e);return s(m)?m:u}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(210),o=t(215),a=t(286),i=t(294),s=t(303),c=t(188),l=a((function(n){var e=c(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),o(e,2))}));n.exports=l},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,o=/^0b[01]+$/i,a=/^0o[0-7]+$/i,i=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,f=function(){return l.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=o.test(n);return s||a.test(n)?i(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,o,a,i,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function x(e){var t=r,a=o;return r=o=void 0,l=e,i=n.apply(a,t)}function y(n){return l=n,s=setTimeout(w,e),u?x(n):i}function b(n){var t=n-c;return void 0===c||t>=e||t<0||v&&n-l>=a}function w(){var n=f();if(b(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-c);return v?p(t,a-(n-l)):t}(n))}function k(n){return s=void 0,g&&r?x(n):(r=o=void 0,i)}function S(){var n=f(),t=b(n);if(r=arguments,o=this,c=n,t){if(void 0===s)return y(c);if(v)return s=setTimeout(w,e),x(c)}return void 0===s&&(s=setTimeout(w,e)),i}return e=h(e)||0,m(t)&&(u=!!t.leading,a=(v="maxWait"in t)?d(h(t.maxWait)||0,e):a,g="trailing"in t?!!t.trailing:g),S.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=o=s=void 0},S.flush=function(){return void 0===s?i:k(f())},S}},function(n,e,t){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?(n.exports=r=function(n){return typeof n},n.exports.default=n.exports,n.exports.__esModule=!0):(n.exports=r=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n.exports.default=n.exports,n.exports.__esModule=!0),r(e)}t(34),t(40),t(9),t(59),t(11),t(15),n.exports=r,n.exports.default=n.exports,n.exports.__esModule=!0},function(n,e,t){"use strict";t(45);var r=t(18),o=t(71),a=t(1),i=t(2),s=t(12),c=i("species"),l=RegExp.prototype;n.exports=function(n,e,t,u){var d=i(n),p=!a((function(){var e={};return e[d]=function(){return 7},7!=""[n](e)})),f=p&&!a((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[d]=/./[d]),t.exec=function(){return e=!0,null},t[d](""),!e}));if(!p||!f||t){var m=/./[d],h=e(d,""[n],(function(n,e,t,r,a){var i=e.exec;return i===o||i===l.exec?p&&!a?{done:!0,value:m.call(e,t,r)}:{done:!0,value:n.call(t,e,r)}:{done:!1}}));r(String.prototype,n,h[0]),r(l,d,h[1])}u&&s(l[d],"sham",!0)}},function(n,e,t){var r=t(28),o=t(71);n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var a=t.call(n,e);if("object"!=typeof a)throw TypeError("RegExp exec method returned something other than an Object or null");return a}if("RegExp"!==r(n))throw TypeError("RegExp#exec called on incompatible receiver");return o.call(n,e)}},function(n,e,t){"use strict";var r=t(0),o=t(77).indexOf,a=t(31),i=[].indexOf,s=!!i&&1/[1].indexOf(1,-0)<0,c=a("indexOf");r({target:"Array",proto:!0,forced:s||!c},{indexOf:function(n){return s?i.apply(this,arguments)||0:o(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(6),o=t(8),a=t(5),i=t(53);n.exports=r?Object.defineProperties:function(n,e){a(n);for(var t,r=i(e),s=r.length,c=0;s>c;)o.f(n,t=r[c++],e[t]);return n}},function(n,e){n.exports=function(n,e,t){if(!(n instanceof e))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return n}},function(n,e,t){var r=t(4),o=t(28),a=t(2)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==o(n))}},function(n,e,t){"use strict";var r=t(5);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(1),o=function(n,e){return RegExp(n,e)};e.UNSUPPORTED_Y=r((function(){var n=o("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=r((function(){var n=o("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},function(n,e,t){"use strict";var r=t(107).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){"use strict";var r=t(0),o=t(36),a=t(14),i=t(31),s=[].join,c=o!=Object,l=i("join",",");r({target:"Array",proto:!0,forced:c||!l},{join:function(n){return s.call(a(this),void 0===n?",":n)}})},function(n,e,t){"use strict";var r=t(0),o=t(1),a=t(33),i=t(4),s=t(10),c=t(13),l=t(57),u=t(108),d=t(58),p=t(2),f=t(37),m=p("isConcatSpreadable"),h=f>=51||!o((function(){var n=[];return n[m]=!1,n.concat()[0]!==n})),v=d("concat"),g=function(n){if(!i(n))return!1;var e=n[m];return void 0!==e?!!e:a(n)};r({target:"Array",proto:!0,forced:!h||!v},{concat:function(n){var e,t,r,o,a,i=s(this),d=u(i,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(g(a=-1===e?i:arguments[e])){if(p+(o=c(a.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<o;t++,p++)t in a&&l(d,p,a[t])}else{if(p>=9007199254740991)throw TypeError("Maximum allowed index exceeded");l(d,p++,a)}return d.length=p,d}})},function(n,e,t){var r=t(0),o=t(6);r({target:"Object",stat:!0,forced:!o,sham:!o},{defineProperty:t(8).f})},function(n,e,t){"use strict";var r=t(119).IteratorPrototype,o=t(25),a=t(32),i=t(47),s=t(39),c=function(){return this};n.exports=function(n,e,t){var l=e+" Iterator";return n.prototype=o(r,{next:a(1,t)}),i(n,l,!1,!0),s[l]=c,n}},function(n,e,t){var r=t(18);n.exports=function(n,e,t){for(var o in e)r(n,o,e[o],t);return n}},function(n,e,t){"use strict";var r=t(19),o=t(8),a=t(2),i=t(6),s=a("species");n.exports=function(n){var e=r(n),t=o.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){"use strict";var r=t(6),o=t(1),a=t(53),i=t(81),s=t(80),c=t(10),l=t(36),u=Object.assign,d=Object.defineProperty;n.exports=!u||o((function(){if(r&&1!==u({b:1},u(d({},"a",{enumerable:!0,get:function(){d(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=u({},n)[t]||"abcdefghijklmnopqrst"!=a(u({},e)).join("")}))?function(n,e){for(var t=c(n),o=arguments.length,u=1,d=i.f,p=s.f;o>u;)for(var f,m=l(arguments[u++]),h=d?a(m).concat(d(m)):a(m),v=h.length,g=0;v>g;)f=h[g++],r&&!p.call(m,f)||(t[f]=m[f]);return t}:u},function(n,e,t){var r=t(0),o=t(6),a=t(118),i=t(14),s=t(26),c=t(57);r({target:"Object",stat:!0,sham:!o},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),o=s.f,l=a(r),u={},d=0;l.length>d;)void 0!==(t=o(r,e=l[d++]))&&c(u,e,t);return u}})},function(n,e,t){"use strict";var r=t(48),o=t(10),a=t(208),i=t(122),s=t(13),c=t(57),l=t(99);n.exports=function(n){var e,t,u,d,p,f,m=o(n),h="function"==typeof this?this:Array,v=arguments.length,g=v>1?arguments[1]:void 0,x=void 0!==g,y=l(m),b=0;if(x&&(g=r(g,v>2?arguments[2]:void 0,2)),null==y||h==Array&&i(y))for(t=new h(e=s(m.length));e>b;b++)f=x?g(m[b],b):m[b],c(t,b,f);else for(p=(d=y.call(m)).next,t=new h;!(u=p.call(d)).done;b++)f=x?a(d,g,[u.value,b],!0):u.value,c(t,b,f);return t.length=b,t}},function(n,e,t){var r=t(1);n.exports=r((function(){var n=RegExp(".","string".charAt(0));return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){var r=t(1);n.exports=r((function(){var n=RegExp("(?<a>b)","string".charAt(5));return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){"use strict";var r=t(0),o=t(77).includes,a=t(103);r({target:"Array",proto:!0},{includes:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}}),a("includes")},function(n,e,t){"use strict";var r=t(0),o=t(131),a=t(23);r({target:"String",proto:!0,forced:!t(132)("includes")},{includes:function(n){return!!~String(a(this)).indexOf(o(n),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(309)},function(n,e,t){var r=t(3),o=t(79),a=r.WeakMap;n.exports="function"==typeof a&&/native code/.test(o(a))},function(n,e,t){var r=t(4);n.exports=function(n){if(!r(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},function(n,e,t){"use strict";var r,o,a,i,s=t(0),c=t(20),l=t(3),u=t(19),d=t(121),p=t(18),f=t(179),m=t(70),h=t(47),v=t(180),g=t(4),x=t(21),y=t(170),b=t(79),w=t(193),k=t(124),S=t(106),C=t(125).set,T=t(194),j=t(127),_=t(196),M=t(128),A=t(197),I=t(24),O=t(104),P=t(2),L=t(198),E=t(55),D=t(37),z=P("species"),$="Promise",R=I.get,F=I.set,N=I.getterFor($),B=d&&d.prototype,W=d,H=B,V=l.TypeError,U=l.document,q=l.process,X=M.f,J=X,G=!!(U&&U.createEvent&&l.dispatchEvent),K="function"==typeof PromiseRejectionEvent,Y=!1,Q=O($,(function(){var n=b(W),e=n!==String(W);if(!e&&66===D)return!0;if(c&&!H.finally)return!0;if(D>=51&&/native code/.test(n))return!1;var t=new W((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[z]=r,!(Y=t.then((function(){}))instanceof r)||!e&&L&&!K})),Z=Q||!k((function(n){W.all(n).catch((function(){}))})),nn=function(n){var e;return!(!g(n)||"function"!=typeof(e=n.then))&&e},en=function(n,e){if(!n.notified){n.notified=!0;var t=n.reactions;T((function(){for(var r=n.value,o=1==n.state,a=0;t.length>a;){var i,s,c,l=t[a++],u=o?l.ok:l.fail,d=l.resolve,p=l.reject,f=l.domain;try{u?(o||(2===n.rejection&&an(n),n.rejection=1),!0===u?i=r:(f&&f.enter(),i=u(r),f&&(f.exit(),c=!0)),i===l.promise?p(V("Promise-chain cycle")):(s=nn(i))?s.call(i,d,p):d(i)):p(r)}catch(n){f&&!c&&f.exit(),p(n)}}n.reactions=[],n.notified=!1,e&&!n.rejection&&rn(n)}))}},tn=function(n,e,t){var r,o;G?((r=U.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),l.dispatchEvent(r)):r={promise:e,reason:t},!K&&(o=l["on"+n])?o(r):"unhandledrejection"===n&&_("Unhandled promise rejection",t)},rn=function(n){C.call(l,(function(){var e,t=n.facade,r=n.value;if(on(n)&&(e=A((function(){E?q.emit("unhandledRejection",r,t):tn("unhandledrejection",t,r)})),n.rejection=E||on(n)?2:1,e.error))throw e.value}))},on=function(n){return 1!==n.rejection&&!n.parent},an=function(n){C.call(l,(function(){var e=n.facade;E?q.emit("rejectionHandled",e):tn("rejectionhandled",e,n.value)}))},sn=function(n,e,t){return function(r){n(e,r,t)}},cn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,en(n,!0))},ln=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw V("Promise can't be resolved itself");var r=nn(e);r?T((function(){var t={done:!1};try{r.call(e,sn(ln,t,n),sn(cn,t,n))}catch(e){cn(t,e,n)}})):(n.value=e,n.state=1,en(n,!1))}catch(e){cn({done:!1},e,n)}}};if(Q&&(H=(W=function(n){y(this,W,$),x(n),r.call(this);var e=R(this);try{n(sn(ln,e),sn(cn,e))}catch(n){cn(e,n)}}).prototype,(r=function(n){F(this,{type:$,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=f(H,{then:function(n,e){var t=N(this),r=X(S(this,W));return r.ok="function"!=typeof n||n,r.fail="function"==typeof e&&e,r.domain=E?q.domain:void 0,t.parent=!0,t.reactions.push(r),0!=t.state&&en(t,!1),r.promise},catch:function(n){return this.then(void 0,n)}}),o=function(){var n=new r,e=R(n);this.promise=n,this.resolve=sn(ln,e),this.reject=sn(cn,e)},M.f=X=function(n){return n===W||n===a?new o(n):J(n)},!c&&"function"==typeof d&&B!==Object.prototype)){i=B.then,Y||(p(B,"then",(function(n,e){var t=this;return new W((function(n,e){i.call(t,n,e)})).then(n,e)}),{unsafe:!0}),p(B,"catch",H.catch,{unsafe:!0}));try{delete B.constructor}catch(n){}m&&m(B,H)}s({global:!0,wrap:!0,forced:Q},{Promise:W}),h(W,$,!1,!0),v($),a=u($),s({target:$,stat:!0,forced:Q},{reject:function(n){var e=X(this);return e.reject.call(void 0,n),e.promise}}),s({target:$,stat:!0,forced:c||Q},{resolve:function(n){return j(c&&this===a?W:this,n)}}),s({target:$,stat:!0,forced:Z},{all:function(n){var e=this,t=X(e),r=t.resolve,o=t.reject,a=A((function(){var t=x(e.resolve),a=[],i=0,s=1;w(n,(function(n){var c=i++,l=!1;a.push(void 0),s++,t.call(e,n).then((function(n){l||(l=!0,a[c]=n,--s||r(a))}),o)})),--s||r(a)}));return a.error&&o(a.value),t.promise},race:function(n){var e=this,t=X(e),r=t.reject,o=A((function(){var o=x(e.resolve);w(n,(function(n){o.call(e,n).then(t.resolve,r)}))}));return o.error&&r(o.value),t.promise}})},function(n,e,t){var r=t(5),o=t(122),a=t(13),i=t(48),s=t(99),c=t(123),l=function(n,e){this.stopped=n,this.result=e};n.exports=function(n,e,t){var u,d,p,f,m,h,v,g=t&&t.that,x=!(!t||!t.AS_ENTRIES),y=!(!t||!t.IS_ITERATOR),b=!(!t||!t.INTERRUPTED),w=i(e,g,1+x+b),k=function(n){return u&&c(u),new l(!0,n)},S=function(n){return x?(r(n),b?w(n[0],n[1],k):w(n[0],n[1])):b?w(n,k):w(n)};if(y)u=n;else{if("function"!=typeof(d=s(n)))throw TypeError("Target is not iterable");if(o(d)){for(p=0,f=a(n.length);f>p;p++)if((m=S(n[p]))&&m instanceof l)return m;return new l(!1)}u=d.call(n)}for(h=u.next;!(v=h.call(u)).done;){try{m=S(v.value)}catch(n){throw c(u),n}if("object"==typeof m&&m&&m instanceof l)return m}return new l(!1)}},function(n,e,t){var r,o,a,i,s,c,l,u,d=t(3),p=t(26).f,f=t(125).set,m=t(126),h=t(195),v=t(55),g=d.MutationObserver||d.WebKitMutationObserver,x=d.document,y=d.process,b=d.Promise,w=p(d,"queueMicrotask"),k=w&&w.value;k||(r=function(){var n,e;for(v&&(n=y.domain)&&n.exit();o;){e=o.fn,o=o.next;try{e()}catch(n){throw o?i():a=void 0,n}}a=void 0,n&&n.enter()},m||v||h||!g||!x?b&&b.resolve?((l=b.resolve(void 0)).constructor=b,u=l.then,i=function(){u.call(l,r)}):i=v?function(){y.nextTick(r)}:function(){f.call(d,r)}:(s=!0,c=x.createTextNode(""),new g(r).observe(c,{characterData:!0}),i=function(){c.data=s=!s})),n.exports=k||function(n){var e={fn:n,next:void 0};a&&(a.next=e),o||(o=e,i()),a=e}},function(n,e,t){var r=t(76);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(3);n.exports=function(n,e){var t=r.console;t&&t.error&&(1===arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e){n.exports="object"==typeof window},function(n,e,t){var r=t(0),o=t(181);r({target:"Object",stat:!0,forced:Object.assign!==o},{assign:o})},function(n,e,t){"use strict";var r=t(0),o=t(20),a=t(121),i=t(1),s=t(19),c=t(106),l=t(127),u=t(18);if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&i((function(){a.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t="function"==typeof n;return this.then(t?function(t){return l(e,n()).then((function(){return t}))}:n,t?function(t){return l(e,n()).then((function(){throw t}))}:n)}}),!o&&"function"==typeof a){var d=s("Promise").prototype.finally;a.prototype.finally!==d&&u(a.prototype,"finally",d,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(83),o=t(105);n.exports=r?{}.toString:function(){return"[object "+o(this)+"]"}},function(n,e,t){"use strict";var r=t(0),o=t(203).left,a=t(31),i=t(37),s=t(55);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&i>79&&i<83},{reduce:function(n){return o(this,n,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(21),o=t(10),a=t(36),i=t(13),s=function(n){return function(e,t,s,c){r(t);var l=o(e),u=a(l),d=i(l.length),p=n?d-1:0,f=n?-1:1;if(s<2)for(;;){if(p in u){c=u[p],p+=f;break}if(p+=f,n?p<0:d<=p)throw TypeError("Reduce of empty array with no initial value")}for(;n?p>=0:d>p;p+=f)p in u&&(c=t(c,u[p],p,l));return c}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){"use strict";var r,o=t(0),a=t(26).f,i=t(13),s=t(131),c=t(23),l=t(132),u=t(20),d="".startsWith,p=Math.min,f=l("startsWith");o({target:"String",proto:!0,forced:!!(u||f||(r=a(String.prototype,"startsWith"),!r||r.writable))&&!f},{startsWith:function(n){var e=String(c(this));s(n);var t=i(p(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return d?d.call(e,r,t):e.slice(t,t+r.length)===r}})},function(n,e,t){var r=t(0),o=t(134),a=t(1),i=t(4),s=t(206).onFreeze,c=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){c(1)})),sham:!o},{freeze:function(n){return c&&i(n)?c(s(n)):n}})},function(n,e,t){var r=t(38),o=t(4),a=t(7),i=t(8).f,s=t(52),c=t(134),l=s("meta"),u=0,d=Object.isExtensible||function(){return!0},p=function(n){i(n,l,{value:{objectID:"O"+u++,weakData:{}}})},f=n.exports={REQUIRED:!1,fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!a(n,l)){if(!d(n))return"F";if(!e)return"E";p(n)}return n[l].objectID},getWeakData:function(n,e){if(!a(n,l)){if(!d(n))return!0;if(!e)return!1;p(n)}return n[l].weakData},onFreeze:function(n){return c&&f.REQUIRED&&d(n)&&!a(n,l)&&p(n),n}};r[l]=!0},function(n,e,t){var r=t(14),o=t(69).f,a={}.toString,i="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return i&&"[object Window]"==a.call(n)?function(n){try{return o(n)}catch(n){return i.slice()}}(n):o(r(n))}},function(n,e,t){var r=t(5),o=t(123);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){throw o(n),e}}},function(n,e,t){var r=t(10),o=Math.floor,a="".replace,i=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,s=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,c,l,u){var d=t+n.length,p=c.length,f=s;return void 0!==l&&(l=r(l),f=i),a.call(u,f,(function(r,a){var i;switch(a.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(d);case"<":i=l[a.slice(1,-1)];break;default:var s=+a;if(0===s)return r;if(s>p){var u=o(s/10);return 0===u?r:u<=p?void 0===c[u-1]?a.charAt(1):c[u-1]+a.charAt(1):r}i=c[s-1]}return void 0===i?"":i}))}},function(n,e,t){var r=t(139),o=t(211);n.exports=function n(e,t,a,i,s){var c=-1,l=e.length;for(a||(a=o),s||(s=[]);++c<l;){var u=e[c];t>0&&a(u)?t>1?n(u,t-1,a,i,s):r(s,u):i||(s[s.length]=u)}return s}},function(n,e,t){var r=t(41),o=t(85),a=t(16),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||o(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(35),o=t(27);n.exports=function(n){return o(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(41),o=Object.prototype,a=o.hasOwnProperty,i=o.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var o=i.call(n);return r&&(e?n[s]=t:delete n[s]),o}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(216),o=t(272),a=t(93),i=t(16),s=t(283);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?i(n)?o(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(217),o=t(271),a=t(156);n.exports=function(n){var e=o(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(141),o=t(145);n.exports=function(n,e,t,a){var i=t.length,s=i,c=!a;if(null==n)return!s;for(n=Object(n);i--;){var l=t[i];if(c&&l[2]?l[1]!==n[l[0]]:!(l[0]in n))return!1}for(;++i<s;){var u=(l=t[i])[0],d=n[u],p=l[1];if(c&&l[2]){if(void 0===d&&!(u in n))return!1}else{var f=new r;if(a)var m=a(d,p,u,n,e,f);if(!(void 0===m?o(p,d,3,a,f):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(61),o=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():o.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(61);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(61);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(61);n.exports=function(n,e){var t=this.__data__,o=r(t,n);return o<0?(++this.size,t.push([n,e])):t[o][1]=e,this}},function(n,e,t){var r=t(60);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(60),o=t(86),a=t(88);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!o||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(143),o=t(229),a=t(87),i=t(144),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,d=l.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||o(n))&&(r(n)?p:s).test(i(n))}},function(n,e,t){var r,o=t(230),a=(r=/[^.]+$/.exec(o&&o.keys&&o.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(17)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(233),o=t(60),a=t(86);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||o),string:new r}}},function(n,e,t){var r=t(234),o=t(235),a=t(236),i=t(237),s=t(238);function c(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=i,c.prototype.set=s,n.exports=c},function(n,e,t){var r=t(62);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(62),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return o.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(62),o=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:o.call(e,n)}},function(n,e,t){var r=t(62);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(63);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(63);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(63);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(63);n.exports=function(n,e){var t=r(this,n),o=t.size;return t.set(n,e),this.size+=t.size==o?0:1,this}},function(n,e,t){var r=t(141),o=t(146),a=t(248),i=t(251),s=t(267),c=t(16),l=t(150),u=t(152),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,f,m,h){var v=c(n),g=c(e),x=v?"[object Array]":s(n),y=g?"[object Array]":s(e),b=(x="[object Arguments]"==x?d:x)==d,w=(y="[object Arguments]"==y?d:y)==d,k=x==y;if(k&&l(n)){if(!l(e))return!1;v=!0,b=!1}if(k&&!b)return h||(h=new r),v||u(n)?o(n,e,t,f,m,h):a(n,e,x,t,f,m,h);if(!(1&t)){var S=b&&p.call(n,"__wrapped__"),C=w&&p.call(e,"__wrapped__");if(S||C){var T=S?n.value():n,j=C?e.value():e;return h||(h=new r),m(T,j,t,f,h)}}return!!k&&(h||(h=new r),i(n,e,t,f,m,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(41),o=t(249),a=t(142),i=t(146),s=t(250),c=t(89),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;n.exports=function(n,e,t,r,l,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new o(n),new o(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var f=s;case"[object Set]":var m=1&r;if(f||(f=c),n.size!=e.size&&!m)return!1;var h=p.get(n);if(h)return h==e;r|=2,p.set(n,e);var v=i(f(n),f(e),r,l,d,p);return p.delete(n),v;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(17).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(252),o=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,i,s){var c=1&t,l=r(n),u=l.length;if(u!=r(e).length&&!c)return!1;for(var d=u;d--;){var p=l[d];if(!(c?p in e:o.call(e,p)))return!1}var f=s.get(n),m=s.get(e);if(f&&m)return f==e&&m==n;var h=!0;s.set(n,e),s.set(e,n);for(var v=c;++d<u;){var g=n[p=l[d]],x=e[p];if(a)var y=c?a(x,g,p,e,n,s):a(g,x,p,n,e,s);if(!(void 0===y?g===x||i(g,x,t,a,s):y)){h=!1;break}v||(v="constructor"==p)}if(h&&!v){var b=n.constructor,w=e.constructor;b==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof b&&b instanceof b&&"function"==typeof w&&w instanceof w||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var r=t(253),o=t(254),a=t(149);n.exports=function(n){return r(n,a,o)}},function(n,e,t){var r=t(139),o=t(16);n.exports=function(n,e,t){var a=e(n);return o(n)?a:r(a,t(n))}},function(n,e,t){var r=t(255),o=t(256),a=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return a.call(n,e)})))}:o;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=0,a=[];++t<r;){var i=n[t];e(i,t,n)&&(a[o++]=i)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(258),o=t(85),a=t(16),i=t(150),s=t(151),c=t(152),l=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),u=!t&&o(n),d=!t&&!u&&i(n),p=!t&&!u&&!d&&c(n),f=t||u||d||p,m=f?r(n.length,String):[],h=m.length;for(var v in n)!e&&!l.call(n,v)||f&&("length"==v||d&&("offset"==v||"parent"==v)||p&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,h))||m.push(v);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(35),o=t(90),a=t(27),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&o(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(140),o=e&&!e.nodeType&&e,a=o&&"object"==typeof n&&n&&!n.nodeType&&n,i=a&&a.exports===o&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||i&&i.binding&&i.binding("util")}catch(n){}}();n.exports=s}).call(this,t(109)(n))},function(n,e,t){var r=t(264),o=t(265),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return o(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(266)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(268),o=t(86),a=t(269),i=t(154),s=t(270),c=t(35),l=t(144),u=l(r),d=l(o),p=l(a),f=l(i),m=l(s),h=c;(r&&"[object DataView]"!=h(new r(new ArrayBuffer(1)))||o&&"[object Map]"!=h(new o)||a&&"[object Promise]"!=h(a.resolve())||i&&"[object Set]"!=h(new i)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=c(n),t="[object Object]"==e?n.constructor:void 0,r=t?l(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case f:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var r=t(22)(t(17),"DataView");n.exports=r},function(n,e,t){var r=t(22)(t(17),"Promise");n.exports=r},function(n,e,t){var r=t(22)(t(17),"WeakMap");n.exports=r},function(n,e,t){var r=t(155),o=t(149);n.exports=function(n){for(var e=o(n),t=e.length;t--;){var a=e[t],i=n[a];e[t]=[a,i,r(i)]}return e}},function(n,e,t){var r=t(145),o=t(273),a=t(280),i=t(91),s=t(155),c=t(156),l=t(64);n.exports=function(n,e){return i(n)&&s(e)?c(l(n),e):function(t){var i=o(t,n);return void 0===i&&i===e?a(t,n):r(e,i,3)}}},function(n,e,t){var r=t(157);n.exports=function(n,e,t){var o=null==n?void 0:r(n,e);return void 0===o?t:o}},function(n,e,t){var r=t(275),o=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(o,(function(n,t,r,o){e.push(r?o.replace(a,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(276);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(88);function o(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,o=e?e.apply(this,r):r[0],a=t.cache;if(a.has(o))return a.get(o);var i=n.apply(this,r);return t.cache=a.set(o,i)||a,i};return t.cache=new(o.Cache||r),t}o.Cache=r,n.exports=o},function(n,e,t){var r=t(278);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(41),o=t(279),a=t(16),i=t(92),s=r?r.prototype:void 0,c=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return o(e,n)+"";if(i(e))return c?c.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,o=Array(r);++t<r;)o[t]=e(n[t],t,n);return o}},function(n,e,t){var r=t(281),o=t(282);n.exports=function(n,e){return null!=n&&o(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(158),o=t(85),a=t(16),i=t(151),s=t(90),c=t(64);n.exports=function(n,e,t){for(var l=-1,u=(e=r(e,n)).length,d=!1;++l<u;){var p=c(e[l]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++l!=u?d:!!(u=null==n?0:n.length)&&s(u)&&i(p,u)&&(a(n)||o(n))}},function(n,e,t){var r=t(284),o=t(285),a=t(91),i=t(64);n.exports=function(n){return a(n)?r(i(n)):o(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(157);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(93),o=t(287),a=t(289);n.exports=function(n,e){return a(o(n,e,r),n+"")}},function(n,e,t){var r=t(288),o=Math.max;n.exports=function(n,e,t){return e=o(void 0===e?n.length-1:e,0),function(){for(var a=arguments,i=-1,s=o(a.length-e,0),c=Array(s);++i<s;)c[i]=a[e+i];i=-1;for(var l=Array(e+1);++i<e;)l[i]=a[i];return l[e]=t(c),r(n,this,l)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(290),o=t(293)(r);n.exports=o},function(n,e,t){var r=t(291),o=t(292),a=t(93),i=o?function(n,e){return o(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(22),o=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=o},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var o=t(),a=16-(o-r);if(r=o,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(147),o=t(295),a=t(300),i=t(148),s=t(301),c=t(89);n.exports=function(n,e,t){var l=-1,u=o,d=n.length,p=!0,f=[],m=f;if(t)p=!1,u=a;else if(d>=200){var h=e?null:s(n);if(h)return c(h);p=!1,u=i,m=new r}else m=e?[]:f;n:for(;++l<d;){var v=n[l],g=e?e(v):v;if(v=t||0!==v?v:0,p&&g==g){for(var x=m.length;x--;)if(m[x]===g)continue n;e&&m.push(g),f.push(v)}else u(m,g,t)||(m!==f&&m.push(g),f.push(v))}return f}},function(n,e,t){var r=t(296);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(297),o=t(298),a=t(299);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,o,t)}},function(n,e){n.exports=function(n,e,t,r){for(var o=n.length,a=t+(r?1:-1);r?a--:++a<o;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,o=n.length;++r<o;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,o=null==n?0:n.length;++r<o;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(154),o=t(302),a=t(89),i=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:o;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(153),o=t(27);n.exports=function(n){return o(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=t(21),o=t(4),a=[].slice,i={},s=function(n,e,t){if(!(e in i)){for(var r=[],o=0;o<e;o++)r[o]="a["+o+"]";i[e]=Function("C,a","return new C("+r.join(",")+")")}return i[e](n,t)};n.exports=Function.bind||function(n){var e=r(this),t=a.call(arguments,1),i=function(){var r=t.concat(a.call(arguments));return this instanceof i?s(e,r.length,r):e.apply(n,r)};return o(e.prototype)&&(i.prototype=e.prototype),i}},function(n,e,t){"use strict";t(161)},function(n,e,t){"use strict";t(162)},function(n,e,t){"use strict";t.r(e);t(102),t(192),t(199),t(200);var r=t(56),o=(t(100),t(49),t(9),t(11),t(15),t(67),t(29),Object.freeze({}));function a(n){return null==n}function i(n){return null!=n}function s(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function d(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function f(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||d(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),r=n.split(","),o=0;o<r.length;o++)t[r[o]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var x=g("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var b=Object.prototype.hasOwnProperty;function w(n,e){return b.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,C=k((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),T=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,_=k((function(n){return n.replace(j,"-$1").toLowerCase()}));var M=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function I(n,e){for(var t in e)n[t]=e[t];return n}function O(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function P(n,e,t){}var L=function(n,e,t){return!1},E=function(n){return n};function D(n,e){if(n===e)return!0;var t=l(n),r=l(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var o=Array.isArray(n),a=Array.isArray(e);if(o&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(o||a)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function z(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function $(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:P,parsePlatformTagName:E,mustUseProp:L,async:!0,_lifecycleHooks:F},B=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function W(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var H=new RegExp("[^"+B.source+".$_\\d]");var V,U="__proto__"in{},q="undefined"!=typeof window,X="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=X&&WXEnvironment.platform.toLowerCase(),G=q&&window.navigator.userAgent.toLowerCase(),K=G&&/msie|trident/.test(G),Y=G&&G.indexOf("msie 9.0")>0,Q=G&&G.indexOf("edge/")>0,Z=(G&&G.indexOf("android"),G&&/iphone|ipad|ipod|ios/.test(G)||"ios"===J),nn=(G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G),G&&G.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(q)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===V&&(V=!q&&!X&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),V},an=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function sn(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,ln="undefined"!=typeof Symbol&&sn(Symbol)&&"undefined"!=typeof Reflect&&sn(Reflect.ownKeys);cn="undefined"!=typeof Set&&sn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=P,dn=0,pn=function(){this.id=dn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var fn=[];function mn(n){fn.push(n),pn.target=n}function hn(){fn.pop(),pn.target=fn[fn.length-1]}var vn=function(n,e,t,r,o,a,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=o,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,gn);var xn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function yn(n){return new vn(void 0,void 0,void 0,String(n))}function bn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];W(kn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var o,a=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":o=t;break;case"splice":o=t.slice(2)}return o&&i.observeArray(o),i.dep.notify(),a}))}));var Sn=Object.getOwnPropertyNames(kn),Cn=!0;function Tn(n){Cn=n}var jn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,W(n,"__ob__",this),Array.isArray(n)?(U?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var r=0,o=t.length;r<o;r++){var a=t[r];W(n,a,e[a])}}(n,kn,Sn),this.observeArray(n)):this.walk(n)};function _n(n,e){var t;if(l(n)&&!(n instanceof vn))return w(n,"__ob__")&&n.__ob__ instanceof jn?t=n.__ob__:Cn&&!on()&&(Array.isArray(n)||d(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new jn(n)),e&&t&&t.vmCount++,t}function Mn(n,e,t,r,o){var a=new pn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,c=i&&i.set;s&&!c||2!==arguments.length||(t=n[e]);var l=!o&&_n(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(a.depend(),l&&(l.dep.depend(),Array.isArray(e)&&On(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!c||(c?c.call(n,e):t=e,l=!o&&_n(e),a.notify())}})}}function An(n,e,t){if(Array.isArray(n)&&f(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Mn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function In(n,e){if(Array.isArray(n)&&f(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&On(e)}jn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Mn(n,e[t])},jn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)_n(n[e])};var Pn=N.optionMergeStrategies;function Ln(n,e){if(!e)return n;for(var t,r,o,a=ln?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++)"__ob__"!==(t=a[i])&&(r=n[t],o=e[t],w(n,t)?r!==o&&d(r)&&d(o)&&Ln(r,o):An(n,t,o));return n}function En(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,o="function"==typeof n?n.call(t,t):n;return r?Ln(r,o):o}:e?n?function(){return Ln("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Dn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function zn(n,e,t,r){var o=Object.create(n||null);return e?I(o,e):o}Pn.data=function(n,e,t){return t?En(n,e,t):e&&"function"!=typeof e?n:En(n,e)},F.forEach((function(n){Pn[n]=Dn})),R.forEach((function(n){Pn[n+"s"]=zn})),Pn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var a in I(o,n),e){var i=o[a],s=e[a];i&&!Array.isArray(i)&&(i=[i]),o[a]=i?i.concat(s):Array.isArray(s)?s:[s]}return o},Pn.props=Pn.methods=Pn.inject=Pn.computed=function(n,e,t,r){if(!n)return e;var o=Object.create(null);return I(o,n),e&&I(o,e),o},Pn.provide=En;var $n=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,o,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(a[C(o)]={type:null});else if(d(t))for(var i in t)o=t[i],a[C(i)]=d(o)?o:{type:o};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(d(t))for(var a in t){var i=t[a];r[a]=d(i)?I({from:a},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)n=Rn(n,e.mixins[r],t);var a,i={};for(a in n)s(a);for(a in e)w(n,a)||s(a);function s(r){var o=Pn[r]||$n;i[r]=o(n[r],e[r],t,r)}return i}function Fn(n,e,t,r){if("string"==typeof t){var o=n[e];if(w(o,t))return o[t];var a=C(t);if(w(o,a))return o[a];var i=T(a);return w(o,i)?o[i]:o[t]||o[a]||o[i]}}function Nn(n,e,t,r){var o=e[n],a=!w(t,n),i=t[n],s=Vn(Boolean,o.type);if(s>-1)if(a&&!w(o,"default"))i=!1;else if(""===i||i===_(n)){var c=Vn(String,o.type);(c<0||s<c)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Wn(e.type)?r.call(n):r}(r,o,n);var l=Cn;Tn(!0),_n(i),Tn(l)}return i}var Bn=/^\s*function (\w+)/;function Wn(n){var e=n&&n.toString().match(Bn);return e?e[1]:""}function Hn(n,e){return Wn(n)===Wn(e)}function Vn(n,e){if(!Array.isArray(e))return Hn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Hn(e[t],n))return t;return-1}function Un(n,e,t){mn();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var a=0;a<o.length;a++)try{if(!1===o[a].call(r,n,e,t))return}catch(n){Xn(n,r,"errorCaptured hook")}}Xn(n,e,t)}finally{hn()}}function qn(n,e,t,r,o){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&m(a)&&!a._handled&&(a.catch((function(n){return Un(n,r,o+" (Promise/async)")})),a._handled=!0)}catch(n){Un(n,r,o)}return a}function Xn(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Jn(e,null,"config.errorHandler")}Jn(n,e,t)}function Jn(n,e,t){if(!q&&!X||"undefined"==typeof console)throw n;console.error(n)}var Gn,Kn=!1,Yn=[],Qn=!1;function Zn(){Qn=!1;var n=Yn.slice(0);Yn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&sn(Promise)){var ne=Promise.resolve();Gn=function(){ne.then(Zn),Z&&setTimeout(P)},Kn=!0}else if(K||"undefined"==typeof MutationObserver||!sn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Gn="undefined"!=typeof setImmediate&&sn(setImmediate)?function(){setImmediate(Zn)}:function(){setTimeout(Zn,0)};else{var ee=1,te=new MutationObserver(Zn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Gn=function(){ee=(ee+1)%2,re.data=String(ee)},Kn=!0}function oe(n,e){var t;if(Yn.push((function(){if(n)try{n.call(e)}catch(n){Un(n,e,"nextTick")}else t&&t(e)})),Qn||(Qn=!0,Gn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new cn;function ie(n){!function n(e,t){var r,o,a=Array.isArray(e);if(!a&&!l(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(a)for(r=e.length;r--;)n(e[r],t);else for(o=Object.keys(e),r=o.length;r--;)n(e[o[r]],t)}(n,ae),ae.clear()}var se=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function ce(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return qn(r,null,arguments,e,"v-on handler");for(var o=r.slice(),a=0;a<o.length;a++)qn(o[a],null,n,e,"v-on handler")}return t.fns=n,t}function le(n,e,t,r,o,i){var c,l,u,d;for(c in n)l=n[c],u=e[c],d=se(c),a(l)||(a(u)?(a(l.fns)&&(l=n[c]=ce(l,i)),s(d.once)&&(l=n[c]=o(d.name,l,d.capture)),t(d.name,l,d.capture,d.passive,d.params)):l!==u&&(u.fns=l,n[c]=u));for(c in e)a(n[c])&&r((d=se(c)).name,e[c],d.capture)}function ue(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var o=n[e];function c(){t.apply(this,arguments),y(r.fns,c)}a(o)?r=ce([c]):i(o.fns)&&s(o.merged)?(r=o).fns.push(c):r=ce([o,c]),r.merged=!0,n[e]=r}function de(n,e,t,r,o){if(i(e)){if(w(e,t))return n[t]=e[t],o||delete e[t],!0;if(w(e,r))return n[t]=e[r],o||delete e[r],!0}return!1}function pe(n){return c(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,o,l,u,d=[];for(r=0;r<e.length;r++)a(o=e[r])||"boolean"==typeof o||(l=d.length-1,u=d[l],Array.isArray(o)?o.length>0&&(fe((o=n(o,(t||"")+"_"+r))[0])&&fe(u)&&(d[l]=yn(u.text+o[0].text),o.shift()),d.push.apply(d,o)):c(o)?fe(u)?d[l]=yn(u.text+o):""!==o&&d.push(yn(o)):fe(o)&&fe(u)?d[l]=yn(u.text+o.text):(s(e._isVList)&&i(o.tag)&&a(o.key)&&i(t)&&(o.key="__vlist"+t+"_"+r+"__"),d.push(o)));return d}(n):void 0}function fe(n){return i(n)&&i(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),r=ln?Reflect.ownKeys(n):Object.keys(n),o=0;o<r.length;o++){var a=r[o];if("__ob__"!==a){for(var i=n[a].from,s=e;s;){if(s._provided&&w(s._provided,i)){t[a]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[a]){var c=n[a].default;t[a]="function"==typeof c?c.call(e):c}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},r=0,o=n.length;r<o;r++){var a=n[r],i=a.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,a.context!==e&&a.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(a);else{var s=i.slot,c=t[s]||(t[s]=[]);"template"===a.tag?c.push.apply(c,a.children||[]):c.push(a)}}for(var l in t)t[l].every(ve)&&delete t[l];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function xe(n,e,t){var r,a=Object.keys(e).length>0,i=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==o&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var c in r={},n)n[c]&&"$"!==c[0]&&(r[c]=ye(e,c,n[c]))}else r={};for(var l in e)l in r||(r[l]=be(e,l));return n&&Object.isExtensible(n)&&(n._normalized=r),W(r,"$stable",i),W(r,"$key",s),W(r,"$hasNormal",a),r}function ye(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ge(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function we(n,e){var t,r,o,a,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,o=n.length;r<o;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)t.push(e(u.value,t.length)),u=c.next()}else for(a=Object.keys(n),t=new Array(a.length),r=0,o=a.length;r<o;r++)s=a[r],t[r]=e(n[s],s,r);return i(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,r){var o,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=I(I({},r),t)),o=a(t)||("function"==typeof e?e():e)):o=this.$slots[n]||("function"==typeof e?e():e);var i=t&&t.slot;return i?this.$createElement("template",{slot:i},o):o}function Se(n){return Fn(this.$options,"filters",n)||E}function Ce(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Te(n,e,t,r,o){var a=N.keyCodes[e]||t;return o&&r&&!N.keyCodes[e]?Ce(o,r):a?Ce(a,n):r?_(r)!==e:void 0===n}function je(n,e,t,r,o){if(t)if(l(t)){var a;Array.isArray(t)&&(t=O(t));var i=function(i){if("class"===i||"style"===i||x(i))a=n;else{var s=n.attrs&&n.attrs.type;a=r||N.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var c=C(i),l=_(i);c in a||l in a||(a[i]=t[i],o&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function _e(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Ae(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Me(n,e,t){return Ae(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ae(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ie(n[r],e+"_"+r,t);else Ie(n,e,t)}function Ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Oe(n,e){if(e)if(d(e)){var t=n.on=n.on?I({},n.on):{};for(var r in e){var o=t[r],a=e[r];t[r]=o?[].concat(o,a):a}}else;return n}function Pe(n,e,t,r){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var a=n[o];Array.isArray(a)?Pe(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Le(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Ee(n,e){return"string"==typeof n?e+n:n}function De(n){n._o=Me,n._n=v,n._s=h,n._l=we,n._t=ke,n._q=D,n._i=z,n._m=_e,n._f=Se,n._k=Te,n._b=je,n._v=yn,n._e=xn,n._u=Pe,n._g=Oe,n._d=Le,n._p=Ee}function ze(n,e,t,r,a){var i,c=this,l=a.options;w(r,"_uid")?(i=Object.create(r))._original=r:(i=r,r=r._original);var u=s(l._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||o,this.injections=me(l.inject,r),this.slots=function(){return c.$slots||xe(n.scopedSlots,c.$slots=he(t,r)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return xe(n.scopedSlots,this.slots())}}),u&&(this.$options=l,this.$slots=this.slots(),this.$scopedSlots=xe(n.scopedSlots,this.$slots)),l._scopeId?this._c=function(n,e,t,o){var a=He(i,n,e,t,o,d);return a&&!Array.isArray(a)&&(a.fnScopeId=l._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,r){return He(i,n,e,t,r,d)}}function $e(n,e,t,r,o){var a=bn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Re(n,e){for(var t in e)n[C(t)]=e[t]}De(ze.prototype);var Fe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Fe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Qe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var i=r.data.scopedSlots,s=n.$scopedSlots,c=!!(i&&!i.$stable||s!==o&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key||!i&&n.$scopedSlots.$key),l=!!(a||n.$options._renderChildren||c);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||o,n.$listeners=t||o,e&&n.$options.props){Tn(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var f=d[p],m=n.$options.props;u[f]=Nn(f,m,e,n)}Tn(!0),n.$options.propsData=e}t=t||o;var h=n.$options._parentListeners;n.$options._parentListeners=t,Ye(n,t,h),l&&(n.$slots=he(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,ot.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Ne=Object.keys(Fe);function Be(n,e,t,r,c){if(!a(n)){var u=t.$options._base;if(l(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Ue;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],o=!0,c=null,u=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==u&&(clearTimeout(u),u=null))},p=$((function(t){n.resolved=qe(t,e),o?r.length=0:d(!0)})),f=$((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),h=n(p,f);return l(h)&&(m(h)?a(n.resolved)&&h.then(p,f):m(h.component)&&(h.component.then(p,f),i(h.error)&&(n.errorComp=qe(h.error,e)),i(h.loading)&&(n.loadingComp=qe(h.loading,e),0===h.delay?n.loading=!0:c=setTimeout((function(){c=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),i(h.timeout)&&(u=setTimeout((function(){u=null,a(n.resolved)&&f(null)}),h.timeout)))),o=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,o){var a=xn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:o},a}(d,e,t,r,c);e=e||{},Ct(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),a=o[r],s=e.model.callback;i(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(o[r]=[s].concat(a)):o[r]=s}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,c=n.props;if(i(s)||i(c))for(var l in r){var u=_(l);de(o,c,l,u,!0)||de(o,s,l,u,!1)}return o}}(e,n);if(s(n.options.functional))return function(n,e,t,r,a){var s=n.options,c={},l=s.props;if(i(l))for(var u in l)c[u]=Nn(u,l,e||o);else i(t.attrs)&&Re(c,t.attrs),i(t.props)&&Re(c,t.props);var d=new ze(t,c,a,r,n),p=s.render.call(null,d._c,d);if(p instanceof vn)return $e(p,t,d.parent,s,d);if(Array.isArray(p)){for(var f=pe(p)||[],m=new Array(f.length),h=0;h<f.length;h++)m[h]=$e(f[h],t,d.parent,s,d);return m}}(n,p,e,t,r);var f=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Ne.length;t++){var r=Ne[t],o=e[r],a=Fe[r];o===a||o&&o._merged||(e[r]=o?We(a,o):a)}}(e);var v=n.options.name||c;return new vn("vue-component-"+n.cid+(v?"-"+v:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:f,tag:c,children:r},d)}}}function We(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function He(n,e,t,r,o,u){return(Array.isArray(t)||c(t))&&(o=r,r=t,t=void 0),s(u)&&(o=2),function(n,e,t,r,o){if(i(t)&&i(t.__ob__))return xn();i(t)&&i(t.is)&&(e=t.is);if(!e)return xn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===o?r=pe(r):1===o&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var c,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),c=N.isReservedTag(e)?new vn(N.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(d=Fn(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):Be(d,t,n,r,e)}else c=Be(e,t,n,r);return Array.isArray(c)?c:i(c)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var o=0,c=e.children.length;o<c;o++){var l=e.children[o];i(l.tag)&&(a(l.ns)||s(r)&&"svg"!==l.tag)&&n(l,t,r)}}(c,u),i(t)&&function(n){l(n.style)&&ie(n.style);l(n.class)&&ie(n.class)}(t),c):xn()}(n,e,t,r,o)}var Ve,Ue=null;function qe(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function Xe(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||ge(t)))return t}}function Je(n,e){Ve.$on(n,e)}function Ge(n,e){Ve.$off(n,e)}function Ke(n,e){var t=Ve;return function r(){var o=e.apply(null,arguments);null!==o&&t.$off(n,r)}}function Ye(n,e,t){Ve=n,le(e,t||{},Je,Ge,Ke,n),Ve=void 0}var Qe=null;function Ze(n){var e=Qe;return Qe=n,function(){Qe=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){mn();var t=n.$options[e],r=e+" hook";if(t)for(var o=0,a=t.length;o<a;o++)qn(t[o],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var rt=[],ot=[],at={},it=!1,st=!1,ct=0;var lt=0,ut=Date.now;if(q&&!K){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}function pt(){var n,e;for(lt=ut(),st=!0,rt.sort((function(n,e){return n.id-e.id})),ct=0;ct<rt.length;ct++)(n=rt[ct]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=ot.slice(),r=rt.slice();ct=rt.length=ot.length=0,at={},it=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),an&&N.devtools&&an.emit("flush")}var ft=0,mt=function(n,e,t,r,o){this.vm=n,o&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ft,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Un(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),hn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,st){for(var t=rt.length-1;t>ct&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);it||(it=!0,oe(pt))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';qn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:P,set:P};function vt(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function gt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},o=n.$options._propKeys=[];n.$parent&&Tn(!1);var a=function(a){o.push(a);var i=Nn(a,e,t,n);Mn(r,a,i),a in n||vt(n,"_props",a)};for(var i in e)a(i);Tn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:M(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;d(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return Un(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,o=(n.$options.methods,t.length);for(;o--;){var a=t[o];0,r&&w(r,a)||(i=void 0,36!==(i=(a+"").charCodeAt(0))&&95!==i&&vt(n,"_data",a))}var i;_n(e,!0)}(n):_n(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var o in e){var a=e[o],i="function"==typeof a?a:a.get;0,r||(t[o]=new mt(n,i||P,P,xt)),o in n||yt(n,o,a)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var o=0;o<r.length;o++)kt(n,t,r[o]);else kt(n,t,r)}}(n,e.watch)}var xt={lazy:!0};function yt(n,e,t){var r=!on();"function"==typeof t?(ht.get=r?bt(e):wt(t),ht.set=P):(ht.get=t.get?r&&!1!==t.cache?bt(e):wt(t.get):P,ht.set=t.set||P),Object.defineProperty(n,e,ht)}function bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,r){return d(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var St=0;function Ct(n){var e=n.options;if(n.super){var t=Ct(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var o in t)t[o]!==r[o]&&(e||(e={}),e[o]=t[o]);return e}(n);r&&I(n.extendOptions,r),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Tt(n){this._init(n)}function jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,o=n._Ctor||(n._Ctor={});if(o[r])return o[r];var a=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=Rn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,R.forEach((function(n){i[n]=t[n]})),a&&(i.options.components[a]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=I({},i.options),o[r]=i,i}}function _t(n){return n&&(n.Ctor.options.name||n.tag)}function Mt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function At(n,e){var t=n.cache,r=n.keys,o=n._vnode;for(var a in t){var i=t[a];if(i){var s=i.name;s&&!e(s)&&It(t,a,r,o)}}}function It(n,e,t,r){var o=n[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),n[e]=null,y(t,e)}Tt.prototype._init=function(n){var e=this;e._uid=St++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var o=r.componentOptions;t.propsData=o.propsData,t._parentListeners=o.listeners,t._renderChildren=o.children,t._componentTag=o.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(Ct(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=he(e._renderChildren,r),n.$scopedSlots=o,n._c=function(e,t,r,o){return He(n,e,t,r,o,!1)},n.$createElement=function(e,t,r,o){return He(n,e,t,r,o,!0)};var a=t&&t.data;Mn(n,"$attrs",a&&a.attrs||o,null,!0),Mn(n,"$listeners",e._parentListeners||o,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(Tn(!1),Object.keys(e).forEach((function(t){Mn(n,t,e[t])})),Tn(!0))}(e),gt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=An,n.prototype.$delete=In,n.prototype.$watch=function(n,e,t){if(d(e))return kt(this,n,e,t);(t=t||{}).user=!0;var r=new mt(this,n,e,t);if(t.immediate){var o='callback for immediate watcher "'+r.expression+'"';mn(),qn(e,this,[r.value],this,o),hn()}return function(){r.teardown()}}}(Tt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var o=0,a=n.length;o<a;o++)r.$on(n[o],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,o=n.length;r<o;r++)t.$off(n[r],e);return t}var a,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((a=i[s])===e||a.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var r=A(arguments,1),o='event handler for "'+n+'"',a=0,i=t.length;a<i;a++)qn(t[a],e,r,e,o)}return e}}(Tt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,o=t._vnode,a=Ze(t);t._vnode=n,t.$el=o?t.__patch__(o,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Tt),function(n){De(n.prototype),n.prototype.$nextTick=function(n){return oe(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,o=t._parentVnode;o&&(e.$scopedSlots=xe(o.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=o;try{Ue=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Un(t,e,"render"),n=e._vnode}finally{Ue=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=xn()),n.parent=o,n}}(Tt);var Ot=[String,RegExp,Array],Pt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ot,exclude:Ot,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var o=t.tag,a=t.componentInstance,i=t.componentOptions;n[r]={name:_t(i),tag:o,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&It(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)It(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){At(n,(function(n){return Mt(e,n)}))})),this.$watch("exclude",(function(e){At(n,(function(n){return!Mt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Xe(n),t=e&&e.componentOptions;if(t){var r=_t(t),o=this.include,a=this.exclude;if(o&&(!r||!Mt(o,r))||a&&r&&Mt(a,r))return e;var i=this.cache,s=this.keys,c=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[c]?(e.componentInstance=i[c].componentInstance,y(s,c),s.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:I,mergeOptions:Rn,defineReactive:Mn},n.set=An,n.delete=In,n.nextTick=oe,n.observable=function(n){return _n(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,Pt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),jt(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&d(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Tt),Object.defineProperty(Tt.prototype,"$isServer",{get:on}),Object.defineProperty(Tt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Tt,"FunctionalRenderContext",{value:ze}),Tt.version="2.6.14";var Lt=g("style,class"),Et=g("input,textarea,option,select,progress"),Dt=g("contenteditable,draggable,spellcheck"),zt=g("events,caret,typing,plaintext-only"),$t=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Ft=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Nt=function(n){return Ft(n)?n.slice(6,n.length):""},Bt=function(n){return null==n||!1===n};function Wt(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ht(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=Ht(e,t.data));return function(n,e){if(i(n)||i(e))return Vt(n,Ut(e));return""}(e.staticClass,e.class)}function Ht(n,e){return{staticClass:Vt(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function Vt(n,e){return n?e?n+" "+e:n:e||""}function Ut(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,o=n.length;r<o;r++)i(e=Ut(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var qt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Xt=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Jt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Gt=function(n){return Xt(n)||Jt(n)};var Kt=Object.create(null);var Yt=g("text,number,password,search,email,tel,url");var Qt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(qt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Zt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(i(t)){var r=n.context,o=n.componentInstance||n.elm,a=r.$refs;e?Array.isArray(a[t])?y(a[t],o):a[t]===o&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(o)<0&&a[t].push(o):a[t]=[o]:a[t]=o}}var er=new vn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,o=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===o||Yt(r)&&Yt(o)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function or(n,e,t){var r,o,a={};for(r=e;r<=t;++r)i(o=n[r].key)&&(a[o]=r);return a}var ar={create:ir,update:ir,destroy:function(n){ir(n,er)}};function ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,o,a=n===er,i=e===er,s=cr(n.data.directives,n.context),c=cr(e.data.directives,e.context),l=[],u=[];for(t in c)r=s[t],o=c[t],r?(o.oldValue=r.value,o.oldArg=r.arg,ur(o,"update",e,n),o.def&&o.def.componentUpdated&&u.push(o)):(ur(o,"bind",e,n),o.def&&o.def.inserted&&l.push(o));if(l.length){var d=function(){for(var t=0;t<l.length;t++)ur(l[t],"inserted",e,n)};a?ue(e,"insert",d):d()}u.length&&ue(e,"postpatch",(function(){for(var t=0;t<u.length;t++)ur(u[t],"componentUpdated",e,n)}));if(!a)for(t in s)c[t]||ur(s[t],"unbind",n,n,i)}(n,e)}var sr=Object.create(null);function cr(n,e){var t,r,o=Object.create(null);if(!n)return o;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),o[lr(r)]=r,r.def=Fn(e.$options,"directives",r.name);return o}function lr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ur(n,e,t,r,o){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,o)}catch(r){Un(r,t.context,"directive "+n.name+" "+e+" hook")}}var dr=[Zt,ar];function pr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,s=e.elm,c=n.data.attrs||{},l=e.data.attrs||{};for(r in i(l.__ob__)&&(l=e.data.attrs=I({},l)),l)o=l[r],c[r]!==o&&fr(s,r,o,e.data.pre);for(r in(K||Q)&&l.value!==c.value&&fr(s,"value",l.value),c)a(l[r])&&(Ft(r)?s.removeAttributeNS(Rt,Nt(r)):Dt(r)||s.removeAttribute(r))}}function fr(n,e,t,r){r||n.tagName.indexOf("-")>-1?mr(n,e,t):$t(e)?Bt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Dt(e)?n.setAttribute(e,function(n,e){return Bt(e)||"false"===e?"false":"contenteditable"===n&&zt(e)?e:"true"}(e,t)):Ft(e)?Bt(t)?n.removeAttributeNS(Rt,Nt(e)):n.setAttributeNS(Rt,e,t):mr(n,e,t)}function mr(n,e,t){if(Bt(t))n.removeAttribute(e);else{if(K&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var hr={create:pr,update:pr};function vr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=Wt(e),c=t._transitionClasses;i(c)&&(s=Vt(s,Ut(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var gr,xr={create:vr,update:vr};function yr(n,e,t){var r=gr;return function o(){var a=e.apply(null,arguments);null!==a&&kr(n,o,t,r)}}var br=Kn&&!(nn&&Number(nn[1])<=53);function wr(n,e,t,r){if(br){var o=lt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=o||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}gr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function kr(n,e,t,r){(r||gr).removeEventListener(n,e._wrapper||e,t)}function Sr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};gr=e.elm,function(n){if(i(n.__r)){var e=K?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),le(t,r,wr,kr,yr,e.context),gr=void 0}}var Cr,Tr={create:Sr,update:Sr};function jr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,s=n.data.domProps||{},c=e.data.domProps||{};for(t in i(c.__ob__)&&(c=e.data.domProps=I({},c)),s)t in c||(o[t]="");for(t in c){if(r=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var l=a(r)?"":String(r);_r(o,l)&&(o.value=l)}else if("innerHTML"===t&&Jt(o.tagName)&&a(o.innerHTML)){(Cr=Cr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=Cr.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==s[t])try{o[t]=r}catch(n){}}}}function _r(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Mr={create:jr,update:jr},Ar=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Ir(n){var e=Or(n.style);return n.staticStyle?I(n.staticStyle,e):e}function Or(n){return Array.isArray(n)?O(n):"string"==typeof n?Ar(n):n}var Pr,Lr=/^--/,Er=/\s*!important$/,Dr=function(n,e,t){if(Lr.test(e))n.style.setProperty(e,t);else if(Er.test(t))n.style.setProperty(_(e),t.replace(Er,""),"important");else{var r=$r(e);if(Array.isArray(t))for(var o=0,a=t.length;o<a;o++)n.style[r]=t[o];else n.style[r]=t}},zr=["Webkit","Moz","ms"],$r=k((function(n){if(Pr=Pr||document.createElement("div").style,"filter"!==(n=C(n))&&n in Pr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<zr.length;t++){var r=zr[t]+e;if(r in Pr)return r}}));function Rr(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,c=e.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},d=l||u,p=Or(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?I({},p):p;var f=function(n,e){var t,r={};if(e)for(var o=n;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(t=Ir(o.data))&&I(r,t);(t=Ir(n.data))&&I(r,t);for(var a=n;a=a.parent;)a.data&&(t=Ir(a.data))&&I(r,t);return r}(e,!0);for(s in d)a(f[s])&&Dr(c,s,"");for(s in f)(o=f[s])!==d[s]&&Dr(c,s,null==o?"":o)}}var Fr={create:Rr,update:Rr},Nr=/\s+/;function Br(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Wr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Nr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Hr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&I(e,Vr(n.name||"v")),I(e,n),e}return"string"==typeof n?Vr(n):void 0}}var Vr=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ur=q&&!Y,qr="transition",Xr="transitionend",Jr="animation",Gr="animationend";Ur&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(qr="WebkitTransition",Xr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Jr="WebkitAnimation",Gr="webkitAnimationEnd"));var Kr=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Kr((function(){Kr(n)}))}function Qr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Br(n,e))}function Zr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Wr(n,e)}function no(n,e,t){var r=to(n,e),o=r.type,a=r.timeout,i=r.propCount;if(!o)return t();var s="transition"===o?Xr:Gr,c=0,l=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++c>=i&&l()};setTimeout((function(){c<i&&l()}),a+1),n.addEventListener(s,u)}var eo=/\b(transform|all)(,|$)/;function to(n,e){var t,r=window.getComputedStyle(n),o=(r[qr+"Delay"]||"").split(", "),a=(r[qr+"Duration"]||"").split(", "),i=ro(o,a),s=(r[Jr+"Delay"]||"").split(", "),c=(r[Jr+"Duration"]||"").split(", "),l=ro(s,c),u=0,d=0;return"transition"===e?i>0&&(t="transition",u=i,d=a.length):"animation"===e?l>0&&(t="animation",u=l,d=c.length):d=(t=(u=Math.max(i,l))>0?i>l?"transition":"animation":null)?"transition"===t?a.length:c.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&eo.test(r[qr+"Property"])}}function ro(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return oo(e)+oo(n[t])})))}function oo(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ao(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Hr(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,c=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,f=r.appearToClass,m=r.appearActiveClass,h=r.beforeEnter,g=r.enter,x=r.afterEnter,y=r.enterCancelled,b=r.beforeAppear,w=r.appear,k=r.afterAppear,S=r.appearCancelled,C=r.duration,T=Qe,j=Qe.$vnode;j&&j.parent;)T=j.context,j=j.parent;var _=!T._isMounted||!n.isRootInsert;if(!_||w||""===w){var M=_&&p?p:c,A=_&&m?m:d,I=_&&f?f:u,O=_&&b||h,P=_&&"function"==typeof w?w:g,L=_&&k||x,E=_&&S||y,D=v(l(C)?C.enter:C);0;var z=!1!==o&&!Y,R=co(P),F=t._enterCb=$((function(){z&&(Zr(t,I),Zr(t,A)),F.cancelled?(z&&Zr(t,M),E&&E(t)):L&&L(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),P&&P(t,F)})),O&&O(t),z&&(Qr(t,M),Qr(t,A),Yr((function(){Zr(t,M),F.cancelled||(Qr(t,I),R||(so(D)?setTimeout(F,D):no(t,s,F)))}))),n.data.show&&(e&&e(),P&&P(t,F)),z||R||F()}}}function io(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Hr(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,c=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,f=r.leave,m=r.afterLeave,h=r.leaveCancelled,g=r.delayLeave,x=r.duration,y=!1!==o&&!Y,b=co(f),w=v(l(x)?x.leave:x);0;var k=t._leaveCb=$((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Zr(t,u),Zr(t,d)),k.cancelled?(y&&Zr(t,c),h&&h(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(S):S()}function S(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Qr(t,c),Qr(t,d),Yr((function(){Zr(t,c),k.cancelled||(Qr(t,u),b||(so(w)?setTimeout(k,w):no(t,s,k)))}))),f&&f(t,k),y||b||k())}}function so(n){return"number"==typeof n&&!isNaN(n)}function co(n){if(a(n))return!1;var e=n.fns;return i(e)?co(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function lo(n,e){!0!==e.data.show&&ao(e)}var uo=function(n){var e,t,r={},o=n.modules,l=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<o.length;++t)i(o[t][tr[e]])&&r[tr[e]].push(o[t][tr[e]]);function u(n){var e=l.parentNode(n);i(e)&&l.removeChild(e,n)}function d(n,e,t,o,a,c,u){if(i(n.elm)&&i(c)&&(n=c[u]=bn(n)),n.isRootInsert=!a,!function(n,e,t,o){var a=n.data;if(i(a)){var c=i(n.componentInstance)&&a.keepAlive;if(i(a=a.hook)&&i(a=a.init)&&a(n,!1),i(n.componentInstance))return p(n,e),f(t,n.elm,o),s(c)&&function(n,e,t,o){var a,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(a=s.data)&&i(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](er,s);e.push(s);break}f(t,n.elm,o)}(n,e,t,o),!0}}(n,e,t,o)){var d=n.data,h=n.children,g=n.tag;i(g)?(n.elm=n.ns?l.createElementNS(n.ns,g):l.createElement(g,n),x(n),m(n,h,e),i(d)&&v(n,e),f(t,n.elm,o)):s(n.isComment)?(n.elm=l.createComment(n.text),f(t,n.elm,o)):(n.elm=l.createTextNode(n.text),f(t,n.elm,o))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(v(n,e),x(n)):(nr(n),e.push(n))}function f(n,e,t){i(n)&&(i(t)?l.parentNode(t)===n&&l.insertBefore(n,e,t):l.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&l.appendChild(n.elm,l.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function v(n,t){for(var o=0;o<r.create.length;++o)r.create[o](er,n);i(e=n.data.hook)&&(i(e.create)&&e.create(er,n),i(e.insert)&&t.push(n))}function x(n){var e;if(i(e=n.fnScopeId))l.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&l.setStyleScope(n.elm,e),t=t.parent;i(e=Qe)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&l.setStyleScope(n.elm,e)}function y(n,e,t,r,o,a){for(;r<=o;++r)d(t[r],a,n,e,!1,t,r)}function b(n){var e,t,o=n.data;if(i(o))for(i(e=o.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)b(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(k(r),b(r)):u(r.elm))}}function k(n,e){if(i(e)||i(n.data)){var t,o=r.remove.length+1;for(i(e)?e.listeners+=o:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,o),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function S(n,e,t,r){for(var o=t;o<r;o++){var a=e[o];if(i(a)&&rr(n,a))return o}}function C(n,e,t,o,c,u){if(n!==e){i(e.elm)&&i(o)&&(e=o[c]=bn(e));var p=e.elm=n.elm;if(s(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?_(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var f,m=e.data;i(m)&&i(f=m.hook)&&i(f=f.prepatch)&&f(n,e);var v=n.children,g=e.children;if(i(m)&&h(e)){for(f=0;f<r.update.length;++f)r.update[f](n,e);i(f=m.hook)&&i(f=f.update)&&f(n,e)}a(e.text)?i(v)&&i(g)?v!==g&&function(n,e,t,r,o){var s,c,u,p=0,f=0,m=e.length-1,h=e[0],v=e[m],g=t.length-1,x=t[0],b=t[g],k=!o;for(0;p<=m&&f<=g;)a(h)?h=e[++p]:a(v)?v=e[--m]:rr(h,x)?(C(h,x,r,t,f),h=e[++p],x=t[++f]):rr(v,b)?(C(v,b,r,t,g),v=e[--m],b=t[--g]):rr(h,b)?(C(h,b,r,t,g),k&&l.insertBefore(n,h.elm,l.nextSibling(v.elm)),h=e[++p],b=t[--g]):rr(v,x)?(C(v,x,r,t,f),k&&l.insertBefore(n,v.elm,h.elm),v=e[--m],x=t[++f]):(a(s)&&(s=or(e,p,m)),a(c=i(x.key)?s[x.key]:S(x,e,p,m))?d(x,r,n,h.elm,!1,t,f):rr(u=e[c],x)?(C(u,x,r,t,f),e[c]=void 0,k&&l.insertBefore(n,u.elm,h.elm)):d(x,r,n,h.elm,!1,t,f),x=t[++f]);p>m?y(n,a(t[g+1])?null:t[g+1].elm,t,f,g,r):f>g&&w(e,p,m)}(p,v,g,t,u):i(g)?(i(n.text)&&l.setTextContent(p,""),y(p,null,g,0,g.length-1,t)):i(v)?w(v,0,v.length-1):i(n.text)&&l.setTextContent(p,""):n.text!==e.text&&l.setTextContent(p,e.text),i(m)&&i(f=m.hook)&&i(f=f.postpatch)&&f(n,e)}}}function T(n,e,t){if(s(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var j=g("attrs,class,staticClass,staticStyle,key");function _(n,e,t,r){var o,a=e.tag,c=e.data,l=e.children;if(r=r||c&&c.pre,e.elm=n,s(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(c)&&(i(o=c.hook)&&i(o=o.init)&&o(e,!0),i(o=e.componentInstance)))return p(e,t),!0;if(i(a)){if(i(l))if(n.hasChildNodes())if(i(o=c)&&i(o=o.domProps)&&i(o=o.innerHTML)){if(o!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,f=0;f<l.length;f++){if(!d||!_(d,l[f],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else m(e,l,t);if(i(c)){var h=!1;for(var g in c)if(!j(g)){h=!0,v(e,t);break}!h&&c.class&&ie(c.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,o){if(!a(e)){var c,u=!1,p=[];if(a(n))u=!0,d(e,p);else{var f=i(n.nodeType);if(!f&&rr(n,e))C(n,e,p,null,null,o);else{if(f){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&_(n,e,p))return T(e,p,!0),n;c=n,n=new vn(l.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,v=l.parentNode(m);if(d(e,p,m._leaveCb?null:v,l.nextSibling(m)),i(e.parent))for(var g=e.parent,x=h(e);g;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](g);if(g.elm=e.elm,x){for(var k=0;k<r.create.length;++k)r.create[k](er,g);var S=g.data.hook.insert;if(S.merged)for(var j=1;j<S.fns.length;j++)S.fns[j]()}else nr(g);g=g.parent}i(v)?w([n],0,0):i(n.tag)&&b(n)}}return T(e,p,u),e.elm}i(n)&&b(n)}}({nodeOps:Qt,modules:[hr,xr,Tr,Mr,Fr,q?{create:lo,activate:lo,remove:function(n,e){!0!==n.data.show?io(n,e):e()}}:{}].concat(dr)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&yo(n,"input")}));var po={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ue(t,"postpatch",(function(){po.componentUpdated(n,e,t)})):fo(n,e,t.context),n._vOptions=[].map.call(n.options,vo)):("textarea"===t.tag||Yt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",go),n.addEventListener("compositionend",xo),n.addEventListener("change",xo),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){fo(n,e,t.context);var r=n._vOptions,o=n._vOptions=[].map.call(n.options,vo);if(o.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return ho(n,o)})):e.value!==e.oldValue&&ho(e.value,o))&&yo(n,"change")}}};function fo(n,e,t){mo(n,e,t),(K||Q)&&setTimeout((function(){mo(n,e,t)}),0)}function mo(n,e,t){var r=e.value,o=n.multiple;if(!o||Array.isArray(r)){for(var a,i,s=0,c=n.options.length;s<c;s++)if(i=n.options[s],o)a=z(r,vo(i))>-1,i.selected!==a&&(i.selected=a);else if(D(vo(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));o||(n.selectedIndex=-1)}}function ho(n,e){return e.every((function(e){return!D(e,n)}))}function vo(n){return"_value"in n?n._value:n.value}function go(n){n.target.composing=!0}function xo(n){n.target.composing&&(n.target.composing=!1,yo(n.target,"input"))}function yo(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function bo(n){return!n.componentInstance||n.data&&n.data.transition?n:bo(n.componentInstance._vnode)}var wo={model:po,show:{bind:function(n,e,t){var r=e.value,o=(t=bo(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&o?(t.data.show=!0,ao(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=bo(t)).data&&t.data.transition?(t.data.show=!0,r?ao(t,(function(){n.style.display=n.__vOriginalDisplay})):io(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,o){o||(n.style.display=n.__vOriginalDisplay)}}},ko={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function So(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?So(Xe(e.children)):n}function Co(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var o=t._parentListeners;for(var a in o)e[C(a)]=o[a];return e}function To(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var jo=function(n){return n.tag||ge(n)},_o=function(n){return"show"===n.name},Mo={name:"transition",props:ko,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(jo)).length){0;var r=this.mode;0;var o=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return o;var a=So(o);if(!a)return o;if(this._leaving)return To(n,o);var i="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?i+"comment":i+a.tag:c(a.key)?0===String(a.key).indexOf(i)?a.key:i+a.key:a.key;var s=(a.data||(a.data={})).transition=Co(this),l=this._vnode,u=So(l);if(a.data.directives&&a.data.directives.some(_o)&&(a.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,u)&&!ge(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=I({},s);if("out-in"===r)return this._leaving=!0,ue(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),To(n,o);if("in-out"===r){if(ge(a))return l;var p,f=function(){p()};ue(s,"afterEnter",f),ue(s,"enterCancelled",f),ue(d,"delayLeave",(function(n){p=n}))}}return o}}},Ao=I({tag:String,moveClass:String},ko);function Io(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Oo(n){n.data.newPos=n.elm.getBoundingClientRect()}function Po(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,o=e.top-t.top;if(r||o){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+o+"px)",a.transitionDuration="0s"}}delete Ao.mode;var Lo={Transition:Mo,TransitionGroup:{props:Ao,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var o=Ze(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,o(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],a=this.children=[],i=Co(this),s=0;s<o.length;s++){var c=o[s];if(c.tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),t[c.key]=c,(c.data||(c.data={})).transition=i;else;}if(r){for(var l=[],u=[],d=0;d<r.length;d++){var p=r[d];p.data.transition=i,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):u.push(p)}this.kept=n(e,null,l),this.removed=u}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Io),n.forEach(Oo),n.forEach(Po),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Qr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Xr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Xr,n),t._moveCb=null,Zr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ur)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Wr(t,n)})),Br(t,e),t.style.display="none",this.$el.appendChild(t);var r=to(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Tt.config.mustUseProp=function(n,e,t){return"value"===t&&Et(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Tt.config.isReservedTag=Gt,Tt.config.isReservedAttr=Lt,Tt.config.getTagNamespace=function(n){return Jt(n)?"svg":"math"===n?"math":void 0},Tt.config.isUnknownElement=function(n){if(!q)return!0;if(Gt(n))return!1;if(n=n.toLowerCase(),null!=Kt[n])return Kt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Kt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Kt[n]=/HTMLUnknownElement/.test(e.toString())},I(Tt.options.directives,wo),I(Tt.options.components,Lo),Tt.prototype.__patch__=q?uo:P,Tt.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=xn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new mt(n,r,P,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},q&&setTimeout((function(){N.devtools&&an&&an.emit("init",Tt)}),0);var Eo=Tt;
/*!
  * vue-router v3.5.2
  * (c) 2021 Evan You
  * @license MIT
  */function Do(n,e){for(var t in e)n[t]=e[t];return n}var zo=/[!'()*]/g,$o=function(n){return"%"+n.charCodeAt(0).toString(16)},Ro=/%2C/g,Fo=function(n){return encodeURIComponent(n).replace(zo,$o).replace(Ro,",")};function No(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Bo=function(n){return null==n||"object"==typeof n?n:String(n)};function Wo(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=No(t.shift()),o=t.length>0?No(t.join("=")):null;void 0===e[r]?e[r]=o:Array.isArray(e[r])?e[r].push(o):e[r]=[e[r],o]})),e):e}function Ho(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Fo(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Fo(e)):r.push(Fo(e)+"="+Fo(n)))})),r.join("&")}return Fo(e)+"="+Fo(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Vo=/\/?$/;function Uo(n,e,t,r){var o=r&&r.options.stringifyQuery,a=e.query||{};try{a=qo(a)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Go(e,o),matched:n?Jo(n):[]};return t&&(i.redirectedFrom=Go(t,o)),Object.freeze(i)}function qo(n){if(Array.isArray(n))return n.map(qo);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=qo(n[t]);return e}return n}var Xo=Uo(null,{path:"/"});function Jo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Go(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var o=n.hash;return void 0===o&&(o=""),(t||"/")+(e||Ho)(r)+o}function Ko(n,e,t){return e===Xo?n===e:!!e&&(n.path&&e.path?n.path.replace(Vo,"")===e.path.replace(Vo,"")&&(t||n.hash===e.hash&&Yo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Yo(n.query,e.query)&&Yo(n.params,e.params))))}function Yo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var a=n[t];if(r[o]!==t)return!1;var i=e[t];return null==a||null==i?a===i:"object"==typeof a&&"object"==typeof i?Yo(a,i):String(a)===String(i)}))}function Qo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var o=t.instances[r],a=t.enteredCbs[r];if(o&&a){delete t.enteredCbs[r];for(var i=0;i<a.length;i++)o._isBeingDestroyed||a[i](o)}}}}var Zo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,o=e.parent,a=e.data;a.routerView=!0;for(var i=o.$createElement,s=t.name,c=o.$route,l=o._routerViewCache||(o._routerViewCache={}),u=0,d=!1;o&&o._routerRoot!==o;){var p=o.$vnode?o.$vnode.data:{};p.routerView&&u++,p.keepAlive&&o._directInactive&&o._inactive&&(d=!0),o=o.$parent}if(a.routerViewDepth=u,d){var f=l[s],m=f&&f.component;return m?(f.configProps&&na(m,a,f.route,f.configProps),i(m,a,r)):i()}var h=c.matched[u],v=h&&h.components[s];if(!h||!v)return l[s]=null,i();l[s]={component:v},a.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),Qo(c)};var g=h.props&&h.props[s];return g&&(Do(l[s],{route:c,configProps:g}),na(v,a,c,g)),i(v,a,r)}};function na(n,e,t,r){var o=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=Do({},o);var a=e.attrs=e.attrs||{};for(var i in o)n.props&&i in n.props||(a[i]=o[i],delete o[i])}}function ea(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var o=e.split("/");t&&o[o.length-1]||o.pop();for(var a=n.replace(/^\//,"").split("/"),i=0;i<a.length;i++){var s=a[i];".."===s?o.pop():"."!==s&&o.push(s)}return""!==o[0]&&o.unshift(""),o.join("/")}function ta(n){return n.replace(/\/\//g,"/")}var ra=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},oa=xa,aa=ua,ia=function(n,e){return pa(ua(n,e),e)},sa=pa,ca=ga,la=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ua(n,e){for(var t,r=[],o=0,a=0,i="",s=e&&e.delimiter||"/";null!=(t=la.exec(n));){var c=t[0],l=t[1],u=t.index;if(i+=n.slice(a,u),a=u+c.length,l)i+=l[1];else{var d=n[a],p=t[2],f=t[3],m=t[4],h=t[5],v=t[6],g=t[7];i&&(r.push(i),i="");var x=null!=p&&null!=d&&d!==p,y="+"===v||"*"===v,b="?"===v||"*"===v,w=t[2]||s,k=m||h;r.push({name:f||o++,prefix:p||"",delimiter:w,optional:b,repeat:y,partial:x,asterisk:!!g,pattern:k?ma(k):g?".*":"[^"+fa(w)+"]+?"})}}return a<n.length&&(i+=n.substr(a)),i&&r.push(i),r}function da(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function pa(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",va(e)));return function(e,r){for(var o="",a=e||{},i=(r||{}).pretty?da:encodeURIComponent,s=0;s<n.length;s++){var c=n[s];if("string"!=typeof c){var l,u=a[c.name];if(null==u){if(c.optional){c.partial&&(o+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(ra(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(l=i(u[d]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");o+=(0===d?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(u),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');o+=c.prefix+l}}else o+=c}return o}}function fa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ma(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ha(n,e){return n.keys=e,n}function va(n){return n&&n.sensitive?"":"i"}function ga(n,e,t){ra(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,o=!1!==t.end,a="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)a+=fa(s);else{var c=fa(s.prefix),l="(?:"+s.pattern+")";e.push(s),s.repeat&&(l+="(?:"+c+l+")*"),a+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=fa(t.delimiter||"/"),d=a.slice(-u.length)===u;return r||(a=(d?a.slice(0,-u.length):a)+"(?:"+u+"(?=$))?"),a+=o?"$":r&&d?"":"(?="+u+"|$)",ha(new RegExp("^"+a,va(t)),e)}function xa(n,e,t){return ra(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ha(n,e)}(n,e):ra(n)?function(n,e,t){for(var r=[],o=0;o<n.length;o++)r.push(xa(n[o],e,t).source);return ha(new RegExp("(?:"+r.join("|")+")",va(t)),e)}(n,e,t):function(n,e,t){return ga(ua(n,t),e,t)}(n,e,t)}oa.parse=aa,oa.compile=ia,oa.tokensToFunction=sa,oa.tokensToRegExp=ca;var ya=Object.create(null);function ba(n,e,t){e=e||{};try{var r=ya[n]||(ya[n]=oa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function wa(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var a=(o=Do({},n)).params;return a&&"object"==typeof a&&(o.params=Do({},a)),o}if(!o.path&&o.params&&e){(o=Do({},o))._normalized=!0;var i=Do(Do({},e.params),o.params);if(e.name)o.name=e.name,o.params=i;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;o.path=ba(s,i,e.path)}else 0;return o}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var o=n.indexOf("?");return o>=0&&(t=n.slice(o+1),n=n.slice(0,o)),{path:n,query:t,hash:e}}(o.path||""),l=e&&e.path||"/",u=c.path?ea(c.path,l,t||o.append):l,d=function(n,e,t){void 0===e&&(e={});var r,o=t||Wo;try{r=o(n||"")}catch(n){r={}}for(var a in e){var i=e[a];r[a]=Array.isArray(i)?i.map(Bo):Bo(i)}return r}(c.query,o.query,r&&r.options.parseQuery),p=o.hash||c.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:u,query:d,hash:p}}var ka,Sa=function(){},Ca={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,o=t.resolve(this.to,r,this.append),a=o.location,i=o.route,s=o.href,c={},l=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==l?"router-link-active":l,p=null==u?"router-link-exact-active":u,f=null==this.activeClass?d:this.activeClass,m=null==this.exactActiveClass?p:this.exactActiveClass,h=i.redirectedFrom?Uo(null,wa(i.redirectedFrom),null,t):i;c[m]=Ko(r,h,this.exactPath),c[f]=this.exact||this.exactPath?c[m]:function(n,e){return 0===n.path.replace(Vo,"/").indexOf(e.path.replace(Vo,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,h);var v=c[m]?this.ariaCurrentValue:null,g=function(n){Ta(n)&&(e.replace?t.replace(a,Sa):t.push(a,Sa))},x={click:Ta};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=g})):x[this.event]=g;var y={class:c},b=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:g,isActive:c[f],isExactActive:c[m]});if(b){if(1===b.length)return b[0];if(b.length>1||!b.length)return 0===b.length?n():n("span",{},b)}if("a"===this.tag)y.on=x,y.attrs={href:s,"aria-current":v};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=Do({},w.data);for(var S in k.on=k.on||{},k.on){var C=k.on[S];S in x&&(k.on[S]=Array.isArray(C)?C:[C])}for(var T in x)T in k.on?k.on[T].push(x[T]):k.on[T]=g;var j=w.data.attrs=Do({},w.data.attrs);j.href=s,j["aria-current"]=v}else y.on=x}return n(this.tag,y,this.$slots.default)}};function Ta(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ja="undefined"!=typeof window;function _a(n,e,t,r,o){var a=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,o,a,i){var s=o.path,c=o.name;0;var l=o.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ta(e.path+"/"+n)}(s,a,l.strict);"boolean"==typeof o.caseSensitive&&(l.sensitive=o.caseSensitive);var d={path:u,regex:Ma(u,l),components:o.components||{default:o.component},alias:o.alias?"string"==typeof o.alias?[o.alias]:o.alias:[],instances:{},enteredCbs:{},name:c,parent:a,matchAs:i,redirect:o.redirect,beforeEnter:o.beforeEnter,meta:o.meta||{},props:null==o.props?{}:o.components?o.props:{default:o.props}};o.children&&o.children.forEach((function(o){var a=i?ta(i+"/"+o.path):void 0;n(e,t,r,o,d,a)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==o.alias)for(var p=Array.isArray(o.alias)?o.alias:[o.alias],f=0;f<p.length;++f){0;var m={path:p[f],children:o.children};n(e,t,r,m,a,d.path||"/")}c&&(r[c]||(r[c]=d))}(a,i,s,n,o)}));for(var c=0,l=a.length;c<l;c++)"*"===a[c]&&(a.push(a.splice(c,1)[0]),l--,c--);return{pathList:a,pathMap:i,nameMap:s}}function Ma(n,e){return oa(n,[],e)}function Aa(n,e){var t=_a(n),r=t.pathList,o=t.pathMap,a=t.nameMap;function i(n,t,i){var s=wa(n,t,!1,e),l=s.name;if(l){var u=a[l];if(!u)return c(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=ba(u.path,s.params),c(u,s,i)}if(s.path){s.params={};for(var f=0;f<r.length;f++){var m=r[f],h=o[m];if(Ia(h.regex,s.path,s.params))return c(h,s,i)}}return c(null,s)}function s(n,t){var r=n.redirect,o="function"==typeof r?r(Uo(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!=typeof o)return c(null,t);var s=o,l=s.name,u=s.path,d=t.query,p=t.hash,f=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,f=s.hasOwnProperty("params")?s.params:f,l){a[l];return i({_normalized:!0,name:l,query:d,hash:p,params:f},void 0,t)}if(u){var m=function(n,e){return ea(n,e.parent?e.parent.path:"/",!0)}(u,n);return i({_normalized:!0,path:ba(m,f),query:d,hash:p},void 0,t)}return c(null,t)}function c(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=i({_normalized:!0,path:ba(t,e.params)});if(r){var o=r.matched,a=o[o.length-1];return e.params=r.params,c(a,e)}return c(null,e)}(0,t,n.matchAs):Uo(n,t,r,e)}return{match:i,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;_a([e||n],r,o,a,t),t&&t.alias.length&&_a(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,a,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){_a(n,r,o,a)}}}function Ia(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var o=1,a=r.length;o<a;++o){var i=n.keys[o-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[o]?No(r[o]):r[o])}return!0}var Oa=ja&&window.performance&&window.performance.now?window.performance:Date;function Pa(){return Oa.now().toFixed(3)}var La=Pa();function Ea(){return La}function Da(n){return La=n}var za=Object.create(null);function $a(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Do({},window.history.state);return t.key=Ea(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Na),function(){window.removeEventListener("popstate",Na)}}function Ra(n,e,t,r){if(n.app){var o=n.options.scrollBehavior;o&&n.app.$nextTick((function(){var a=function(){var n=Ea();if(n)return za[n]}(),i=o.call(n,e,t,r?a:null);i&&("function"==typeof i.then?i.then((function(n){Ua(n,a)})).catch((function(n){0})):Ua(i,a))}))}}function Fa(){var n=Ea();n&&(za[n]={x:window.pageXOffset,y:window.pageYOffset})}function Na(n){Fa(),n.state&&n.state.key&&Da(n.state.key)}function Ba(n){return Ha(n.x)||Ha(n.y)}function Wa(n){return{x:Ha(n.x)?n.x:window.pageXOffset,y:Ha(n.y)?n.y:window.pageYOffset}}function Ha(n){return"number"==typeof n}var Va=/^#\d/;function Ua(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var o=Va.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,a={x:Ha((t=a).x)?t.x:0,y:Ha(t.y)?t.y:0})}else Ba(n)&&(e=Wa(n))}else r&&Ba(n)&&(e=Wa(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var qa,Xa=ja&&((-1===(qa=window.navigator.userAgent).indexOf("Android 2.")&&-1===qa.indexOf("Android 4.0")||-1===qa.indexOf("Mobile Safari")||-1!==qa.indexOf("Chrome")||-1!==qa.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ja(n,e){Fa();var t=window.history;try{if(e){var r=Do({},t.state);r.key=Ea(),t.replaceState(r,"",n)}else t.pushState({key:Da(Pa())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ga(n){Ja(n,!0)}function Ka(n,e,t){var r=function(o){o>=n.length?t():n[o]?e(n[o],(function(){r(o+1)})):r(o+1)};r(0)}var Ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function Qa(n,e){return ni(n,e,Ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ei.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Za(n,e){return ni(n,e,Ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ni(n,e,t,r){var o=new Error(r);return o._isRouter=!0,o.from=n,o.to=e,o.type=t,o}var ei=["params","query","hash"];function ti(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ri(n,e){return ti(n)&&n._isRouter&&(null==e||n.type===e)}function oi(n){return function(e,t,r){var o=!1,a=0,i=null;ai(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){o=!0,a++;var c,l=ci((function(e){var o;((o=e).__esModule||si&&"Module"===o[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ka.extend(e),t.components[s]=e,--a<=0&&r()})),u=ci((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ti(n)?n:new Error(e),r(i))}));try{c=n(l,u)}catch(n){u(n)}if(c)if("function"==typeof c.then)c.then(l,u);else{var d=c.component;d&&"function"==typeof d.then&&d.then(l,u)}}})),o||r()}}function ai(n,e){return ii(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ii(n){return Array.prototype.concat.apply([],n)}var si="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function ci(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var li=function(n,e){this.router=n,this.base=function(n){if(!n)if(ja){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Xo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ui(n,e,t,r){var o=ai(n,(function(n,r,o,a){var i=function(n,e){"function"!=typeof n&&(n=ka.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,o,a)})):t(i,r,o,a)}));return ii(r?o.reverse():o)}function di(n,e){if(e)return function(){return n.apply(e,arguments)}}li.prototype.listen=function(n){this.cb=n},li.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},li.prototype.onError=function(n){this.errorCbs.push(n)},li.prototype.transitionTo=function(n,e,t){var r,o=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){o.updateRoute(r),e&&e(r),o.ensureURL(),o.router.afterHooks.forEach((function(n){n&&n(r,a)})),o.ready||(o.ready=!0,o.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!o.ready&&(ri(n,Ya.redirected)&&a===Xo||(o.ready=!0,o.readyErrorCbs.forEach((function(e){e(n)}))))}))},li.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var a,i,s=function(n){!ri(n)&&ti(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,l=o.matched.length-1;if(Ko(n,o)&&c===l&&n.matched[c]===o.matched[l])return this.ensureURL(),s(((i=ni(a=o,n,Ya.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",i));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,f=u.activated,m=[].concat(function(n){return ui(n,"beforeRouteLeave",di,!0)}(p),this.router.beforeHooks,function(n){return ui(n,"beforeRouteUpdate",di)}(d),f.map((function(n){return n.beforeEnter})),oi(f)),h=function(e,t){if(r.pending!==n)return s(Za(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return ni(n,e,Ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ti(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Qa(o,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Ka(m,h,(function(){Ka(function(n){return ui(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,o,a){return n(r,o,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(f).concat(r.router.resolveHooks),h,(function(){if(r.pending!==n)return s(Za(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Qo(n)}))}))}))},li.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},li.prototype.setupListeners=function(){},li.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Xo,this.pending=null};var pi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=fi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Xa&&t;r&&this.listeners.push($a());var o=function(){var t=n.current,o=fi(n.base);n.current===Xo&&o===n._startLocation||n.transitionTo(o,(function(n){r&&Ra(e,n,t,!0)}))};window.addEventListener("popstate",o),this.listeners.push((function(){window.removeEventListener("popstate",o)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ja(ta(r.base+n.fullPath)),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){Ga(ta(r.base+n.fullPath)),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(fi(this.base)!==this.current.fullPath){var e=ta(this.base+this.current.fullPath);n?Ja(e):Ga(e)}},e.prototype.getCurrentLocation=function(){return fi(this.base)},e}(li);function fi(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var mi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=fi(n);if(!/^\/#/.test(e))return window.location.replace(ta(n+"/#"+e)),!0}(this.base)||hi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Xa&&e;t&&this.listeners.push($a());var r=function(){var e=n.current;hi()&&n.transitionTo(vi(),(function(r){t&&Ra(n.router,r,e,!0),Xa||yi(r.fullPath)}))},o=Xa?"popstate":"hashchange";window.addEventListener(o,r),this.listeners.push((function(){window.removeEventListener(o,r)}))}},e.prototype.push=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){xi(n.fullPath),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,o=this.current;this.transitionTo(n,(function(n){yi(n.fullPath),Ra(r.router,n,o,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vi()!==e&&(n?xi(e):yi(e))},e.prototype.getCurrentLocation=function(){return vi()},e}(li);function hi(){var n=vi();return"/"===n.charAt(0)||(yi("/"+n),!1)}function vi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function gi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function xi(n){Xa?Ja(gi(n)):window.location.hash=n}function yi(n){Xa?Ga(gi(n)):window.location.replace(gi(n))}var bi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ri(n,Ya.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(li),wi=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Aa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Xa&&!1!==n.fallback,this.fallback&&(e="hash"),ja||(e="abstract"),this.mode=e,e){case"history":this.history=new pi(this,n.base);break;case"hash":this.history=new mi(this,n.base,this.fallback);break;case"abstract":this.history=new bi(this,n.base);break;default:0}},ki={currentRoute:{configurable:!0}};function Si(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wi.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ki.currentRoute.get=function(){return this.history&&this.history.current},wi.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof pi||t instanceof mi){var r=function(n){t.setupListeners(),function(n){var r=t.current,o=e.options.scrollBehavior;Xa&&o&&"fullPath"in n&&Ra(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wi.prototype.beforeEach=function(n){return Si(this.beforeHooks,n)},wi.prototype.beforeResolve=function(n){return Si(this.resolveHooks,n)},wi.prototype.afterEach=function(n){return Si(this.afterHooks,n)},wi.prototype.onReady=function(n,e){this.history.onReady(n,e)},wi.prototype.onError=function(n){this.history.onError(n)},wi.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},wi.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},wi.prototype.go=function(n){this.history.go(n)},wi.prototype.back=function(){this.go(-1)},wi.prototype.forward=function(){this.go(1)},wi.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wi.prototype.resolve=function(n,e,t){var r=wa(n,e=e||this.history.current,t,this),o=this.match(r,e),a=o.redirectedFrom||o.fullPath;return{location:r,route:o,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:o}},wi.prototype.getRoutes=function(){return this.matcher.getRoutes()},wi.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Xo&&this.history.transitionTo(this.history.getCurrentLocation())},wi.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Xo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wi.prototype,ki),wi.install=function n(e){if(!n.installed||ka!==e){n.installed=!0,ka=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Zo),e.component("RouterLink",Ca);var o=e.config.optionMergeStrategies;o.beforeRouteEnter=o.beforeRouteLeave=o.beforeRouteUpdate=o.created}},wi.version="3.5.2",wi.isNavigationFailure=ri,wi.NavigationFailureType=Ya,wi.START_LOCATION=Xo,ja&&window.Vue&&window.Vue.use(wi);var Ci=wi;t(182),t(130),t(202),t(96),t(204),t(97),t(98),t(205);function Ti(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(34),t(40),t(59);var ji=t(42),_i=(t(138),t(45),t(68),t(186),t(187),{NotFound:function(){return t.e(10).then(t.bind(null,401))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,400))}}),Mi={"v-7700522a":function(){return t.e(11).then(t.bind(null,424))},"v-9e5658da":function(){return t.e(15).then(t.bind(null,425))},"v-097775ff":function(){return t.e(14).then(t.bind(null,426))},"v-533a7316":function(){return t.e(16).then(t.bind(null,427))},"v-7bd7c3e1":function(){return t.e(18).then(t.bind(null,428))},"v-37caf9b5":function(){return t.e(17).then(t.bind(null,429))},"v-04a01422":function(){return t.e(20).then(t.bind(null,430))},"v-059aa732":function(){return t.e(13).then(t.bind(null,431))},"v-1339279e":function(){return t.e(21).then(t.bind(null,432))},"v-255b6cbe":function(){return t.e(23).then(t.bind(null,433))},"v-24743de0":function(){return t.e(22).then(t.bind(null,434))},"v-5d72327c":function(){return t.e(24).then(t.bind(null,435))},"v-039d0484":function(){return t.e(25).then(t.bind(null,436))},"v-3ed32d46":function(){return t.e(26).then(t.bind(null,438))},"v-60270942":function(){return t.e(29).then(t.bind(null,423))},"v-c33c2b3c":function(){return t.e(30).then(t.bind(null,422))},"v-6fb951e2":function(){return t.e(31).then(t.bind(null,404))},"v-253bc5a2":function(){return t.e(33).then(t.bind(null,420))},"v-7cf74bf4":function(){return t.e(34).then(t.bind(null,419))},"v-c5b9cbd8":function(){return t.e(35).then(t.bind(null,418))},"v-3a8ab342":function(){return t.e(38).then(t.bind(null,439))},"v-246dd3ca":function(){return t.e(39).then(t.bind(null,416))},"v-4bb39c46":function(){return t.e(4).then(t.bind(null,415))},"v-04117fc6":function(){return t.e(40).then(t.bind(null,414))},"v-c2f12d76":function(){return t.e(41).then(t.bind(null,413))},"v-981a8bba":function(){return t.e(9).then(t.bind(null,412))},"v-65b54a42":function(){return t.e(27).then(t.bind(null,411))},"v-329dab7c":function(){return t.e(28).then(t.bind(null,410))},"v-7ce715bc":function(){return t.e(37).then(t.bind(null,409))},"v-647c498d":function(){return t.e(3).then(t.bind(null,408))},"v-1e4261d6":function(){return t.e(8).then(t.bind(null,407))},"v-2a365402":function(){return t.e(36).then(t.bind(null,406))},"v-03e20728":function(){return t.e(32).then(t.bind(null,405))},"v-155d8bd6":function(){return t.e(12).then(t.bind(null,437))},"v-a174ed7c":function(){return t.e(19).then(t.bind(null,421))}};function Ai(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Ii=/-(\w)/g,Oi=Ai((function(n){return n.replace(Ii,(function(n,e){return e?e.toUpperCase():""}))})),Pi=/\B([A-Z])/g,Li=Ai((function(n){return n.replace(Pi,"-$1").toLowerCase()})),Ei=Ai((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Di(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Ei(Oi(e))):n(Ei(e))||n(Li(e))}var zi=Object.assign({},_i,Mi),$i=function(n){return zi[n]},Ri=function(n){return Mi[n]},Fi=function(n){return _i[n]},Ni=function(n){return Eo.component(n)};function Bi(n){return Di(Ri,n)}function Wi(n){return Di(Fi,n)}function Hi(n){return Di($i,n)}function Vi(n){return Di(Ni,n)}function Ui(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Vi(e)||!Hi(e)){n.next=5;break}return n.next=3,Hi(e)();case 3:t=n.sent,Eo.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function qi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Xi=t(94),Ji=(t(175),t(176),t(163)),Gi=t.n(Ji),Ki={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Xi.a)(n,1)[0]})).map((function(n){var e=Object(Xi.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(n[t],'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=Qi(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(ji.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=Zi(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Gi()([{name:"description",content:this.$description}],n,this.siteMeta,ns)},updateCanonicalLink:function(){Yi(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Qi(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){Zi(null,this.currentMetaTags),Yi()}};function Yi(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Qi(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function Zi(n,e){if(e&&Object(ji.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ns(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(95);var es=t(164),ts={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(es)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),o=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,i=0;i<t.length;i++){var s=t[i],c=t[i+1],l=0===i&&0===r||r>=s.parentElement.offsetTop+10&&(!c||r<c.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(l&&u!==decodeURIComponent(s.hash)){var d=s;if(a===o)for(var p=i+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},rs=(t(84),t(66)),os=t.n(rs),as=[Ki,ts,{mounted:function(){var n=this;os.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Eo.component(n.name)||os.a.start(),t()})),this.$router.afterEach((function(){os.a.done(),n.isSidebarOpen=!1}))}}],is={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return qi("layout",n),Eo.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ss=t(44),cs=Object(ss.a)(is,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(ji.a)(t));break;default:throw new Error("Unknown option name.")}}(cs,"mixins",as);var ls=[{name:"v-7700522a",path:"/frontend-network/_references.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-7700522a").then(t)}},{name:"v-9e5658da",path:"/frontend-network/web-intro.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-9e5658da").then(t)}},{name:"v-097775ff",path:"/frontend-network/http-protocol.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-097775ff").then(t)}},{name:"v-533a7316",path:"/frontend-network/web-security.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-533a7316").then(t)}},{name:"v-7bd7c3e1",path:"/",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-7bd7c3e1").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-37caf9b5",path:"/frontend-network/webpage-rendering.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-37caf9b5").then(t)}},{name:"v-04a01422",path:"/mp/component-programming/communicate-and-events.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-04a01422").then(t)}},{name:"v-059aa732",path:"/frontend-network/dns.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-059aa732").then(t)}},{name:"v-1339279e",path:"/mp/component-programming/constructor.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-1339279e").then(t)}},{name:"v-255b6cbe",path:"/mp/component-programming/lifecycle.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-255b6cbe").then(t)}},{name:"v-24743de0",path:"/mp/component-programming/data-observer.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-24743de0").then(t)}},{name:"v-5d72327c",path:"/mp/component-programming/mixins.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-5d72327c").then(t)}},{name:"v-039d0484",path:"/mp/component-programming/relations-component.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-039d0484").then(t)}},{name:"v-3ed32d46",path:"/mp/component-programming/summary.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-3ed32d46").then(t)}},{name:"v-60270942",path:"/mp/get-started/conditional-render.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-60270942").then(t)}},{name:"v-c33c2b3c",path:"/mp/get-started/data-binding.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-c33c2b3c").then(t)}},{name:"v-6fb951e2",path:"/mp/get-started/environment-config.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-6fb951e2").then(t)}},{name:"v-253bc5a2",path:"/mp/get-started/form-binding.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-253bc5a2").then(t)}},{name:"v-7cf74bf4",path:"/mp/get-started/list-render.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-7cf74bf4").then(t)}},{name:"v-c5b9cbd8",path:"/mp/get-started/miniprogram-framework.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-c5b9cbd8").then(t)}},{name:"v-3a8ab342",path:"/mp/get-started/style-wxss.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-3a8ab342").then(t)}},{name:"v-246dd3ca",path:"/private/0yyy0qaq==/",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-246dd3ca").then(t)}},{path:"/private/0yyy0qaq==/index.html",redirect:"/private/0yyy0qaq==/"},{name:"v-4bb39c46",path:"/vue3-deep-dive/creating-a-mount-function.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-4bb39c46").then(t)}},{name:"v-04117fc6",path:"/vue3-deep-dive/intro.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-04117fc6").then(t)}},{name:"v-c2f12d76",path:"/vue3-deep-dive/rendering-mechanism.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-c2f12d76").then(t)}},{name:"v-981a8bba",path:"/vue3-deep-dive/use-render-function.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-981a8bba").then(t)}},{name:"v-65b54a42",path:"/mp/component-programming/template-style.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-65b54a42").then(t)}},{name:"v-329dab7c",path:"/mp/get-started/app-instance.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-329dab7c").then(t)}},{name:"v-7ce715bc",path:"/mp/get-started/program-structure.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-7ce715bc").then(t)}},{name:"v-647c498d",path:"/vue3-deep-dive/compiler-and-renderer-api.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-647c498d").then(t)}},{name:"v-1e4261d6",path:"/private/0yyy0qaq==/majiang/ch01.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-1e4261d6").then(t)}},{name:"v-2a365402",path:"/mp/get-started/page.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-2a365402").then(t)}},{name:"v-03e20728",path:"/mp/get-started/event-binding.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-03e20728").then(t)}},{name:"v-155d8bd6",path:"/frontend-network/browser-workflow.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-155d8bd6").then(t)}},{name:"v-a174ed7c",path:"/mp/api-ability/api.html",component:cs,beforeEnter:function(n,e,t){Ui("Layout","v-a174ed7c").then(t)}},{path:"*",component:cs}],us={title:"HiDoc",description:"",base:"/",headTags:[],pages:[{frontmatter:{},regularPath:"/frontend-network/_references.html",relativePath:"frontend-network/_references.md",key:"v-7700522a",path:"/frontend-network/_references.html",headersStr:null,content:" * browser-workflow\n\n * * https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\n\n * web资料\n\n * * https://frontendmasters.com/books/front-end-handbook/2018/learning/browsers.html",normalizedContent:" * browser-workflow\n\n * * https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\n\n * web资料\n\n * * https://frontendmasters.com/books/front-end-handbook/2018/learning/browsers.html",charsets:{cjk:!0}},{title:"网络入门",frontmatter:{},regularPath:"/frontend-network/web-intro.html",relativePath:"frontend-network/web-intro.md",key:"v-9e5658da",path:"/frontend-network/web-intro.html",headers:[{level:2,title:"客户端和服务器",slug:"客户端和服务器",normalizedTitle:"客户端和服务器",charIndex:102},{level:2,title:"其他部分",slug:"其他部分",normalizedTitle:"其他部分",charIndex:321},{level:2,title:"访问过程",slug:"访问过程",normalizedTitle:"访问过程",charIndex:936},{level:2,title:"网页呈现",slug:"网页呈现",normalizedTitle:"网页呈现",charIndex:1237},{level:2,title:"DNS 解析",slug:"dns-解析",normalizedTitle:"dns 解析",charIndex:1759},{level:2,title:"数据包详解",slug:"数据包详解",normalizedTitle:"数据包详解",charIndex:1999}],headersStr:"客户端和服务器 其他部分 访问过程 网页呈现 DNS 解析 数据包详解",content:'# 网络入门\n\n这篇文章简单描述了你在计算机或手机上通过浏览器访问网页时发生了什么。\n\n这个理论在短期内对你编写网页代码不会有实质性的帮助，但是不久之后你就会真正受益于理解了后台究竟发生了什么。\n\n\n# 客户端和服务器\n\n连接到互联网的计算机被称作客户端和服务器。下面是一个简单描述它们如何交互的图表：\n\n\n\n * 客户端是典型的Web用户入网设备（比如，你连接了Wi-Fi的电脑，或接入移动网络的手机）和设备上可联网的软件（通常使用像 Firefox 和 Chrome 的浏览器）。\n * 服务器是存储网页，站点和应用的计算机。当一个客户端设备想要获取一个网页时，一份网页的拷贝将从服务器上下载到客户端机器上来在用户浏览器上显示。\n\n\n# 其他部分\n\n我们讲的客户端和服务器并不能完成全部工作。还有其他必要的部分，我们将在下面讲述。\n\n现在，让我们假设 Web 就是一条路。路的一端是客户端，就像你的家。另一端则是服务器，就像你想去的商店。\n\n\n\n除了客户端和服务器之外，我们还需要向以下人员打招呼：\n\n * 网络连接: 允许你在互联网上发送和接受数据。基本上和你家到商店的街道差不多。\n * TCP/IP: 传输控制协议和互联网协议是定义数据如何在互联网上传输的通信协议。这就像运输机制，让你下订单，去商店，并购买你的商品。在我们的示例中，这类似于一辆汽车或一辆自行车(或者您可能到处走动的其他东西)\n * DNS: 域名系统服务器像是一本网站通讯录。当你在浏览器内输入一个网址时，浏览器获取网页之前将会查看域名系统。浏览器需要找到存放你想要的网页的服务器，才能发送 HTTP 请求到正确的地方。就像你要知道商店的地址才能到达那。\n * HTTP: 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（protocol ）。就像你下订单时所说的话一样。\n * 组成文件：一个网页由许多文件组成，就像商店里不同的商品一样。这些文件有两种类型：\n   * 代码 : 网页大体由 HTML、CSS、JavaScript组成，不过你会在后面看到不同的技术。\n   * 资源 : 这是其他组成网页的东西的集合，比如图像、音乐、视频、Word 文档、PDF 文件。\n\n\n# 访问过程\n\n当你在浏览器里输入一个网址时（在我们的例子里就是走向商店的路上时）：\n\n 1. 浏览器在域名系统（DNS）服务器上找出存放网页的服务器的实际地址（找出商店的位置）。\n 2. 浏览器发送 HTTP 请求信息到服务器来请拷贝一份网页到客户端（你走到商店并下订单）。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网使用 TCP/IP 协议传输的。\n 3. 服务器同意客户端的请求后，会返回一个“200 OK”信息，意味着“你可以查看这个网页，给你~”，然后开始将网页的文件以数据包的形式传输到浏览器（商店给你商品，你将商品带回家）。\n 4. 浏览器将数据包聚集成完整的网页然后将网页呈现给你（商品到了你的门口 —— 新东西，好棒！）。\n\n\n# 网页呈现\n\n当浏览器向服务器发送 HTML 文件请求时，这些 HTML 文件通常包含引用外部 CSS 样式表的 <link> 元素和引用外部 JavaScript 脚本的 <script> 元素。当浏览器加载页面时，了解这些文件被浏览器解析的顺序是很重要的：\n\n * 浏览器首先解析 HTML 文件，这使浏览器识别对外部 CSS 样式表的任何 <link> 元素引用和对脚本的任何 <script> 元素引用。\n * 当浏览器解析 HTML 时，它将请求发送回服务器，以获取从 <link> 元素中找到的任何 CSS 文件，以及从 <script> 元素中找到的任何 JavaScript 文件，然后从这些文件中解析 CSS 和 JavaScript .\n * 浏览器从解析的 HTML 生成内存中的 DOM 树，从解析的 CSS 生成内存中的 CSSOM 结构，并编译并执行解析的 JavaScript。\n * 当浏览器构建 DOM 树并应用 CSSOM 树中的样式并执行 JavaScript 时，页面的视觉表示被绘制到屏幕上，用户看到页面内容并可以开始与之交互。\n\n\n# DNS 解析\n\n真正的网址看上去并不像你输入到地址框中的那样美好且容易记忆。它们是一串数字，像 63.245.217.105。\n\n这叫做 IP 地址，它代表了一个互联网上独特的位置。然而，它并不容易记忆，不是吗？那就是域名系统（DNS）被发明的原因。它们是将你输入浏览器的地址（像 "mozilla.org"）与实际 IP 地址相匹配的特殊的服务器。\n\n网页可以通过 IP 地址直接访问。您可以通过在 IP Checker 等工具中输入域名来查找网站的 IP 地址。\n\n\n\n\n# 数据包详解\n\n前面我们用“包”来描述了数据从服务器到客户端传输的格式。这是什么意思？基本上，当数据在 Web 上传输时，是以成千上万的小数据块的形式传输的。大量不同的用户都可以同时下载同一个网页。如果网页以单个大的数据块形式传输，一次就只有一个用户下载，无疑会让 Web 非常没有效率并且失去很多乐趣。',normalizedContent:'# 网络入门\n\n这篇文章简单描述了你在计算机或手机上通过浏览器访问网页时发生了什么。\n\n这个理论在短期内对你编写网页代码不会有实质性的帮助，但是不久之后你就会真正受益于理解了后台究竟发生了什么。\n\n\n# 客户端和服务器\n\n连接到互联网的计算机被称作客户端和服务器。下面是一个简单描述它们如何交互的图表：\n\n\n\n * 客户端是典型的web用户入网设备（比如，你连接了wi-fi的电脑，或接入移动网络的手机）和设备上可联网的软件（通常使用像 firefox 和 chrome 的浏览器）。\n * 服务器是存储网页，站点和应用的计算机。当一个客户端设备想要获取一个网页时，一份网页的拷贝将从服务器上下载到客户端机器上来在用户浏览器上显示。\n\n\n# 其他部分\n\n我们讲的客户端和服务器并不能完成全部工作。还有其他必要的部分，我们将在下面讲述。\n\n现在，让我们假设 web 就是一条路。路的一端是客户端，就像你的家。另一端则是服务器，就像你想去的商店。\n\n\n\n除了客户端和服务器之外，我们还需要向以下人员打招呼：\n\n * 网络连接: 允许你在互联网上发送和接受数据。基本上和你家到商店的街道差不多。\n * tcp/ip: 传输控制协议和互联网协议是定义数据如何在互联网上传输的通信协议。这就像运输机制，让你下订单，去商店，并购买你的商品。在我们的示例中，这类似于一辆汽车或一辆自行车(或者您可能到处走动的其他东西)\n * dns: 域名系统服务器像是一本网站通讯录。当你在浏览器内输入一个网址时，浏览器获取网页之前将会查看域名系统。浏览器需要找到存放你想要的网页的服务器，才能发送 http 请求到正确的地方。就像你要知道商店的地址才能到达那。\n * http: 超文本传输协议是一个定义客户端和服务器间交流的语言的协议（protocol ）。就像你下订单时所说的话一样。\n * 组成文件：一个网页由许多文件组成，就像商店里不同的商品一样。这些文件有两种类型：\n   * 代码 : 网页大体由 html、css、javascript组成，不过你会在后面看到不同的技术。\n   * 资源 : 这是其他组成网页的东西的集合，比如图像、音乐、视频、word 文档、pdf 文件。\n\n\n# 访问过程\n\n当你在浏览器里输入一个网址时（在我们的例子里就是走向商店的路上时）：\n\n 1. 浏览器在域名系统（dns）服务器上找出存放网页的服务器的实际地址（找出商店的位置）。\n 2. 浏览器发送 http 请求信息到服务器来请拷贝一份网页到客户端（你走到商店并下订单）。这条消息，包括其他所有在客户端和服务器之间传递的数据都是通过互联网使用 tcp/ip 协议传输的。\n 3. 服务器同意客户端的请求后，会返回一个“200 ok”信息，意味着“你可以查看这个网页，给你~”，然后开始将网页的文件以数据包的形式传输到浏览器（商店给你商品，你将商品带回家）。\n 4. 浏览器将数据包聚集成完整的网页然后将网页呈现给你（商品到了你的门口 —— 新东西，好棒！）。\n\n\n# 网页呈现\n\n当浏览器向服务器发送 html 文件请求时，这些 html 文件通常包含引用外部 css 样式表的 <link> 元素和引用外部 javascript 脚本的 <script> 元素。当浏览器加载页面时，了解这些文件被浏览器解析的顺序是很重要的：\n\n * 浏览器首先解析 html 文件，这使浏览器识别对外部 css 样式表的任何 <link> 元素引用和对脚本的任何 <script> 元素引用。\n * 当浏览器解析 html 时，它将请求发送回服务器，以获取从 <link> 元素中找到的任何 css 文件，以及从 <script> 元素中找到的任何 javascript 文件，然后从这些文件中解析 css 和 javascript .\n * 浏览器从解析的 html 生成内存中的 dom 树，从解析的 css 生成内存中的 cssom 结构，并编译并执行解析的 javascript。\n * 当浏览器构建 dom 树并应用 cssom 树中的样式并执行 javascript 时，页面的视觉表示被绘制到屏幕上，用户看到页面内容并可以开始与之交互。\n\n\n# dns 解析\n\n真正的网址看上去并不像你输入到地址框中的那样美好且容易记忆。它们是一串数字，像 63.245.217.105。\n\n这叫做 ip 地址，它代表了一个互联网上独特的位置。然而，它并不容易记忆，不是吗？那就是域名系统（dns）被发明的原因。它们是将你输入浏览器的地址（像 "mozilla.org"）与实际 ip 地址相匹配的特殊的服务器。\n\n网页可以通过 ip 地址直接访问。您可以通过在 ip checker 等工具中输入域名来查找网站的 ip 地址。\n\n\n\n\n# 数据包详解\n\n前面我们用“包”来描述了数据从服务器到客户端传输的格式。这是什么意思？基本上，当数据在 web 上传输时，是以成千上万的小数据块的形式传输的。大量不同的用户都可以同时下载同一个网页。如果网页以单个大的数据块形式传输，一次就只有一个用户下载，无疑会让 web 非常没有效率并且失去很多乐趣。',charsets:{cjk:!0}},{title:"HTTP 协议",frontmatter:{},regularPath:"/frontend-network/http-protocol.html",relativePath:"frontend-network/http-protocol.md",key:"v-097775ff",path:"/frontend-network/http-protocol.html",headersStr:null,content:"# HTTP 协议\n\n> building...",normalizedContent:"# http 协议\n\n> building...",charsets:{cjk:!0}},{title:"web 安全",frontmatter:{},regularPath:"/frontend-network/web-security.html",relativePath:"frontend-network/web-security.md",key:"v-533a7316",path:"/frontend-network/web-security.html",headersStr:null,content:"# web 安全\n\n * xss\n * csrf",normalizedContent:"# web 安全\n\n * xss\n * csrf",charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroText:null,tagline:null},regularPath:"/",relativePath:"index.md",key:"v-7bd7c3e1",path:"/",headersStr:null,content:"# 存档\n\n * 微信小程序\n * 前端网络\n * Vue 3 Deep Dive",normalizedContent:"# 存档\n\n * 微信小程序\n * 前端网络\n * vue 3 deep dive",charsets:{cjk:!0}},{title:"网页渲染",frontmatter:{},regularPath:"/frontend-network/webpage-rendering.html",relativePath:"frontend-network/webpage-rendering.md",key:"v-37caf9b5",path:"/frontend-network/webpage-rendering.html",headers:[{level:2,title:"浏览器如何渲染网页",slug:"浏览器如何渲染网页",normalizedTitle:"浏览器如何渲染网页",charIndex:284},{level:2,title:"Repaint(重绘)",slug:"repaint-重绘",normalizedTitle:"repaint(重绘)",charIndex:814},{level:2,title:"Reflow(重排/回流)",slug:"reflow-重排-回流",normalizedTitle:"reflow(重排/回流)",charIndex:943},{level:2,title:"浏览器如何优化渲染",slug:"浏览器如何优化渲染",normalizedTitle:"浏览器如何优化渲染",charIndex:1158},{level:2,title:"关于优化的实用建议",slug:"关于优化的实用建议",normalizedTitle:"关于优化的实用建议",charIndex:3159}],headersStr:"浏览器如何渲染网页 Repaint(重绘) Reflow(重排/回流) 浏览器如何优化渲染 关于优化的实用建议",content:"# 网页渲染\n\n今天我想集中讨论网页渲染的主题，以及为什么它在网页开发中很重要。有很多文章都涉及到这个主题，但是这些信息是零散的，而且有些支离破碎。例如，为了理解这个主题，我必须研究很多资料。这就是为什么我决定写这篇文章。我相信这篇文章对于初学者和那些想要更新和组织他们已经知道的东西的高级开发人员都是有用的。\n\n渲染必须从一开始就进行优化，因为样式和脚本在页面渲染中起着至关重要的作用。为了避免性能问题，专业人士必须知道一些技巧。\n\n本文没有详细研究内部浏览器机制，而是提供了一些常见的原则。不同的浏览器引擎工作方式不同，这会使特定于浏览器的研究更加复杂。\n\n\n# 浏览器如何渲染网页\n\n我们首先概述一下呈现页面时浏览器的操作:\n\n 1. DOM (文档对象模型)是由从服务器接收的 HTML 构成的\n 2. 样式被加载和解析，形成 CSSOM (CSS 对象模型)\n 3. 在 DOM 和 CSSOM 之上，创建了一个渲染树，它是一组要渲染的对象（Webkit 将这些对象中的每一个称为“渲染器(renderer)”或“渲染对象(render object)”，而在 Gecko 中它是一个“框架(frame)”）。渲染树反映了 DOM 结构，除了不可见元素（如标签或具有 display:none; 的元素）。每个文本字符串在渲染树中表示为单独的渲染器。每个渲染对象都包含其对应的 DOM 对象（或文本块）以及计算出的样式。换句话说，渲染树描述了 DOM 的可视化表示。\n 4. 对于每个渲染树元素，计算它的坐标，这被称为“布局(layout)”。浏览器使用流布局(flow method)，该方法只需要一次传递就可以布局所有元素(表需要多次传递)\n 5. 最后，这实际上会显示在一个浏览器窗口中，这个过程称为“绘制”\n\n当用户与页面交互时，或者脚本修改它时，随着底层页面结构的变化，前面提到的一些操作必须重复。\n\n\n# Repaint(重绘)\n\n当更改不影响元素在页面上位置的元素样式(比如background-color、border-color、visibility)时，浏览器只需用新的样式重新绘制元素(这意味着正在进行“repaint”或“restyle”)。\n\n\n# Reflow(重排/回流)\n\n当更改影响到文档内容、结构或元素位置时，将发生回流(Reflow)(或重新布局(relayout))。这些变化通常由以下因素触发:\n\n * DOM 操作(元素添加、删除、更改或更改元素顺序)\n * 内容更改，包括表单字段中的文本更改\n * 计算或改变 CSS 属性\n * 添加或删除样式表\n * 更改\"class\"属性\n * 浏览器窗口操作(调整大小，滚动)\n * 伪类激活(:hover)\n\n\n# 浏览器如何优化渲染\n\n浏览器正在尽最大努力将重新绘制/回流限制在只覆盖已更改元素的区域。例如，绝对/固定定位元素的大小变化只影响元素本身及其后代，而静态定位元素的类似变化会触发所有后续元素的复流。\n\n另一种优化技术是，在运行 JavaScript 代码的同时，浏览器缓存这些更改，并在代码运行后一次性应用它们。例如，这段代码只会触发一次回流和重绘:\n\nvar $body = $('body');\n$body.css('padding', '1px'); // reflow, repaint\n$body.css('color', 'red'); // repaint\n$body.css('margin', '2px'); // reflow, repaint\n// only 1 reflow and repaint will actually happen\n\n\n但是，如上所述，访问元素属性会触发强制回流。如果我们在前面的代码块中添加一行元素属性，就会出现这种情况:\n\nvar $body = $('body');\n$body.css('padding', '1px');\n$body.css('padding'); // reading a property, a forced reflow\n$body.css('color', 'red');\n$body.css('margin', '2px');\n\n\n因此，我们得到了两个回流而不是一个。因此，您应该将读取元素属性组合在一起，以优化性能(参见关于 JSBin 的更详细的示例)。\n\n有些情况下，你不得不触发强迫复流。示例: 我们必须对同一个元素应用相同的属性(例如“ margin-left”)两次。最初，它应该设置为100px 没有动画，然后它必须转换为50px 的值动画。您现在可以在 JSBin 上研究这个示例，但是我将在这里更详细地描述它。\n\n我们首先创建一个带有转换的 CSS 类:\n\n.has-transition {\n    -webkit-transition: margin-left 1s ease-out;\n        -moz-transition: margin-left 1s ease-out;\n        -o-transition: margin-left 1s ease-out;\n            transition: margin-left 1s ease-out;\n}\n\n\n然后继续执行:\n\n// our element that has a \"has-transition\" class by default\nvar $targetElem = $('#targetElemId');\n\n// remove the transition class\n$targetElem.removeClass('has-transition');\n\n// change the property expecting the transition to be off, as the class is not there\n// anymore\n$targetElem.css('margin-left', 100);\n\n// put the transition class back\n$targetElem.addClass('has-transition');\n\n// change the property\n$targetElem.css('margin-left', 50);\n\n\n但是，这种实现并不像预期的那样工作。这些更改将被缓存并仅应用于代码块的末尾。我们需要的是强制回流，我们可以通过以下变化来实现:\n\n// remove the transition class\n$(this).removeClass('has-transition');\n\n// change the property\n$(this).css('margin-left', 100);\n\n// trigger a forced reflow, so that changes in a class/property get applied immediately\n$(this)[0].offsetHeight; // an example, other properties would work, too\n\n// put the transition class back\n$(this).addClass('has-transition');\n\n// change the property\n$(this).css('margin-left', 50);\n\n\n现在这个工作正如预期的那样。\n\n\n# 关于优化的实用建议\n\n总结现有的信息，我可以建议如下:\n\n * 创建有效的 HTML 和 CSS，不要忘记指定文档编码。样式应该包含在标记中，脚本应该附加到标记的末尾\n * 尝试简化和优化 CSS 选择器(这种优化几乎被主要使用 CSS 预处理器的开发人员所忽略)。将嵌套级别保持在最低水平。下面是 CSS 选择器根据性能排名的方法(从最快的开始)：\n   * 标识符:#id\n   * 类别:.class\n   * 标签:div\n   * 相邻的兄弟姐妹选择器:a + i\n   * 父选择器:ul > li\n   * 通用选择器:*\n   * 属性选择器:input[type=\"text\"]\n   * 伪类和伪元素: 你应该记住浏览器从右到左处理选择器，这就是为什么最右边的选择器应该是最快的选择器 或.class\n\ndiv * {...} // bad\n.list li {...} // bad\n.list-item {...} // good\n#list .list-item {...} // good\n\n\n 1. 在脚本中，尽可能减少 DOM 操作。缓存所有内容，包括属性和对象(如果要重用它们的话)。在执行复杂的操作时，最好使用“ offline”元素(“ offline”元素是与 DOM 断开连接并仅存储在内存中的元素) ，然后将其附加到 DOM\n 2. 如果您使用 jQuery 来选择元素，请遵循 jQuery 选择器的最佳实践\n 3. 要改变元素的样式，修改“ class”属性是最有效的方法之一。这种更改在 DOM 树中执行得越深入越好(还因为这有助于将逻辑与表示分离)\n 4. 如果可以的话，只对绝对/固定位置的元素进行动画处理\n 5. 禁用复杂系统是一个好主意 在滚动时使用动画(例如添加一个额外的“ no-hover”类)\n\n为了获得更详细的概述，看看这些文章:\n\n 1. 浏览器是如何工作的\n 2. 渲染(rendering): 重绘(repaint)，回流/重新布局(reflowrelayout)，重设(restyle)",normalizedContent:"# 网页渲染\n\n今天我想集中讨论网页渲染的主题，以及为什么它在网页开发中很重要。有很多文章都涉及到这个主题，但是这些信息是零散的，而且有些支离破碎。例如，为了理解这个主题，我必须研究很多资料。这就是为什么我决定写这篇文章。我相信这篇文章对于初学者和那些想要更新和组织他们已经知道的东西的高级开发人员都是有用的。\n\n渲染必须从一开始就进行优化，因为样式和脚本在页面渲染中起着至关重要的作用。为了避免性能问题，专业人士必须知道一些技巧。\n\n本文没有详细研究内部浏览器机制，而是提供了一些常见的原则。不同的浏览器引擎工作方式不同，这会使特定于浏览器的研究更加复杂。\n\n\n# 浏览器如何渲染网页\n\n我们首先概述一下呈现页面时浏览器的操作:\n\n 1. dom (文档对象模型)是由从服务器接收的 html 构成的\n 2. 样式被加载和解析，形成 cssom (css 对象模型)\n 3. 在 dom 和 cssom 之上，创建了一个渲染树，它是一组要渲染的对象（webkit 将这些对象中的每一个称为“渲染器(renderer)”或“渲染对象(render object)”，而在 gecko 中它是一个“框架(frame)”）。渲染树反映了 dom 结构，除了不可见元素（如标签或具有 display:none; 的元素）。每个文本字符串在渲染树中表示为单独的渲染器。每个渲染对象都包含其对应的 dom 对象（或文本块）以及计算出的样式。换句话说，渲染树描述了 dom 的可视化表示。\n 4. 对于每个渲染树元素，计算它的坐标，这被称为“布局(layout)”。浏览器使用流布局(flow method)，该方法只需要一次传递就可以布局所有元素(表需要多次传递)\n 5. 最后，这实际上会显示在一个浏览器窗口中，这个过程称为“绘制”\n\n当用户与页面交互时，或者脚本修改它时，随着底层页面结构的变化，前面提到的一些操作必须重复。\n\n\n# repaint(重绘)\n\n当更改不影响元素在页面上位置的元素样式(比如background-color、border-color、visibility)时，浏览器只需用新的样式重新绘制元素(这意味着正在进行“repaint”或“restyle”)。\n\n\n# reflow(重排/回流)\n\n当更改影响到文档内容、结构或元素位置时，将发生回流(reflow)(或重新布局(relayout))。这些变化通常由以下因素触发:\n\n * dom 操作(元素添加、删除、更改或更改元素顺序)\n * 内容更改，包括表单字段中的文本更改\n * 计算或改变 css 属性\n * 添加或删除样式表\n * 更改\"class\"属性\n * 浏览器窗口操作(调整大小，滚动)\n * 伪类激活(:hover)\n\n\n# 浏览器如何优化渲染\n\n浏览器正在尽最大努力将重新绘制/回流限制在只覆盖已更改元素的区域。例如，绝对/固定定位元素的大小变化只影响元素本身及其后代，而静态定位元素的类似变化会触发所有后续元素的复流。\n\n另一种优化技术是，在运行 javascript 代码的同时，浏览器缓存这些更改，并在代码运行后一次性应用它们。例如，这段代码只会触发一次回流和重绘:\n\nvar $body = $('body');\n$body.css('padding', '1px'); // reflow, repaint\n$body.css('color', 'red'); // repaint\n$body.css('margin', '2px'); // reflow, repaint\n// only 1 reflow and repaint will actually happen\n\n\n但是，如上所述，访问元素属性会触发强制回流。如果我们在前面的代码块中添加一行元素属性，就会出现这种情况:\n\nvar $body = $('body');\n$body.css('padding', '1px');\n$body.css('padding'); // reading a property, a forced reflow\n$body.css('color', 'red');\n$body.css('margin', '2px');\n\n\n因此，我们得到了两个回流而不是一个。因此，您应该将读取元素属性组合在一起，以优化性能(参见关于 jsbin 的更详细的示例)。\n\n有些情况下，你不得不触发强迫复流。示例: 我们必须对同一个元素应用相同的属性(例如“ margin-left”)两次。最初，它应该设置为100px 没有动画，然后它必须转换为50px 的值动画。您现在可以在 jsbin 上研究这个示例，但是我将在这里更详细地描述它。\n\n我们首先创建一个带有转换的 css 类:\n\n.has-transition {\n    -webkit-transition: margin-left 1s ease-out;\n        -moz-transition: margin-left 1s ease-out;\n        -o-transition: margin-left 1s ease-out;\n            transition: margin-left 1s ease-out;\n}\n\n\n然后继续执行:\n\n// our element that has a \"has-transition\" class by default\nvar $targetelem = $('#targetelemid');\n\n// remove the transition class\n$targetelem.removeclass('has-transition');\n\n// change the property expecting the transition to be off, as the class is not there\n// anymore\n$targetelem.css('margin-left', 100);\n\n// put the transition class back\n$targetelem.addclass('has-transition');\n\n// change the property\n$targetelem.css('margin-left', 50);\n\n\n但是，这种实现并不像预期的那样工作。这些更改将被缓存并仅应用于代码块的末尾。我们需要的是强制回流，我们可以通过以下变化来实现:\n\n// remove the transition class\n$(this).removeclass('has-transition');\n\n// change the property\n$(this).css('margin-left', 100);\n\n// trigger a forced reflow, so that changes in a class/property get applied immediately\n$(this)[0].offsetheight; // an example, other properties would work, too\n\n// put the transition class back\n$(this).addclass('has-transition');\n\n// change the property\n$(this).css('margin-left', 50);\n\n\n现在这个工作正如预期的那样。\n\n\n# 关于优化的实用建议\n\n总结现有的信息，我可以建议如下:\n\n * 创建有效的 html 和 css，不要忘记指定文档编码。样式应该包含在标记中，脚本应该附加到标记的末尾\n * 尝试简化和优化 css 选择器(这种优化几乎被主要使用 css 预处理器的开发人员所忽略)。将嵌套级别保持在最低水平。下面是 css 选择器根据性能排名的方法(从最快的开始)：\n   * 标识符:#id\n   * 类别:.class\n   * 标签:div\n   * 相邻的兄弟姐妹选择器:a + i\n   * 父选择器:ul > li\n   * 通用选择器:*\n   * 属性选择器:input[type=\"text\"]\n   * 伪类和伪元素: 你应该记住浏览器从右到左处理选择器，这就是为什么最右边的选择器应该是最快的选择器 或.class\n\ndiv * {...} // bad\n.list li {...} // bad\n.list-item {...} // good\n#list .list-item {...} // good\n\n\n 1. 在脚本中，尽可能减少 dom 操作。缓存所有内容，包括属性和对象(如果要重用它们的话)。在执行复杂的操作时，最好使用“ offline”元素(“ offline”元素是与 dom 断开连接并仅存储在内存中的元素) ，然后将其附加到 dom\n 2. 如果您使用 jquery 来选择元素，请遵循 jquery 选择器的最佳实践\n 3. 要改变元素的样式，修改“ class”属性是最有效的方法之一。这种更改在 dom 树中执行得越深入越好(还因为这有助于将逻辑与表示分离)\n 4. 如果可以的话，只对绝对/固定位置的元素进行动画处理\n 5. 禁用复杂系统是一个好主意 在滚动时使用动画(例如添加一个额外的“ no-hover”类)\n\n为了获得更详细的概述，看看这些文章:\n\n 1. 浏览器是如何工作的\n 2. 渲染(rendering): 重绘(repaint)，回流/重新布局(reflowrelayout)，重设(restyle)",charsets:{cjk:!0}},{title:"组件间通信与事件",frontmatter:{},regularPath:"/mp/component-programming/communicate-and-events.html",relativePath:"mp/component-programming/communicate-and-events.md",key:"v-04a01422",path:"/mp/component-programming/communicate-and-events.html",headers:[{level:2,title:"组件间通信",slug:"组件间通信",normalizedTitle:"组件间通信",charIndex:2},{level:2,title:"监听事件",slug:"监听事件",normalizedTitle:"监听事件",charIndex:251},{level:2,title:"触发事件",slug:"触发事件",normalizedTitle:"触发事件",charIndex:579},{level:2,title:"获取组件实例",slug:"获取组件实例",normalizedTitle:"获取组件实例",charIndex:2054},{level:3,title:"自定义的组件实例获取结果",slug:"自定义的组件实例获取结果",normalizedTitle:"自定义的组件实例获取结果",charIndex:2559}],headersStr:"组件间通信 监听事件 触发事件 获取组件实例 自定义的组件实例获取结果",content:"# 组件间通信与事件\n\n\n# 组件间通信\n\n组件间的基本通信方式有以下几种。\n\n * WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。\n * 事件：用于子组件向父组件传递数据，可以传递任意数据。\n * 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。\n\n\n# 监听事件\n\n事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 事件处理 。\n\n监听自定义组件事件的方法与监听基础组件事件的方法完全一致：\n\n代码示例：\n\n\x3c!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 --\x3e\n<component-tag-name bindmyevent=\"onMyEvent\" />\n\x3c!-- 或者可以写成 --\x3e\n<component-tag-name bind:myevent=\"onMyEvent\" />\nPage({\n  onMyEvent: function(e){\n    e.detail // 自定义组件触发事件时提供的detail对象\n  }\n})\n\n\n\n# 触发事件\n\n自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail对象和事件选项：\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 在自定义组件中 --\x3e\n<button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\nComponent({\n  properties: {},\n  methods: {\n    onTap: function(){\n      var myEventDetail = {} // detail对象，提供给事件监听函数\n      var myEventOption = {} // 触发事件的选项\n      this.triggerEvent('myevent', myEventDetail, myEventOption)\n    }\n  }\n})\n\n\n触发事件的选项包括：\n\n选项名            类型        是否必填   默认值     描述\nbubbles        Boolean   否      false   事件是否冒泡\ncomposed       Boolean   否      false   事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部\ncapturePhase   Boolean   否      false   事件是否拥有捕获阶段\n\n关于冒泡和捕获阶段的概念，请阅读 事件处理 章节中的相关说明。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 页面 page.wxml\n<another-component bindcustomevent=\"pageEventListener1\">\n  <my-component bindcustomevent=\"pageEventListener2\"></my-component>\n</another-component>\n// 组件 another-component.wxml\n<view bindcustomevent=\"anotherEventListener\">\n  <slot />\n</view>\n// 组件 my-component.wxml\n<view bindcustomevent=\"myEventListener\">\n  <slot />\n</view>\n// 组件 my-component.js\nComponent({\n  methods: {\n    onTap: function(){\n      this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2\n      this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1\n      this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1\n    }\n  }\n})\n\n\n\n# 获取组件实例\n\n可在父组件里调用 this.selectComponent ，获取子组件的实例对象。\n\n调用时需要传入一个匹配选择器 selector，如：this.selectComponent(\".my-component\")。\n\nselector 详细语法可查看 selector 语法参考文档。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 父组件\nPage({\n  data: {},\n  getChildComponent: function () {\n    const child = this.selectComponent('.my-component');\n    console.log(child)\n  }\n})\n\n\n在上例中，父组件将会获取 class 为 my-component 的子组件实例对象，即子组件的 this 。\n\n注意 ：默认情况下，小程序与插件之间、不同插件之间的组件将无法通过 selectComponent 得到组件实例（将返回 null）。如果想让一个组件在上述条件下依然能被 selectComponent 返回，可以自定义其返回结果（见下）。\n\n\n# 自定义的组件实例获取结果\n\n若需要自定义 selectComponent 返回的数据，可使用内置 behavior: wx://component-export\n\n从基础库版本 2.2.3 开始提供支持。\n\n使用该 behavior 时，自定义组件中的 export 定义段将用于指定组件被 selectComponent 调用时的返回值。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 自定义组件 my-component 内部\nComponent({\n  behaviors: ['wx://component-export'],\n  export() {\n    return { myField: 'myValue' }\n  }\n})\n\x3c!-- 使用自定义组件时 --\x3e\n<my-component id=\"the-id\" />\n// 父组件调用\nconst child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }\n\n\n在上例中，父组件获取 id 为 the-id 的子组件实例的时候，得到的是对象 { myField: 'myValue' } 。",normalizedContent:"# 组件间通信与事件\n\n\n# 组件间通信\n\n组件间的基本通信方式有以下几种。\n\n * wxml 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 json 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。\n * 事件：用于子组件向父组件传递数据，可以传递任意数据。\n * 如果以上两种方式不足以满足需要，父组件还可以通过 this.selectcomponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。\n\n\n# 监听事件\n\n事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 事件处理 。\n\n监听自定义组件事件的方法与监听基础组件事件的方法完全一致：\n\n代码示例：\n\n\x3c!-- 当自定义组件触发“myevent”事件时，调用“onmyevent”方法 --\x3e\n<component-tag-name bindmyevent=\"onmyevent\" />\n\x3c!-- 或者可以写成 --\x3e\n<component-tag-name bind:myevent=\"onmyevent\" />\npage({\n  onmyevent: function(e){\n    e.detail // 自定义组件触发事件时提供的detail对象\n  }\n})\n\n\n\n# 触发事件\n\n自定义组件触发事件时，需要使用 triggerevent 方法，指定事件名、detail对象和事件选项：\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 在自定义组件中 --\x3e\n<button bindtap=\"ontap\">点击这个按钮将触发“myevent”事件</button>\ncomponent({\n  properties: {},\n  methods: {\n    ontap: function(){\n      var myeventdetail = {} // detail对象，提供给事件监听函数\n      var myeventoption = {} // 触发事件的选项\n      this.triggerevent('myevent', myeventdetail, myeventoption)\n    }\n  }\n})\n\n\n触发事件的选项包括：\n\n选项名            类型        是否必填   默认值     描述\nbubbles        boolean   否      false   事件是否冒泡\ncomposed       boolean   否      false   事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部\ncapturephase   boolean   否      false   事件是否拥有捕获阶段\n\n关于冒泡和捕获阶段的概念，请阅读 事件处理 章节中的相关说明。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 页面 page.wxml\n<another-component bindcustomevent=\"pageeventlistener1\">\n  <my-component bindcustomevent=\"pageeventlistener2\"></my-component>\n</another-component>\n// 组件 another-component.wxml\n<view bindcustomevent=\"anothereventlistener\">\n  <slot />\n</view>\n// 组件 my-component.wxml\n<view bindcustomevent=\"myeventlistener\">\n  <slot />\n</view>\n// 组件 my-component.js\ncomponent({\n  methods: {\n    ontap: function(){\n      this.triggerevent('customevent', {}) // 只会触发 pageeventlistener2\n      this.triggerevent('customevent', {}, { bubbles: true }) // 会依次触发 pageeventlistener2 、 pageeventlistener1\n      this.triggerevent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageeventlistener2 、 anothereventlistener 、 pageeventlistener1\n    }\n  }\n})\n\n\n\n# 获取组件实例\n\n可在父组件里调用 this.selectcomponent ，获取子组件的实例对象。\n\n调用时需要传入一个匹配选择器 selector，如：this.selectcomponent(\".my-component\")。\n\nselector 详细语法可查看 selector 语法参考文档。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 父组件\npage({\n  data: {},\n  getchildcomponent: function () {\n    const child = this.selectcomponent('.my-component');\n    console.log(child)\n  }\n})\n\n\n在上例中，父组件将会获取 class 为 my-component 的子组件实例对象，即子组件的 this 。\n\n注意 ：默认情况下，小程序与插件之间、不同插件之间的组件将无法通过 selectcomponent 得到组件实例（将返回 null）。如果想让一个组件在上述条件下依然能被 selectcomponent 返回，可以自定义其返回结果（见下）。\n\n\n# 自定义的组件实例获取结果\n\n若需要自定义 selectcomponent 返回的数据，可使用内置 behavior: wx://component-export\n\n从基础库版本 2.2.3 开始提供支持。\n\n使用该 behavior 时，自定义组件中的 export 定义段将用于指定组件被 selectcomponent 调用时的返回值。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// 自定义组件 my-component 内部\ncomponent({\n  behaviors: ['wx://component-export'],\n  export() {\n    return { myfield: 'myvalue' }\n  }\n})\n\x3c!-- 使用自定义组件时 --\x3e\n<my-component id=\"the-id\" />\n// 父组件调用\nconst child = this.selectcomponent('#the-id') // 等于 { myfield: 'myvalue' }\n\n\n在上例中，父组件获取 id 为 the-id 的子组件实例的时候，得到的是对象 { myfield: 'myvalue' } 。",charsets:{cjk:!0}},{title:"DNS 简述",frontmatter:{},regularPath:"/frontend-network/dns.html",relativePath:"frontend-network/dns.md",key:"v-059aa732",path:"/frontend-network/dns.html",headersStr:null,content:"# DNS 简述\n\n> 页面施工中",normalizedContent:"# dns 简述\n\n> 页面施工中",charsets:{cjk:!0}},{title:"Component 构造器",frontmatter:{},regularPath:"/mp/component-programming/constructor.html",relativePath:"mp/component-programming/constructor.md",key:"v-1339279e",path:"/mp/component-programming/constructor.html",headers:[{level:2,title:"使用 Component 构造器构造页面",slug:"使用-component-构造器构造页面",normalizedTitle:"使用 component 构造器构造页面",charIndex:1053}],headersStr:"使用 Component 构造器构造页面",content:"# Component 构造器\n\nComponent 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。\n\n详细的参数含义和使用请参考 Component 参考文档。\n\nComponent({\n\n  behaviors: [],\n\n  properties: {\n    myProperty: { // 属性名\n      type: String,\n      value: ''\n    },\n    myProperty2: String // 简化的定义方式\n  },\n  \n  data: {}, // 私有数据，可用于模板渲染\n\n  lifetimes: {\n    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\n    attached: function () { },\n    moved: function () { },\n    detached: function () { },\n  },\n\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\n  attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖\n  ready: function() { },\n\n  pageLifetimes: {\n    // 组件所在页面的生命周期函数\n    show: function () { },\n    hide: function () { },\n    resize: function () { },\n  },\n\n  methods: {\n    onMyButtonTap: function(){\n      this.setData({\n        // 更新属性和数据的方法与更新页面数据的方法类似\n      })\n    },\n    // 内部方法建议以下划线开头\n    _myPrivateMethod: function(){\n      // 这里将 data.A[0].B 设为 'myPrivateData'\n      this.setData({\n        'A[0].B': 'myPrivateData'\n      })\n    },\n    _propertyChange: function(newVal, oldVal) {\n\n    }\n  }\n\n})\n\n\n\n# 使用 Component 构造器构造页面\n\n事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 usingComponents 定义段。\n\n此时，组件的属性可以用于接收页面的参数，如访问页面 /pages/index/index?paramA=123&paramB=xyz ，如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz 。\n\n页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。\n\n代码示例：\n\n{\n  \"usingComponents\": {}\n}\nComponent({\n\n  properties: {\n    paramA: Number,\n    paramB: String,\n  },\n\n  methods: {\n    onLoad: function() {\n      this.data.paramA // 页面参数 paramA 的值\n      this.data.paramB // 页面参数 paramB 的值\n    }\n  }\n\n})\n\n\n使用 Component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。\n\n例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中。\n\n代码示例：\n\n// page-common-behavior.js\nmodule.exports = Behavior({\n  attached: function() {\n    // 页面创建时执行\n    console.info('Page loaded!')\n  },\n  detached: function() {\n    // 页面销毁时执行\n    console.info('Page unloaded!')\n  }\n})\n// 页面 A\nvar pageCommonBehavior = require('./page-common-behavior')\nComponent({\n  behaviors: [pageCommonBehavior],\n  data: { /* ... */ },\n  methods: { /* ... */ },\n})\n// 页面 B\nvar pageCommonBehavior = require('./page-common-behavior')\nComponent({\n  behaviors: [pageCommonBehavior],\n  data: { /* ... */ },\n  methods: { /* ... */ },\n})\n",normalizedContent:"# component 构造器\n\ncomponent 构造器可用于定义组件，调用 component 构造器时可以指定组件的属性、数据、方法等。\n\n详细的参数含义和使用请参考 component 参考文档。\n\ncomponent({\n\n  behaviors: [],\n\n  properties: {\n    myproperty: { // 属性名\n      type: string,\n      value: ''\n    },\n    myproperty2: string // 简化的定义方式\n  },\n  \n  data: {}, // 私有数据，可用于模板渲染\n\n  lifetimes: {\n    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\n    attached: function () { },\n    moved: function () { },\n    detached: function () { },\n  },\n\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\n  attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖\n  ready: function() { },\n\n  pagelifetimes: {\n    // 组件所在页面的生命周期函数\n    show: function () { },\n    hide: function () { },\n    resize: function () { },\n  },\n\n  methods: {\n    onmybuttontap: function(){\n      this.setdata({\n        // 更新属性和数据的方法与更新页面数据的方法类似\n      })\n    },\n    // 内部方法建议以下划线开头\n    _myprivatemethod: function(){\n      // 这里将 data.a[0].b 设为 'myprivatedata'\n      this.setdata({\n        'a[0].b': 'myprivatedata'\n      })\n    },\n    _propertychange: function(newval, oldval) {\n\n    }\n  }\n\n})\n\n\n\n# 使用 component 构造器构造页面\n\n事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 component 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 usingcomponents 定义段。\n\n此时，组件的属性可以用于接收页面的参数，如访问页面 /pages/index/index?parama=123&paramb=xyz ，如果声明有属性 parama 或 paramb ，则它们会被赋值为 123 或 xyz 。\n\n页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。\n\n代码示例：\n\n{\n  \"usingcomponents\": {}\n}\ncomponent({\n\n  properties: {\n    parama: number,\n    paramb: string,\n  },\n\n  methods: {\n    onload: function() {\n      this.data.parama // 页面参数 parama 的值\n      this.data.paramb // 页面参数 paramb 的值\n    }\n  }\n\n})\n\n\n使用 component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。\n\n例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中。\n\n代码示例：\n\n// page-common-behavior.js\nmodule.exports = behavior({\n  attached: function() {\n    // 页面创建时执行\n    console.info('page loaded!')\n  },\n  detached: function() {\n    // 页面销毁时执行\n    console.info('page unloaded!')\n  }\n})\n// 页面 a\nvar pagecommonbehavior = require('./page-common-behavior')\ncomponent({\n  behaviors: [pagecommonbehavior],\n  data: { /* ... */ },\n  methods: { /* ... */ },\n})\n// 页面 b\nvar pagecommonbehavior = require('./page-common-behavior')\ncomponent({\n  behaviors: [pagecommonbehavior],\n  data: { /* ... */ },\n  methods: { /* ... */ },\n})\n",charsets:{cjk:!0}},{title:"组件生命周期",frontmatter:{},regularPath:"/mp/component-programming/lifecycle.html",relativePath:"mp/component-programming/lifecycle.md",key:"v-255b6cbe",path:"/mp/component-programming/lifecycle.html",headers:[{level:2,title:"定义生命周期方法",slug:"定义生命周期方法",normalizedTitle:"定义生命周期方法",charIndex:438},{level:2,title:"组件所在页面的生命周期",slug:"组件所在页面的生命周期",normalizedTitle:"组件所在页面的生命周期",charIndex:1403}],headersStr:"定义生命周期方法 组件所在页面的生命周期",content:"# 组件生命周期\n\n组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。\n\n其中，最重要的生命周期是 created、 attached、 detached ，包含一个组件实例生命流程的最主要时间点。\n\n * 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。\n * 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。\n * 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。\n\n\n# 定义生命周期方法\n\n生命周期方法可以直接定义在 Component 构造器的第一级参数中。\n\n自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。\n\n代码示例：\n\nComponent({\n  lifetimes: {\n    attached: function() {\n      // 在组件实例进入页面节点树时执行\n    },\n    detached: function() {\n      // 在组件实例被从页面节点树移除时执行\n    },\n  },\n  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容\n  attached: function() {\n    // 在组件实例进入页面节点树时执行\n  },\n  detached: function() {\n    // 在组件实例被从页面节点树移除时执行\n  },\n  // ...\n})\n\n\n在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。\n\n可用的全部生命周期如下表所示。\n\n生命周期       参数             描述                     最低版本\ncreated    无              在组件实例刚刚被创建时执行          1.6.3\nattached   无              在组件实例进入页面节点树时执行        1.6.3\nready      无              在组件在视图层布局完成后执行         1.6.3\nmoved      无              在组件实例被移动到节点树另一个位置时执行   1.6.3\ndetached   无              在组件实例被从页面节点树移除时执行      1.6.3\nerror      Object Error   每当组件方法抛出错误时执行          2.4.1\n\n\n# 组件所在页面的生命周期\n\n还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：\n\n生命周期     参数            描述               最低版本\nshow     无             组件所在的页面被展示时执行    2.2.3\nhide     无             组件所在的页面被隐藏时执行    2.2.3\nresize   Object Size   组件所在的页面尺寸变化时执行   2.4.0\n\n代码示例：\n\nComponent({\n  pageLifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n",normalizedContent:"# 组件生命周期\n\n组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。\n\n其中，最重要的生命周期是 created、 attached、 detached ，包含一个组件实例生命流程的最主要时间点。\n\n * 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 component 构造器中定义的数据 data 。 此时还不能调用 setdata 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。\n * 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。\n * 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。\n\n\n# 定义生命周期方法\n\n生命周期方法可以直接定义在 component 构造器的第一级参数中。\n\n自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。\n\n代码示例：\n\ncomponent({\n  lifetimes: {\n    attached: function() {\n      // 在组件实例进入页面节点树时执行\n    },\n    detached: function() {\n      // 在组件实例被从页面节点树移除时执行\n    },\n  },\n  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容\n  attached: function() {\n    // 在组件实例进入页面节点树时执行\n  },\n  detached: function() {\n    // 在组件实例被从页面节点树移除时执行\n  },\n  // ...\n})\n\n\n在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。\n\n可用的全部生命周期如下表所示。\n\n生命周期       参数             描述                     最低版本\ncreated    无              在组件实例刚刚被创建时执行          1.6.3\nattached   无              在组件实例进入页面节点树时执行        1.6.3\nready      无              在组件在视图层布局完成后执行         1.6.3\nmoved      无              在组件实例被移动到节点树另一个位置时执行   1.6.3\ndetached   无              在组件实例被从页面节点树移除时执行      1.6.3\nerror      object error   每当组件方法抛出错误时执行          2.4.1\n\n\n# 组件所在页面的生命周期\n\n还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pagelifetimes 定义段中定义。其中可用的生命周期包括：\n\n生命周期     参数            描述               最低版本\nshow     无             组件所在的页面被展示时执行    2.2.3\nhide     无             组件所在的页面被隐藏时执行    2.2.3\nresize   object size   组件所在的页面尺寸变化时执行   2.4.0\n\n代码示例：\n\ncomponent({\n  pagelifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n",charsets:{cjk:!0}},{title:"数据监听",frontmatter:{},regularPath:"/mp/component-programming/data-observer.html",relativePath:"mp/component-programming/data-observer.md",key:"v-24743de0",path:"/mp/component-programming/data-observer.html",headers:[{level:2,title:"使用数据监听器",slug:"使用数据监听器",normalizedTitle:"使用数据监听器",charIndex:60},{level:2,title:"监听字段语法",slug:"监听字段语法",normalizedTitle:"监听字段语法",charIndex:494},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1649}],headersStr:"使用数据监听器 监听字段语法 注意事项",content:"# 数据监听\n\n数据监听可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。\n\n\n# 使用数据监听器\n\n有时，在一些数据字段被 setData 设置时，需要执行一些操作。\n\n例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。\n\nComponent({\n  attached: function() {\n    this.setData({\n      numberA: 1,\n      numberB: 2,\n    })\n  },\n  observers: {\n    'numberA, numberB': function(numberA, numberB) {\n      // 在 numberA 或者 numberB 被设置时，执行这个函数\n      this.setData({\n        sum: numberA + numberB\n      })\n    }\n  }\n})\n\n\n在开发者工具中预览效果\n\n\n# 监听字段语法\n\n数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。\n\n同时，监听器可以监听子数据字段，如下例所示。\n\nComponent({\n  observers: {\n    'some.subfield': function(subfield) {\n      // 使用 setData 设置 this.data.some.subfield 时触发\n      // （除此以外，使用 setData 设置 this.data.some 也会触发）\n      subfield === this.data.some.subfield\n    },\n    'arr[12]': function(arr12) {\n      // 使用 setData 设置 this.data.arr[12] 时触发\n      // （除此以外，使用 setData 设置 this.data.arr 也会触发）\n      arr12 === this.data.arr[12]\n    },\n  }\n})\n\n\n如果需要监听所有子数据字段的变化，可以使用通配符 ** 。\n\nComponent({\n  observers: {\n    'some.field.**': function(field) {\n      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发\n      // （除此以外，使用 setData 设置 this.data.some 也会触发）\n      field === this.data.some.field\n    },\n  },\n  attached: function() {\n    // 这样会触发上面的 observer\n    this.setData({\n      'some.field': { /* ... */ }\n    })\n    // 这样也会触发上面的 observer\n    this.setData({\n      'some.field.xxx': { /* ... */ }\n    })\n    // 这样还是会触发上面的 observer\n    this.setData({\n      'some': { /* ... */ }\n    })\n  }\n})\n\n\n特别地，仅使用通配符 ** 可以监听全部 setData 。\n\nComponent({\n  observers: {\n    '**': function() {\n      // 每次 setData 都触发\n    },\n  },\n})\n\n\n\n# 注意事项\n\n * 数据监听器监听的是 setData 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。\n * 如果在数据监听器函数中使用 setData 设置本身监听的数据字段，可能会导致死循环，需要特别留意。\n * 数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。",normalizedContent:"# 数据监听\n\n数据监听可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。\n\n\n# 使用数据监听器\n\n有时，在一些数据字段被 setdata 设置时，需要执行一些操作。\n\n例如， this.data.sum 永远是 this.data.numbera 与 this.data.numberb 的和。此时，可以使用数据监听器进行如下实现。\n\ncomponent({\n  attached: function() {\n    this.setdata({\n      numbera: 1,\n      numberb: 2,\n    })\n  },\n  observers: {\n    'numbera, numberb': function(numbera, numberb) {\n      // 在 numbera 或者 numberb 被设置时，执行这个函数\n      this.setdata({\n        sum: numbera + numberb\n      })\n    }\n  }\n})\n\n\n在开发者工具中预览效果\n\n\n# 监听字段语法\n\n数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setdata 最多触发每个监听器一次。\n\n同时，监听器可以监听子数据字段，如下例所示。\n\ncomponent({\n  observers: {\n    'some.subfield': function(subfield) {\n      // 使用 setdata 设置 this.data.some.subfield 时触发\n      // （除此以外，使用 setdata 设置 this.data.some 也会触发）\n      subfield === this.data.some.subfield\n    },\n    'arr[12]': function(arr12) {\n      // 使用 setdata 设置 this.data.arr[12] 时触发\n      // （除此以外，使用 setdata 设置 this.data.arr 也会触发）\n      arr12 === this.data.arr[12]\n    },\n  }\n})\n\n\n如果需要监听所有子数据字段的变化，可以使用通配符 ** 。\n\ncomponent({\n  observers: {\n    'some.field.**': function(field) {\n      // 使用 setdata 设置 this.data.some.field 本身或其下任何子数据字段时触发\n      // （除此以外，使用 setdata 设置 this.data.some 也会触发）\n      field === this.data.some.field\n    },\n  },\n  attached: function() {\n    // 这样会触发上面的 observer\n    this.setdata({\n      'some.field': { /* ... */ }\n    })\n    // 这样也会触发上面的 observer\n    this.setdata({\n      'some.field.xxx': { /* ... */ }\n    })\n    // 这样还是会触发上面的 observer\n    this.setdata({\n      'some': { /* ... */ }\n    })\n  }\n})\n\n\n特别地，仅使用通配符 ** 可以监听全部 setdata 。\n\ncomponent({\n  observers: {\n    '**': function() {\n      // 每次 setdata 都触发\n    },\n  },\n})\n\n\n\n# 注意事项\n\n * 数据监听器监听的是 setdata 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。\n * 如果在数据监听器函数中使用 setdata 设置本身监听的数据字段，可能会导致死循环，需要特别留意。\n * 数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。",charsets:{cjk:!0}},{title:"共享代码 (Behavior)",frontmatter:{},regularPath:"/mp/component-programming/mixins.html",relativePath:"mp/component-programming/mixins.md",key:"v-5d72327c",path:"/mp/component-programming/mixins.html",headers:[{level:2,title:"组件中使用",slug:"组件中使用",normalizedTitle:"组件中使用",charIndex:238},{level:2,title:"同名字段的覆盖和组合规则",slug:"同名字段的覆盖和组合规则",normalizedTitle:"同名字段的覆盖和组合规则",charIndex:1348},{level:2,title:"内置 behaviors",slug:"内置-behaviors",normalizedTitle:"内置 behaviors",charIndex:2094},{level:3,title:"wx://form-field",slug:"wx-form-field",normalizedTitle:"wx://form-field",charIndex:2174},{level:3,title:"wx://form-field-group",slug:"wx-form-field-group",normalizedTitle:"wx://form-field-group",charIndex:2449},{level:3,title:"wx://form-field-button",slug:"wx-form-field-button",normalizedTitle:"wx://form-field-button",charIndex:2557},{level:3,title:"wx://component-export",slug:"wx-component-export",normalizedTitle:"wx://component-export",charIndex:2718}],headersStr:"组件中使用 同名字段的覆盖和组合规则 内置 behaviors wx://form-field wx://form-field-group wx://form-field-button wx://component-export",content:"# 共享代码 (Behavior)\n\nbehaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。\n\n每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。\n\n详细的参数含义和使用请参考 Behavior 参考文档。\n\n\n# 组件中使用\n\n组件引用时，在 behaviors 定义段中将它们逐个列出即可。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// my-component.js\nvar myBehavior = require('my-behavior')\nComponent({\n  behaviors: [myBehavior],\n  properties: {\n    myProperty: {\n      type: String\n    }\n  },\n  data: {\n    myData: 'my-component-data'\n  },\n  created: function () {\n    console.log('[my-component] created')\n  },\n  attached: function () { \n    console.log('[my-component] attached')\n  },\n  ready: function () {\n    console.log('[my-component] ready')\n  },\n  methods: {\n    myMethod: function () {\n      console.log('[my-component] log by myMethod')\n    },\n  }\n})\n\n\n在上例中， my-component 组件定义中加入了 my-behavior，\n\n而 my-behavior 结构为：\n\n * 属性：myBehaviorProperty\n * 数据字段：myBehaviorData\n * 方法：myBehaviorMethod\n * 生命周期函数：attached、created、ready\n\n这将使 my-component 最终结构为：\n\n * 属性：myBehaviorProperty、myProperty\n * 数据字段：myBehaviorData、myData\n * 方法：myBehaviorMethod、myMethod\n * 生命周期函数：attached、created、ready\n\n当组件触发生命周期时，上例生命周期函数执行顺序为：\n\n 1. [my-behavior] created\n 2. [my-component] created\n 3. [my-behavior] attached\n 4. [my-component] attached\n 5. [my-behavior] ready\n 6. [my-component] ready\n\n详细规则参考 同名字段的覆盖和组合规则。\n\n\n# 同名字段的覆盖和组合规则\n\n组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：\n\n * 如果有同名的属性 (properties) 或方法 (methods)：\n   1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；\n   2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；\n   3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。\n * 如果有同名的数据字段 (data)：\n   * 若同名的数据字段都是对象类型，会进行对象合并；\n   * 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）\n * 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：\n   * 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；\n   * 对于同种生命周期函数，遵循如下规则：\n     * behavior 优先于组件执行；\n     * 子 behavior 优先于 父 behavior 执行；\n     * 靠前的 behavior 优先于 靠后的 behavior 执行；\n   * 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\n# 内置 behaviors\n\n自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为。\n\nComponent({\n  behaviors: ['wx://form-field']\n})\n\n\n在上例中， wx://form-field 代表一个内置 behavior ，它使得这个自定义组件有类似于表单控件的行为。\n\n内置 behavior 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 type 或添加 observer 。\n\n\n# wx://form-field\n\n使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://form-field-group\n\n从基础库版本 2.10.2 开始提供支持。\n\n使 form 组件可以识别到这个自定义组件内部的所有表单控件。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://form-field-button\n\n从基础库版本 2.10.3 开始提供支持。\n\n使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form 接受。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://component-export\n\n从基础库版本 2.2.3 开始提供支持。\n\n使自定义组件支持 export 定义段。这个定义段可以用于指定组件被 selectComponent 调用时的返回值。\n\n详细用法以及代码示例可见：selectComponent 参考文档",normalizedContent:"# 共享代码 (behavior)\n\nbehaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。\n\n每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。\n\n详细的参数含义和使用请参考 behavior 参考文档。\n\n\n# 组件中使用\n\n组件引用时，在 behaviors 定义段中将它们逐个列出即可。\n\n代码示例：\n\n在开发者工具中预览效果\n\n// my-component.js\nvar mybehavior = require('my-behavior')\ncomponent({\n  behaviors: [mybehavior],\n  properties: {\n    myproperty: {\n      type: string\n    }\n  },\n  data: {\n    mydata: 'my-component-data'\n  },\n  created: function () {\n    console.log('[my-component] created')\n  },\n  attached: function () { \n    console.log('[my-component] attached')\n  },\n  ready: function () {\n    console.log('[my-component] ready')\n  },\n  methods: {\n    mymethod: function () {\n      console.log('[my-component] log by mymethod')\n    },\n  }\n})\n\n\n在上例中， my-component 组件定义中加入了 my-behavior，\n\n而 my-behavior 结构为：\n\n * 属性：mybehaviorproperty\n * 数据字段：mybehaviordata\n * 方法：mybehaviormethod\n * 生命周期函数：attached、created、ready\n\n这将使 my-component 最终结构为：\n\n * 属性：mybehaviorproperty、myproperty\n * 数据字段：mybehaviordata、mydata\n * 方法：mybehaviormethod、mymethod\n * 生命周期函数：attached、created、ready\n\n当组件触发生命周期时，上例生命周期函数执行顺序为：\n\n 1. [my-behavior] created\n 2. [my-component] created\n 3. [my-behavior] attached\n 4. [my-component] attached\n 5. [my-behavior] ready\n 6. [my-component] ready\n\n详细规则参考 同名字段的覆盖和组合规则。\n\n\n# 同名字段的覆盖和组合规则\n\n组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：\n\n * 如果有同名的属性 (properties) 或方法 (methods)：\n   1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；\n   2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；\n   3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。\n * 如果有同名的数据字段 (data)：\n   * 若同名的数据字段都是对象类型，会进行对象合并；\n   * 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）\n * 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：\n   * 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；\n   * 对于同种生命周期函数，遵循如下规则：\n     * behavior 优先于组件执行；\n     * 子 behavior 优先于 父 behavior 执行；\n     * 靠前的 behavior 优先于 靠后的 behavior 执行；\n   * 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\n# 内置 behaviors\n\n自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为。\n\ncomponent({\n  behaviors: ['wx://form-field']\n})\n\n\n在上例中， wx://form-field 代表一个内置 behavior ，它使得这个自定义组件有类似于表单控件的行为。\n\n内置 behavior 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 type 或添加 observer 。\n\n\n# wx://form-field\n\n使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://form-field-group\n\n从基础库版本 2.10.2 开始提供支持。\n\n使 form 组件可以识别到这个自定义组件内部的所有表单控件。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://form-field-button\n\n从基础库版本 2.10.3 开始提供支持。\n\n使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form 接受。\n\n详细用法以及代码示例可见：form 组件参考文档\n\n\n# wx://component-export\n\n从基础库版本 2.2.3 开始提供支持。\n\n使自定义组件支持 export 定义段。这个定义段可以用于指定组件被 selectcomponent 调用时的返回值。\n\n详细用法以及代码示例可见：selectcomponent 参考文档",charsets:{cjk:!0}},{title:"关联组件",frontmatter:{},regularPath:"/mp/component-programming/relations-component.html",relativePath:"mp/component-programming/relations-component.md",key:"v-039d0484",path:"/mp/component-programming/relations-component.html",headers:[{level:2,title:"定义和使用关联组件",slug:"定义和使用关联组件",normalizedTitle:"定义和使用关联组件",charIndex:11},{level:2,title:"关联一类组件",slug:"关联一类组件",normalizedTitle:"关联一类组件",charIndex:1402},{level:2,title:"relations 定义段",slug:"relations-定义段",normalizedTitle:"relations 定义段",charIndex:202}],headersStr:"定义和使用关联组件 关联一类组件 relations 定义段",content:"# 关联组件\n\n\n# 定义和使用关联组件\n\n有时需要实现这样的组件：\n\n<custom-ul>\n  <custom-li> item 1 </custom-li>\n  <custom-li> item 2 </custom-li>\n</custom-ul>\n\n\n这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 relations 定义段，可以解决这样的问题。示例：\n\n在开发者工具中预览效果\n\n// path/to/custom-ul.js\nComponent({\n  relations: {\n    './custom-li': {\n      type: 'child', // 关联的目标节点应为子节点\n      linked: function(target) {\n        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\n      },\n      linkChanged: function(target) {\n        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\n      },\n      unlinked: function(target) {\n        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\n      }\n    }\n  },\n  methods: {\n    _getAllLi: function(){\n      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的\n      var nodes = this.getRelationNodes('path/to/custom-li')\n    }\n  },\n  ready: function(){\n    this._getAllLi()\n  }\n})\n// path/to/custom-li.js\nComponent({\n  relations: {\n    './custom-ul': {\n      type: 'parent', // 关联的目标节点应为父节点\n      linked: function(target) {\n        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\n      },\n      linkChanged: function(target) {\n        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\n      },\n      unlinked: function(target) {\n        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\n      }\n    }\n  }\n})\n\n\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。\n\n\n# 关联一类组件\n\n在开发者工具中预览效果\n\n有时，需要关联的是一类组件，如：\n\n<custom-form>\n  <view>\n    input\n    <custom-input></custom-input>\n  </view>\n  <custom-submit> submit </custom-submit>\n</custom-form>\n\n\ncustom-form 组件想要关联 custom-input 和 custom-submit 两个组件。此时，如果这两个组件都有同一个behavior：\n\n// path/to/custom-form-controls.js\nmodule.exports = Behavior({\n  // ...\n})\n// path/to/custom-input.js\nvar customFormControls = require('./custom-form-controls')\nComponent({\n  behaviors: [customFormControls],\n  relations: {\n    './custom-form': {\n      type: 'ancestor', // 关联的目标节点应为祖先节点\n    }\n  }\n})\n// path/to/custom-submit.js\nvar customFormControls = require('./custom-form-controls')\nComponent({\n  behaviors: [customFormControls],\n  relations: {\n    './custom-form': {\n      type: 'ancestor', // 关联的目标节点应为祖先节点\n    }\n  }\n})\n\n\n则在 relations 关系定义中，可使用这个behavior来代替组件路径作为关联的目标节点：\n\n// path/to/custom-form.js\nvar customFormControls = require('./custom-form-controls')\nComponent({\n  relations: {\n    'customFormControls': {\n      type: 'descendant', // 关联的目标节点应为子孙节点\n      target: customFormControls\n    }\n  }\n})\n\n\n\n# relations 定义段\n\nrelations 定义段包含目标组件路径及其对应选项，可包含的选项见下表。\n\n选项            类型         是否必填   描述\ntype          String     是      目标组件的相对关系，可选的值为 parent 、 child 、 ancestor 、 descendant\nlinked        Function   否      关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后\nlinkChanged   Function   否      关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后\nunlinked      Function   否      关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后\ntarget        String     否      如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联",normalizedContent:"# 关联组件\n\n\n# 定义和使用关联组件\n\n有时需要实现这样的组件：\n\n<custom-ul>\n  <custom-li> item 1 </custom-li>\n  <custom-li> item 2 </custom-li>\n</custom-ul>\n\n\n这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 relations 定义段，可以解决这样的问题。示例：\n\n在开发者工具中预览效果\n\n// path/to/custom-ul.js\ncomponent({\n  relations: {\n    './custom-li': {\n      type: 'child', // 关联的目标节点应为子节点\n      linked: function(target) {\n        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\n      },\n      linkchanged: function(target) {\n        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后\n      },\n      unlinked: function(target) {\n        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后\n      }\n    }\n  },\n  methods: {\n    _getallli: function(){\n      // 使用getrelationnodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的\n      var nodes = this.getrelationnodes('path/to/custom-li')\n    }\n  },\n  ready: function(){\n    this._getallli()\n  }\n})\n// path/to/custom-li.js\ncomponent({\n  relations: {\n    './custom-ul': {\n      type: 'parent', // 关联的目标节点应为父节点\n      linked: function(target) {\n        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后\n      },\n      linkchanged: function(target) {\n        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后\n      },\n      unlinked: function(target) {\n        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后\n      }\n    }\n  }\n})\n\n\n注意：必须在两个组件定义中都加入relations定义，否则不会生效。\n\n\n# 关联一类组件\n\n在开发者工具中预览效果\n\n有时，需要关联的是一类组件，如：\n\n<custom-form>\n  <view>\n    input\n    <custom-input></custom-input>\n  </view>\n  <custom-submit> submit </custom-submit>\n</custom-form>\n\n\ncustom-form 组件想要关联 custom-input 和 custom-submit 两个组件。此时，如果这两个组件都有同一个behavior：\n\n// path/to/custom-form-controls.js\nmodule.exports = behavior({\n  // ...\n})\n// path/to/custom-input.js\nvar customformcontrols = require('./custom-form-controls')\ncomponent({\n  behaviors: [customformcontrols],\n  relations: {\n    './custom-form': {\n      type: 'ancestor', // 关联的目标节点应为祖先节点\n    }\n  }\n})\n// path/to/custom-submit.js\nvar customformcontrols = require('./custom-form-controls')\ncomponent({\n  behaviors: [customformcontrols],\n  relations: {\n    './custom-form': {\n      type: 'ancestor', // 关联的目标节点应为祖先节点\n    }\n  }\n})\n\n\n则在 relations 关系定义中，可使用这个behavior来代替组件路径作为关联的目标节点：\n\n// path/to/custom-form.js\nvar customformcontrols = require('./custom-form-controls')\ncomponent({\n  relations: {\n    'customformcontrols': {\n      type: 'descendant', // 关联的目标节点应为子孙节点\n      target: customformcontrols\n    }\n  }\n})\n\n\n\n# relations 定义段\n\nrelations 定义段包含目标组件路径及其对应选项，可包含的选项见下表。\n\n选项            类型         是否必填   描述\ntype          string     是      目标组件的相对关系，可选的值为 parent 、 child 、 ancestor 、 descendant\nlinked        function   否      关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后\nlinkchanged   function   否      关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后\nunlinked      function   否      关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后\ntarget        string     否      如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联",charsets:{cjk:!0}},{title:"概览",frontmatter:{},regularPath:"/mp/component-programming/summary.html",relativePath:"mp/component-programming/summary.md",key:"v-3ed32d46",path:"/mp/component-programming/summary.html",headers:[{level:2,title:"创建自定义组件",slug:"创建自定义组件",normalizedTitle:"创建自定义组件",charIndex:161},{level:2,title:"使用自定义组件",slug:"使用自定义组件",normalizedTitle:"使用自定义组件",charIndex:970},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:369}],headersStr:"创建自定义组件 使用自定义组件 注意事项",content:'# 概览\n\n从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。\n\n开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。\n\n\n# 创建自定义组件\n\n类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）：\n\n{\n  "component": true\n}\n\n\n同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 组件模板和样式 。\n\n代码示例：\n\n\x3c!-- 这是自定义组件的内部WXML结构 --\x3e\n<view class="inner">\n  {{innerText}}\n</view>\n<slot></slot>\n/* 这里的样式只应用于这个自定义组件 */\n.inner {\n  color: red;\n}\n\n\n注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。\n\n在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。\n\n组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 Component构造器 。\n\n代码示例：\n\nComponent({\n  properties: {\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\n    innerText: {\n      type: String,\n      value: \'default value\',\n    }\n  },\n  data: {\n    // 这里是一些组件内部数据\n    someData: {}\n  },\n  methods: {\n    // 这里是一个自定义方法\n    customMethod: function(){}\n  }\n})\n\n\n\n# 使用自定义组件\n\n使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：\n\n{\n  "usingComponents": {\n    "component-tag-name": "path/to/the/custom/component"\n  }\n}\n\n\n这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。\n\n> 开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。\n\n代码示例：\n\n在开发者工具中预览效果\n\n<view>\n  \x3c!-- 以下是对一个自定义组件的引用 --\x3e\n  <component-tag-name inner-text="Some text"></component-tag-name>\n</view>\n\n\n自定义组件的 wxml 节点结构在与数据结合之后，将被插入到引用位置内。\n\n\n# 注意事项\n\n一些需要注意的细节：\n\n * 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。\n * 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。\n * 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。\n\n注意，是否在页面文件中使用 usingComponents 会使得页面的 this 对象的原型稍有差异，包括：\n\n * 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。\n * 使用 usingComponents 时会多一些方法，如 selectComponent 。\n * 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）\n\n如果页面比较复杂，新增或删除 usingComponents 定义段时建议重新测试一下。',normalizedContent:'# 概览\n\n从小程序基础库版本 1.6.3 开始，小程序支持简洁的组件化编程。所有自定义组件相关特性都需要基础库版本 1.6.3 或更高。\n\n开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。\n\n\n# 创建自定义组件\n\n类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）：\n\n{\n  "component": true\n}\n\n\n同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 组件模板和样式 。\n\n代码示例：\n\n\x3c!-- 这是自定义组件的内部wxml结构 --\x3e\n<view class="inner">\n  {{innertext}}\n</view>\n<slot></slot>\n/* 这里的样式只应用于这个自定义组件 */\n.inner {\n  color: red;\n}\n\n\n注意：在组件wxss中不应使用id选择器、属性选择器和标签名选择器。\n\n在自定义组件的 js 文件中，需要使用 component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。\n\n组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 component构造器 。\n\n代码示例：\n\ncomponent({\n  properties: {\n    // 这里定义了innertext属性，属性值可以在组件使用时指定\n    innertext: {\n      type: string,\n      value: \'default value\',\n    }\n  },\n  data: {\n    // 这里是一些组件内部数据\n    somedata: {}\n  },\n  methods: {\n    // 这里是一个自定义方法\n    custommethod: function(){}\n  }\n})\n\n\n\n# 使用自定义组件\n\n使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：\n\n{\n  "usingcomponents": {\n    "component-tag-name": "path/to/the/custom/component"\n  }\n}\n\n\n这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。\n\n> 开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明 usingcomponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。\n\n代码示例：\n\n在开发者工具中预览效果\n\n<view>\n  \x3c!-- 以下是对一个自定义组件的引用 --\x3e\n  <component-tag-name inner-text="some text"></component-tag-name>\n</view>\n\n\n自定义组件的 wxml 节点结构在与数据结合之后，将被插入到引用位置内。\n\n\n# 注意事项\n\n一些需要注意的细节：\n\n * 因为 wxml 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。\n * 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingcomponents 字段）。\n * 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。\n\n注意，是否在页面文件中使用 usingcomponents 会使得页面的 this 对象的原型稍有差异，包括：\n\n * 使用 usingcomponents 页面的原型与不使用时不一致，即 object.getprototypeof(this) 结果不同。\n * 使用 usingcomponents 时会多一些方法，如 selectcomponent 。\n * 出于性能考虑，使用 usingcomponents 时， setdata 内容不会被直接深复制，即 this.setdata({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）\n\n如果页面比较复杂，新增或删除 usingcomponents 定义段时建议重新测试一下。',charsets:{cjk:!0}},{title:"条件渲染",frontmatter:{},regularPath:"/mp/get-started/conditional-render.html",relativePath:"mp/get-started/conditional-render.md",key:"v-60270942",path:"/mp/get-started/conditional-render.html",headers:[{level:2,title:"wx:if",slug:"wx-if",normalizedTitle:"wx:if",charIndex:11},{level:2,title:"block wx:if",slug:"block-wx-if",normalizedTitle:"block wx:if",charIndex:245},{level:2,title:"wx:if vs hidden",slug:"wx-if-vs-hidden",normalizedTitle:"wx:if vs hidden",charIndex:490}],headersStr:"wx:if block wx:if wx:if vs hidden",content:'# 条件渲染\n\n\n# wx:if\n\n在框架中，使用 wx:if="" 来判断是否需要渲染该代码块：\n\n<view wx:if="{{condition}}"> True </view>\n\n\n也可以用 wx:elif 和 wx:else 来添加一个 else 块：\n\n<view wx:if="{{length > 5}}"> 1 </view>\n<view wx:elif="{{length > 2}}"> 2 </view>\n<view wx:else> 3 </view>\n\n\n\n# block wx:if\n\n因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <block/> 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。\n\n<block wx:if="{{true}}">\n  <view> view1 </view>\n  <view> view2 </view>\n</block>\n\n\n注意： <block/> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。\n\n\n# wx:if vs hidden\n\n因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。\n\n同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。\n\n相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。\n\n一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。',normalizedContent:'# 条件渲染\n\n\n# wx:if\n\n在框架中，使用 wx:if="" 来判断是否需要渲染该代码块：\n\n<view wx:if="{{condition}}"> true </view>\n\n\n也可以用 wx:elif 和 wx:else 来添加一个 else 块：\n\n<view wx:if="{{length > 5}}"> 1 </view>\n<view wx:elif="{{length > 2}}"> 2 </view>\n<view wx:else> 3 </view>\n\n\n\n# block wx:if\n\n因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <block/> 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。\n\n<block wx:if="{{true}}">\n  <view> view1 </view>\n  <view> view2 </view>\n</block>\n\n\n注意： <block/> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。\n\n\n# wx:if vs hidden\n\n因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。\n\n同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。\n\n相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。\n\n一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。',charsets:{cjk:!0}},{title:"数据绑定与 WXML 模板",frontmatter:{},regularPath:"/mp/get-started/data-binding.html",relativePath:"mp/get-started/data-binding.md",key:"v-c33c2b3c",path:"/mp/get-started/data-binding.html",headers:[{level:2,title:"简单绑定",slug:"简单绑定",normalizedTitle:"简单绑定",charIndex:51},{level:3,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:99},{level:3,title:"组件属性(需要在双引号之内)",slug:"组件属性-需要在双引号之内",normalizedTitle:"组件属性(需要在双引号之内)",charIndex:188},{level:3,title:"控制属性(需要在双引号之内)",slug:"控制属性-需要在双引号之内",normalizedTitle:"控制属性(需要在双引号之内)",charIndex:275},{level:3,title:"关键字(需要在双引号之内)",slug:"关键字-需要在双引号之内",normalizedTitle:"关键字(需要在双引号之内)",charIndex:377},{level:2,title:"运算",slug:"运算",normalizedTitle:"运算",charIndex:561},{level:3,title:"三元运算",slug:"三元运算",normalizedTitle:"三元运算",charIndex:599},{level:3,title:"算数运算",slug:"算数运算",normalizedTitle:"算数运算",charIndex:665},{level:3,title:"逻辑判断",slug:"逻辑判断",normalizedTitle:"逻辑判断",charIndex:788},{level:3,title:"字符串运算",slug:"字符串运算",normalizedTitle:"字符串运算",charIndex:837},{level:3,title:"数据路径运算",slug:"数据路径运算",normalizedTitle:"数据路径运算",charIndex:921},{level:2,title:"组合",slug:"组合",normalizedTitle:"组合",charIndex:1060},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:1094},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:1090}],headersStr:"简单绑定 内容 组件属性(需要在双引号之内) 控制属性(需要在双引号之内) 关键字(需要在双引号之内) 运算 三元运算 算数运算 逻辑判断 字符串运算 数据路径运算 组合 数组 对象",content:'# 数据绑定与 WXML 模板\n\nWXML 中的动态数据均来自对应 Page 的 data。\n\n\n# 简单绑定\n\n数据绑定使用 Mustache 语法（双大括号）将变量包起来，可以作用于：\n\n\n# 内容\n\n<view> {{ message }} </view>\nPage({\n  data: {\n    message: \'Hello MINA!\'\n  }\n})\n\n\n\n# 组件属性(需要在双引号之内)\n\n<view id="item-{{id}}"> </view>\nPage({\n  data: {\n    id: 0\n  }\n})\n\n\n\n# 控制属性(需要在双引号之内)\n\n<view wx:if="{{condition}}"> </view>\nPage({\n  data: {\n    condition: true\n  }\n})\n\n\n\n# 关键字(需要在双引号之内)\n\ntrue：boolean 类型的 true，代表真值。\n\nfalse： boolean 类型的 false，代表假值。\n\n<checkbox checked="{{false}}"> </checkbox>\n\n\n特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。\n\n\n# 运算\n\n可以在 {{}} 内进行简单的运算，支持的有如下几种方式：\n\n\n# 三元运算\n\n<view hidden="{{flag ? true : false}}"> Hidden </view>\n\n\n\n# 算数运算\n\n<view> {{a + b}} + {{c}} + d </view>\nPage({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3\n  }\n})\n\n\nview中的内容为 3 + 3 + d。\n\n\n# 逻辑判断\n\n<view wx:if="{{length > 5}}"> </view>\n\n\n\n# 字符串运算\n\n<view>{{"hello" + name}}</view>\nPage({\n  data:{\n    name: \'MINA\'\n  }\n})\n\n\n\n# 数据路径运算\n\n<view>{{object.key}} {{array[0]}}</view>\nPage({\n  data: {\n    object: {\n      key: \'Hello \'\n    },\n    array: [\'MINA\']\n  }\n})\n\n\n\n# 组合\n\n也可以在 Mustache 内直接进行组合，构成新的对象或者数组。\n\n\n# 数组\n\n<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>\nPage({\n  data: {\n    zero: 0\n  }\n})\n\n\n最终组合成数组[0, 1, 2, 3, 4]。\n\n\n# 对象\n\n<template is="objectCombine" data="{{for: a, bar: b}}"></template>\nPage({\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n最终组合成的对象是 {for: 1, bar: 2}\n\n也可以用扩展运算符 ... 来将一个对象展开\n\n<template is="objectCombine" data="{{...obj1, ...obj2, e: 5}}"></template>\nPage({\n  data: {\n    obj1: {\n      a: 1,\n      b: 2\n    },\n    obj2: {\n      c: 3,\n      d: 4\n    }\n  }\n})\n\n\n最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}。\n\n如果对象的 key 和 value 相同，也可以间接地表达。\n\n<template is="objectCombine" data="{{foo, bar}}"></template>\nPage({\n  data: {\n    foo: \'my-foo\',\n    bar: \'my-bar\'\n  }\n})\n\n\n最终组合成的对象是 {foo: \'my-foo\', bar:\'my-bar\'}。\n\n注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：\n\n<template is="objectCombine" data="{{...obj1, ...obj2, a, c: 6}}"></template>\nPage({\n  data: {\n    obj1: {\n      a: 1,\n      b: 2\n    },\n    obj2: {\n      b: 3,\n      c: 4\n    },\n    a: 5\n  }\n})\n\n\n最终组合成的对象是 {a: 5, b: 3, c: 6}。\n\n注意： 花括号和引号之间如果有空格，将最终被解析成为字符串\n\n<view wx:for="{{[1,2,3]}} ">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[1,2,3] + \' \'}}">\n  {{item}}\n</view>\n',normalizedContent:'# 数据绑定与 wxml 模板\n\nwxml 中的动态数据均来自对应 page 的 data。\n\n\n# 简单绑定\n\n数据绑定使用 mustache 语法（双大括号）将变量包起来，可以作用于：\n\n\n# 内容\n\n<view> {{ message }} </view>\npage({\n  data: {\n    message: \'hello mina!\'\n  }\n})\n\n\n\n# 组件属性(需要在双引号之内)\n\n<view id="item-{{id}}"> </view>\npage({\n  data: {\n    id: 0\n  }\n})\n\n\n\n# 控制属性(需要在双引号之内)\n\n<view wx:if="{{condition}}"> </view>\npage({\n  data: {\n    condition: true\n  }\n})\n\n\n\n# 关键字(需要在双引号之内)\n\ntrue：boolean 类型的 true，代表真值。\n\nfalse： boolean 类型的 false，代表假值。\n\n<checkbox checked="{{false}}"> </checkbox>\n\n\n特别注意：不要直接写 checked="false"，其计算结果是一个字符串，转成 boolean 类型后代表真值。\n\n\n# 运算\n\n可以在 {{}} 内进行简单的运算，支持的有如下几种方式：\n\n\n# 三元运算\n\n<view hidden="{{flag ? true : false}}"> hidden </view>\n\n\n\n# 算数运算\n\n<view> {{a + b}} + {{c}} + d </view>\npage({\n  data: {\n    a: 1,\n    b: 2,\n    c: 3\n  }\n})\n\n\nview中的内容为 3 + 3 + d。\n\n\n# 逻辑判断\n\n<view wx:if="{{length > 5}}"> </view>\n\n\n\n# 字符串运算\n\n<view>{{"hello" + name}}</view>\npage({\n  data:{\n    name: \'mina\'\n  }\n})\n\n\n\n# 数据路径运算\n\n<view>{{object.key}} {{array[0]}}</view>\npage({\n  data: {\n    object: {\n      key: \'hello \'\n    },\n    array: [\'mina\']\n  }\n})\n\n\n\n# 组合\n\n也可以在 mustache 内直接进行组合，构成新的对象或者数组。\n\n\n# 数组\n\n<view wx:for="{{[zero, 1, 2, 3, 4]}}"> {{item}} </view>\npage({\n  data: {\n    zero: 0\n  }\n})\n\n\n最终组合成数组[0, 1, 2, 3, 4]。\n\n\n# 对象\n\n<template is="objectcombine" data="{{for: a, bar: b}}"></template>\npage({\n  data: {\n    a: 1,\n    b: 2\n  }\n})\n\n\n最终组合成的对象是 {for: 1, bar: 2}\n\n也可以用扩展运算符 ... 来将一个对象展开\n\n<template is="objectcombine" data="{{...obj1, ...obj2, e: 5}}"></template>\npage({\n  data: {\n    obj1: {\n      a: 1,\n      b: 2\n    },\n    obj2: {\n      c: 3,\n      d: 4\n    }\n  }\n})\n\n\n最终组合成的对象是 {a: 1, b: 2, c: 3, d: 4, e: 5}。\n\n如果对象的 key 和 value 相同，也可以间接地表达。\n\n<template is="objectcombine" data="{{foo, bar}}"></template>\npage({\n  data: {\n    foo: \'my-foo\',\n    bar: \'my-bar\'\n  }\n})\n\n\n最终组合成的对象是 {foo: \'my-foo\', bar:\'my-bar\'}。\n\n注意：上述方式可以随意组合，但是如有存在变量名相同的情况，后边的会覆盖前面，如：\n\n<template is="objectcombine" data="{{...obj1, ...obj2, a, c: 6}}"></template>\npage({\n  data: {\n    obj1: {\n      a: 1,\n      b: 2\n    },\n    obj2: {\n      b: 3,\n      c: 4\n    },\n    a: 5\n  }\n})\n\n\n最终组合成的对象是 {a: 5, b: 3, c: 6}。\n\n注意： 花括号和引号之间如果有空格，将最终被解析成为字符串\n\n<view wx:for="{{[1,2,3]}} ">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[1,2,3] + \' \'}}">\n  {{item}}\n</view>\n',charsets:{cjk:!0}},{title:"开始",frontmatter:{},regularPath:"/mp/get-started/environment-config.html",relativePath:"mp/get-started/environment-config.md",key:"v-6fb951e2",path:"/mp/get-started/environment-config.html",headers:[{level:2,title:"申请帐号",slug:"申请帐号",normalizedTitle:"申请帐号",charIndex:72},{level:2,title:"安装开发工具",slug:"安装开发工具",normalizedTitle:"安装开发工具",charIndex:317},{level:2,title:"你的第一个小程序",slug:"你的第一个小程序",normalizedTitle:"你的第一个小程序",charIndex:420},{level:2,title:"编译预览",slug:"编译预览",normalizedTitle:"编译预览",charIndex:617}],headersStr:"申请帐号 安装开发工具 你的第一个小程序 编译预览",content:'# 开始\n\n开发小程序的第一步，你需要拥有一个小程序帐号，通过这个帐号你就可以管理你的小程序。\n\n跟随这个教程，开始你的小程序之旅吧！\n\n\n# 申请帐号\n\n进入小程序注册页 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。\n\n\n\n在这个小程序管理平台，你可以管理你的小程序的权限，查看数据报表，发布小程序等操作。\n\n登录 小程序后台 ，我们可以在菜单 “开发”-“开发设置” 看到小程序的 AppID 了 。\n\n\n\n小程序的 AppID 相当于小程序平台的一个身份证，后续你会在很多地方要用到 AppID （注意这里要区别于服务号或订阅号的 AppID）。\n\n有了小程序帐号之后，我们需要一个工具来开发小程序。\n\n\n# 安装开发工具\n\n前往 开发者工具下载页面 ，根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看 《开发者工具介绍》 。\n\n打开小程序开发者工具，用微信扫码登录开发者工具，准备开发你的第一个小程序吧！\n\n\n# 你的第一个小程序\n\n新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的 AppID，给你的项目起一个好听的名字，勾选 "不使用云服务" （注意: 你要选择一个空的目录才可以创建项目），点击新建，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在微信开发者工具中预览你的第一个小程序。\n\n\n\n接下来我们来预览一下这个小程序的效果。\n\n\n# 编译预览\n\n点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。\n\n\n\n通过这个章节，你已经成功创建了你的第一个小程序，并且在微信客户端上体验到它流畅的表现。\n\n下个章节，我们一起来看看这个小程序的代码构成。',normalizedContent:'# 开始\n\n开发小程序的第一步，你需要拥有一个小程序帐号，通过这个帐号你就可以管理你的小程序。\n\n跟随这个教程，开始你的小程序之旅吧！\n\n\n# 申请帐号\n\n进入小程序注册页 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。\n\n\n\n在这个小程序管理平台，你可以管理你的小程序的权限，查看数据报表，发布小程序等操作。\n\n登录 小程序后台 ，我们可以在菜单 “开发”-“开发设置” 看到小程序的 appid 了 。\n\n\n\n小程序的 appid 相当于小程序平台的一个身份证，后续你会在很多地方要用到 appid （注意这里要区别于服务号或订阅号的 appid）。\n\n有了小程序帐号之后，我们需要一个工具来开发小程序。\n\n\n# 安装开发工具\n\n前往 开发者工具下载页面 ，根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看 《开发者工具介绍》 。\n\n打开小程序开发者工具，用微信扫码登录开发者工具，准备开发你的第一个小程序吧！\n\n\n# 你的第一个小程序\n\n新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的 appid，给你的项目起一个好听的名字，勾选 "不使用云服务" （注意: 你要选择一个空的目录才可以创建项目），点击新建，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在微信开发者工具中预览你的第一个小程序。\n\n\n\n接下来我们来预览一下这个小程序的效果。\n\n\n# 编译预览\n\n点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。\n\n\n\n通过这个章节，你已经成功创建了你的第一个小程序，并且在微信客户端上体验到它流畅的表现。\n\n下个章节，我们一起来看看这个小程序的代码构成。',charsets:{cjk:!0}},{title:"表单处理与双向绑定",frontmatter:{},regularPath:"/mp/get-started/form-binding.html",relativePath:"mp/get-started/form-binding.md",key:"v-253bc5a2",path:"/mp/get-started/form-binding.html",headers:[{level:2,title:"双向绑定语法",slug:"双向绑定语法",normalizedTitle:"双向绑定语法",charIndex:45},{level:2,title:"在自定义组件中传递双向绑定",slug:"在自定义组件中传递双向绑定",normalizedTitle:"在自定义组件中传递双向绑定",charIndex:646},{level:2,title:"在自定义组件中触发双向绑定更新",slug:"在自定义组件中触发双向绑定更新",normalizedTitle:"在自定义组件中触发双向绑定更新",charIndex:1063}],headersStr:"双向绑定语法 在自定义组件中传递双向绑定 在自定义组件中触发双向绑定更新",content:'# 表单处理与双向绑定\n\n> 基础库 2.9.3 开始支持，低版本需做兼容处理。\n\n\n# 双向绑定语法\n\n在 WXML 中，普通的属性的绑定是单向的。例如：\n\n<input value="{{value}}" />\n\n\n如果使用 this.setData({ value: \'leaf\' }) 来更新 value ，this.data.value 和输入框的中显示的值都会被更新为 leaf ；但如果用户修改了输入框里的值，却不会同时改变 this.data.value 。\n\n如果需要在用户输入的同时改变 this.data.value ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 model: 前缀：\n\n<input model:value="{{value}}" />\n\n\n这样，如果输入框的值被改变了， this.data.value 也会同时改变。同时， WXML 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。\n\n在开发者工具中预览效果\n\n用于双向绑定的表达式有如下限制：\n\n 1. 只能是一个单一字段的绑定，如\n\n<input model:value="值为 {{value}}" />\n<input model:value="{{ a + b }}" />\n\n\n都是非法的；\n\n 1. 目前，尚不能 data 路径，如\n\n<input model:value="{{ a.b }}" />\n\n\n这样的表达式目前暂不支持。\n\n\n# 在自定义组件中传递双向绑定\n\n双向绑定同样可以使用在自定义组件上。如下的自定义组件：\n\n// custom-component.js\nComponent({\n  properties: {\n    myValue: String\n  }\n})\n\x3c!-- custom-component.wxml --\x3e\n<input model:value="{{myValue}}" />\n\n\n这个自定义组件将自身的 myValue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件：\n\n<custom-component model:my-value="{{pageValue}}" />\n\n\n当输入框的值变更时，自定义组件的 myValue 属性会同时变更，这样，页面的 this.data.pageValue 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。\n\n\n# 在自定义组件中触发双向绑定更新\n\n自定义组件还可以自己触发双向绑定更新，做法就是：使用 setData 设置自身的属性。例如：\n\n// custom-component.js\nComponent({\n  properties: {\n    myValue: String\n  },\n  methods: {\n    update: function() {\n      // 更新 myValue\n      this.setData({\n        myValue: \'leaf\'\n      })\n    }\n  }\n})\n\n\n如果页面这样使用这个组件：\n\n<custom-component model:my-value="{{pageValue}}" />\n\n\n当组件使用 setData 更新 myValue 时，页面的 this.data.pageValue 也会同时变更，页面 WXML 中所有绑定了 pageValue 的位置也会被一同更新。',normalizedContent:'# 表单处理与双向绑定\n\n> 基础库 2.9.3 开始支持，低版本需做兼容处理。\n\n\n# 双向绑定语法\n\n在 wxml 中，普通的属性的绑定是单向的。例如：\n\n<input value="{{value}}" />\n\n\n如果使用 this.setdata({ value: \'leaf\' }) 来更新 value ，this.data.value 和输入框的中显示的值都会被更新为 leaf ；但如果用户修改了输入框里的值，却不会同时改变 this.data.value 。\n\n如果需要在用户输入的同时改变 this.data.value ，需要借助简易双向绑定机制。此时，可以在对应项目之前加入 model: 前缀：\n\n<input model:value="{{value}}" />\n\n\n这样，如果输入框的值被改变了， this.data.value 也会同时改变。同时， wxml 中所有绑定了 value 的位置也会被一同更新， 数据监听器 也会被正常触发。\n\n在开发者工具中预览效果\n\n用于双向绑定的表达式有如下限制：\n\n 1. 只能是一个单一字段的绑定，如\n\n<input model:value="值为 {{value}}" />\n<input model:value="{{ a + b }}" />\n\n\n都是非法的；\n\n 1. 目前，尚不能 data 路径，如\n\n<input model:value="{{ a.b }}" />\n\n\n这样的表达式目前暂不支持。\n\n\n# 在自定义组件中传递双向绑定\n\n双向绑定同样可以使用在自定义组件上。如下的自定义组件：\n\n// custom-component.js\ncomponent({\n  properties: {\n    myvalue: string\n  }\n})\n\x3c!-- custom-component.wxml --\x3e\n<input model:value="{{myvalue}}" />\n\n\n这个自定义组件将自身的 myvalue 属性双向绑定到了组件内输入框的 value 属性上。这样，如果页面这样使用这个组件：\n\n<custom-component model:my-value="{{pagevalue}}" />\n\n\n当输入框的值变更时，自定义组件的 myvalue 属性会同时变更，这样，页面的 this.data.pagevalue 也会同时变更，页面 wxml 中所有绑定了 pagevalue 的位置也会被一同更新。\n\n\n# 在自定义组件中触发双向绑定更新\n\n自定义组件还可以自己触发双向绑定更新，做法就是：使用 setdata 设置自身的属性。例如：\n\n// custom-component.js\ncomponent({\n  properties: {\n    myvalue: string\n  },\n  methods: {\n    update: function() {\n      // 更新 myvalue\n      this.setdata({\n        myvalue: \'leaf\'\n      })\n    }\n  }\n})\n\n\n如果页面这样使用这个组件：\n\n<custom-component model:my-value="{{pagevalue}}" />\n\n\n当组件使用 setdata 更新 myvalue 时，页面的 this.data.pagevalue 也会同时变更，页面 wxml 中所有绑定了 pagevalue 的位置也会被一同更新。',charsets:{cjk:!0}},{title:"列表渲染",frontmatter:{},regularPath:"/mp/get-started/list-render.html",relativePath:"mp/get-started/list-render.md",key:"v-7cf74bf4",path:"/mp/get-started/list-render.html",headers:[{level:2,title:"wx:for",slug:"wx-for",normalizedTitle:"wx:for",charIndex:11},{level:2,title:"block wx:for",slug:"block-wx-for",normalizedTitle:"block wx:for",charIndex:699},{level:2,title:"wx:key",slug:"wx-key",normalizedTitle:"wx:key",charIndex:873},{level:2,title:"示例代码",slug:"示例代码",normalizedTitle:"示例代码",charIndex:1302},{level:2,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:2848}],headersStr:"wx:for block wx:for wx:key 示例代码 注意事项",content:'# 列表渲染\n\n\n# wx:for\n\n在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。\n\n默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item\n\n<view wx:for="{{array}}">\n  {{index}}: {{item.message}}\n</view>\nPage({\n  data: {\n    array: [{\n      message: \'foo\',\n    }, {\n      message: \'bar\'\n    }]\n  }\n})\n\n\n使用 wx:for-item 可以指定数组当前元素的变量名，\n\n使用 wx:for-index 可以指定数组当前下标的变量名：\n\n<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">\n  {{idx}}: {{itemName.message}}\n</view>\n\n\nwx:for 也可以嵌套，下边是一个九九乘法表\n\n<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">\n  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">\n    <view wx:if="{{i <= j}}">\n      {{i}} * {{j}} = {{i * j}}\n    </view>\n  </view>\n</view>\n\n\n\n# block wx:for\n\n类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：\n\n<block wx:for="{{[1, 2, 3]}}">\n  <view> {{index}}: </view>\n  <view> {{item}} </view>\n</block>\n\n\n\n# wx:key\n\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。\n\nwx:key 的值以两种形式提供\n\n 1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。\n 2. 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。\n\n当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。\n\n如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。\n\n\n# 示例代码\n\n在开发者工具中预览效果\n\n<switch wx:for="{{objectArray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>\n<button bindtap="switch"> Switch </button>\n<button bindtap="addToFront"> Add to the front </button>\n\n<switch wx:for="{{numberArray}}" wx:key="*this" style="display: block;"> {{item}} </switch>\n<button bindtap="addNumberToFront"> Add to the front </button>\nPage({\n  data: {\n    objectArray: [\n      {id: 5, unique: \'unique_5\'},\n      {id: 4, unique: \'unique_4\'},\n      {id: 3, unique: \'unique_3\'},\n      {id: 2, unique: \'unique_2\'},\n      {id: 1, unique: \'unique_1\'},\n      {id: 0, unique: \'unique_0\'},\n    ],\n    numberArray: [1, 2, 3, 4]\n  },\n  switch: function(e) {\n    const length = this.data.objectArray.length\n    for (let i = 0; i < length; ++i) {\n      const x = Math.floor(Math.random() * length)\n      const y = Math.floor(Math.random() * length)\n      const temp = this.data.objectArray[x]\n      this.data.objectArray[x] = this.data.objectArray[y]\n      this.data.objectArray[y] = temp\n    }\n    this.setData({\n      objectArray: this.data.objectArray\n    })\n  },\n  addToFront: function(e) {\n    const length = this.data.objectArray.length\n    this.data.objectArray = [{id: length, unique: \'unique_\' + length}].concat(this.data.objectArray)\n    this.setData({\n      objectArray: this.data.objectArray\n    })\n  },\n  addNumberToFront: function(e){\n    this.data.numberArray = [ this.data.numberArray.length + 1 ].concat(this.data.numberArray)\n    this.setData({\n      numberArray: this.data.numberArray\n    })\n  }\n})\n\n\n\n# 注意事项\n\n当 wx:for 的值为字符串时，会将字符串解析成字符串数组\n\n<view wx:for="array">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[\'a\',\'r\',\'r\',\'a\',\'y\']}}">\n  {{item}}\n</view>\n\n\n注意： 花括号和引号之间如果有空格，将最终被解析成为字符串\n\n<view wx:for="{{[1,2,3]}} ">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[1,2,3] + \' \'}}" >\n  {{item}}\n</view>\n',normalizedContent:'# 列表渲染\n\n\n# wx:for\n\n在组件上使用 wx:for 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。\n\n默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item\n\n<view wx:for="{{array}}">\n  {{index}}: {{item.message}}\n</view>\npage({\n  data: {\n    array: [{\n      message: \'foo\',\n    }, {\n      message: \'bar\'\n    }]\n  }\n})\n\n\n使用 wx:for-item 可以指定数组当前元素的变量名，\n\n使用 wx:for-index 可以指定数组当前下标的变量名：\n\n<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemname">\n  {{idx}}: {{itemname.message}}\n</view>\n\n\nwx:for 也可以嵌套，下边是一个九九乘法表\n\n<view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="i">\n  <view wx:for="{{[1, 2, 3, 4, 5, 6, 7, 8, 9]}}" wx:for-item="j">\n    <view wx:if="{{i <= j}}">\n      {{i}} * {{j}} = {{i * j}}\n    </view>\n  </view>\n</view>\n\n\n\n# block wx:for\n\n类似 block wx:if，也可以将 wx:for 用在<block/>标签上，以渲染一个包含多节点的结构块。例如：\n\n<block wx:for="{{[1, 2, 3]}}">\n  <view> {{index}}: </view>\n  <view> {{item}} </view>\n</block>\n\n\n\n# wx:key\n\n如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。\n\nwx:key 的值以两种形式提供\n\n 1. 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。\n 2. 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。\n\n当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。\n\n如不提供 wx:key，会报一个 warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。\n\n\n# 示例代码\n\n在开发者工具中预览效果\n\n<switch wx:for="{{objectarray}}" wx:key="unique" style="display: block;"> {{item.id}} </switch>\n<button bindtap="switch"> switch </button>\n<button bindtap="addtofront"> add to the front </button>\n\n<switch wx:for="{{numberarray}}" wx:key="*this" style="display: block;"> {{item}} </switch>\n<button bindtap="addnumbertofront"> add to the front </button>\npage({\n  data: {\n    objectarray: [\n      {id: 5, unique: \'unique_5\'},\n      {id: 4, unique: \'unique_4\'},\n      {id: 3, unique: \'unique_3\'},\n      {id: 2, unique: \'unique_2\'},\n      {id: 1, unique: \'unique_1\'},\n      {id: 0, unique: \'unique_0\'},\n    ],\n    numberarray: [1, 2, 3, 4]\n  },\n  switch: function(e) {\n    const length = this.data.objectarray.length\n    for (let i = 0; i < length; ++i) {\n      const x = math.floor(math.random() * length)\n      const y = math.floor(math.random() * length)\n      const temp = this.data.objectarray[x]\n      this.data.objectarray[x] = this.data.objectarray[y]\n      this.data.objectarray[y] = temp\n    }\n    this.setdata({\n      objectarray: this.data.objectarray\n    })\n  },\n  addtofront: function(e) {\n    const length = this.data.objectarray.length\n    this.data.objectarray = [{id: length, unique: \'unique_\' + length}].concat(this.data.objectarray)\n    this.setdata({\n      objectarray: this.data.objectarray\n    })\n  },\n  addnumbertofront: function(e){\n    this.data.numberarray = [ this.data.numberarray.length + 1 ].concat(this.data.numberarray)\n    this.setdata({\n      numberarray: this.data.numberarray\n    })\n  }\n})\n\n\n\n# 注意事项\n\n当 wx:for 的值为字符串时，会将字符串解析成字符串数组\n\n<view wx:for="array">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[\'a\',\'r\',\'r\',\'a\',\'y\']}}">\n  {{item}}\n</view>\n\n\n注意： 花括号和引号之间如果有空格，将最终被解析成为字符串\n\n<view wx:for="{{[1,2,3]}} ">\n  {{item}}\n</view>\n\n\n等同于\n\n<view wx:for="{{[1,2,3] + \' \'}}" >\n  {{item}}\n</view>\n',charsets:{cjk:!0}},{title:"小程序架构",frontmatter:{},regularPath:"/mp/get-started/miniprogram-framework.html",relativePath:"mp/get-started/miniprogram-framework.md",key:"v-c5b9cbd8",path:"/mp/get-started/miniprogram-framework.html",headers:[{level:2,title:"渲染层和逻辑层",slug:"渲染层和逻辑层",normalizedTitle:"渲染层和逻辑层",charIndex:134},{level:2,title:"程序与页面",slug:"程序与页面",normalizedTitle:"程序与页面",charIndex:406},{level:2,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:1348},{level:2,title:"API",slug:"api",normalizedTitle:"api",charIndex:1885}],headersStr:"渲染层和逻辑层 程序与页面 组件 API",content:'# 小程序架构\n\n我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。\n\n上一章中我们把小程序涉及到的文件类型阐述了一遍，我们结合 QuickStart 这个项目来讲一下这些文件是怎么配合工作的。\n\n\n# 渲染层和逻辑层\n\n首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。\n\n小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行 JS 脚本。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发，小程序的通信模型下图所示。\n\n\n\n\n# 程序与页面\n\n微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。\n\n紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:\n\n{\n  "pages":[\n    "pages/index/index",\n    "pages/logs/logs"\n  ]\n}\n\n\n这个配置说明在 QuickStart 项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs。而写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。\n\n于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。\n\n小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:\n\nApp({\n  onLaunch: function () {\n    // 小程序启动之后 触发\n  }\n})\n\n\n整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 App 实例 。\n\n接下来我们简单看看小程序的一个页面是怎么写的。\n\n你可以观察到 pages/logs/logs 下其实是包括了4种文件的，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 logs.js，你可以看到 logs.js 的大体内容就是:\n\nPage({\n  data: { // 参与页面渲染的数据\n    logs: []\n  },\n  onLoad: function () {\n    // 页面渲染后 执行\n  }\n})\n\n\nPage 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。\n\n在渲染完界面之后，页面实例就会收到一个 onLoad 的回调，你可以在这个回调处理你的逻辑。\n\n有关于 Page 构造器更多详细的文档参考 Page 注册与管理 。\n\n\n# 组件\n\n小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。\n\n就像 HTML 的 div, p 等标签一样，在小程序里边，你只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：\n\n<map></map>\n\n\n使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:\n\n<map longitude="广州经度" latitude="广州纬度"></map>\n\n\n组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：\n\n<map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>\n\n\n当然你也可以通过 style 或者 class 来控制组件的外层样式，以便适应你的界面宽度高度等等。\n\n更多的组件可以参考 小程序提供的基础组件。\n\n\n# API\n\n为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。\n\n要获取用户的地理位置时，只需要：\n\nwx.getLocation({\n  type: \'wgs84\',\n  success: (res) => {\n    var latitude = res.latitude // 纬度\n    var longitude = res.longitude // 经度\n  }\n})\n\n\n调用微信扫一扫能力，只需要：\n\nwx.scanCode({\n  success: (res) => {\n    console.log(res)\n  }\n})\n\n\n需要注意的是：多数 API 的回调都是异步，你需要处理好代码逻辑的异步问题。\n\n更多的 API 能力可以参考 小程序提供的 API 能力。',normalizedContent:'# 小程序架构\n\n我们称微信客户端给小程序所提供的环境为宿主环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。\n\n上一章中我们把小程序涉及到的文件类型阐述了一遍，我们结合 quickstart 这个项目来讲一下这些文件是怎么配合工作的。\n\n\n# 渲染层和逻辑层\n\n首先，我们来简单了解下小程序的运行环境。小程序的运行环境分成渲染层和逻辑层，其中 wxml 模板和 wxss 样式工作在渲染层，js 脚本工作在逻辑层。\n\n小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 webview 进行渲染；逻辑层采用 jscore 线程运行 js 脚本。一个小程序存在多个界面，所以渲染层存在多个 webview 线程，这两个线程的通信会经由微信客户端（下文中也会采用native来代指微信客户端）做中转，逻辑层发送网络请求也经由native转发，小程序的通信模型下图所示。\n\n\n\n\n# 程序与页面\n\n微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。\n\n紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:\n\n{\n  "pages":[\n    "pages/index/index",\n    "pages/logs/logs"\n  ]\n}\n\n\n这个配置说明在 quickstart 项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs。而写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。\n\n于是微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。\n\n小程序启动之后，在 app.js 定义的 app 实例的 onlaunch 回调会被执行:\n\napp({\n  onlaunch: function () {\n    // 小程序启动之后 触发\n  }\n})\n\n\n整个小程序只有一个 app 实例，是全部页面共享的，更多的事件回调参考文档 app 实例 。\n\n接下来我们简单看看小程序的一个页面是怎么写的。\n\n你可以观察到 pages/logs/logs 下其实是包括了4种文件的，微信客户端会先根据 logs.json 配置生成一个界面，顶部的颜色和文字你都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 wxml 结构和 wxss 样式。最后客户端会装载 logs.js，你可以看到 logs.js 的大体内容就是:\n\npage({\n  data: { // 参与页面渲染的数据\n    logs: []\n  },\n  onload: function () {\n    // 页面渲染后 执行\n  }\n})\n\n\npage 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 data 数据和 index.wxml 一起渲染出最终的结构，于是就得到了你看到的小程序的样子。\n\n在渲染完界面之后，页面实例就会收到一个 onload 的回调，你可以在这个回调处理你的逻辑。\n\n有关于 page 构造器更多详细的文档参考 page 注册与管理 。\n\n\n# 组件\n\n小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。\n\n就像 html 的 div, p 等标签一样，在小程序里边，你只需要在 wxml 写上对应的组件标签名字就可以把该组件显示在界面上，例如，你需要在界面上显示地图，你只需要这样写即可：\n\n<map></map>\n\n\n使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是广州，那么你需要声明地图的 longitude（中心经度） 和 latitude（中心纬度）两个属性:\n\n<map longitude="广州经度" latitude="广州纬度"></map>\n\n\n组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，你可以在 js 编写 markertap 函数来处理：\n\n<map bindmarkertap="markertap" longitude="广州经度" latitude="广州纬度"></map>\n\n\n当然你也可以通过 style 或者 class 来控制组件的外层样式，以便适应你的界面宽度高度等等。\n\n更多的组件可以参考 小程序提供的基础组件。\n\n\n# api\n\n为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 api 给开发者去使用。\n\n要获取用户的地理位置时，只需要：\n\nwx.getlocation({\n  type: \'wgs84\',\n  success: (res) => {\n    var latitude = res.latitude // 纬度\n    var longitude = res.longitude // 经度\n  }\n})\n\n\n调用微信扫一扫能力，只需要：\n\nwx.scancode({\n  success: (res) => {\n    console.log(res)\n  }\n})\n\n\n需要注意的是：多数 api 的回调都是异步，你需要处理好代码逻辑的异步问题。\n\n更多的 api 能力可以参考 小程序提供的 api 能力。',charsets:{cjk:!0}},{title:"样式与 WXSS",frontmatter:{},regularPath:"/mp/get-started/style-wxss.html",relativePath:"mp/get-started/style-wxss.md",key:"v-3a8ab342",path:"/mp/get-started/style-wxss.html",headers:[{level:2,title:"尺寸单位",slug:"尺寸单位",normalizedTitle:"尺寸单位",charIndex:187},{level:2,title:"样式导入",slug:"样式导入",normalizedTitle:"样式导入",charIndex:195},{level:2,title:"内联样式",slug:"内联样式",normalizedTitle:"内联样式",charIndex:825},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:1015},{level:2,title:"全局样式与局部样式",slug:"全局样式与局部样式",normalizedTitle:"全局样式与局部样式",charIndex:1492}],headersStr:"尺寸单位 样式导入 内联样式 选择器 全局样式与局部样式",content:'# 样式与 WXSS\n\nWXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。\n\nWXSS 用来决定 WXML 的组件应该怎么显示。\n\n为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。\n\n与 CSS 相比，WXSS 扩展的特性有：\n\n * 尺寸单位\n * 样式导入\n\n\n# 尺寸单位\n\n * rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n设备             RPX换算PX (屏幕宽度/750)   PX换算RPX (750/屏幕宽度)\niPhone5        1rpx = 0.42px        1px = 2.34rpx\niPhone6        1rpx = 0.5px         1px = 2rpx\niPhone6 Plus   1rpx = 0.552px       1px = 1.81rpx\n\n建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。\n\n注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。\n\n\n# 样式导入\n\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\n\n示例代码：\n\n/** common.wxss **/\n.small-p {\n  padding: 5px;\n}\n/** app.wxss **/\n@import "common.wxss";\n.middle-p {\n  padding: 15px;\n}\n\n\n\n# 内联样式\n\n框架组件上支持使用 style、class 属性来控制组件的样式。\n\n * style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。\n\n<view style="color:{{color}};" />\n\n\n * class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。\n\n<view class="normal_view" />\n\n\n\n# 选择器\n\n目前支持的选择器有：\n\n选择器                样例               样例描述\n.class             .intro           选择所有拥有 class="intro" 的组件\n#id                #firstname       选择拥有 id="firstname" 的组件\nelement            view             选择所有 view 组件\nelement, element   view, checkbox   选择所有文档的 view 组件和所有的 checkbox 组件\n::after            view::after      在 view 组件后边插入内容\n::before           view::before     在 view 组件前边插入内容\n\n\n# 全局样式与局部样式\n\n定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。',normalizedContent:'# 样式与 wxss\n\nwxss (weixin style sheets) 是一套样式语言，用于描述 wxml 的组件样式。\n\nwxss 用来决定 wxml 的组件应该怎么显示。\n\n为了适应广大的前端开发者，wxss 具有 css 大部分特性。同时为了更适合开发微信小程序，wxss 对 css 进行了扩充以及修改。\n\n与 css 相比，wxss 扩展的特性有：\n\n * 尺寸单位\n * 样式导入\n\n\n# 尺寸单位\n\n * rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iphone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。\n\n设备             rpx换算px (屏幕宽度/750)   px换算rpx (750/屏幕宽度)\niphone5        1rpx = 0.42px        1px = 2.34rpx\niphone6        1rpx = 0.5px         1px = 2rpx\niphone6 plus   1rpx = 0.552px       1px = 1.81rpx\n\n建议： 开发微信小程序时设计师可以用 iphone6 作为视觉稿的标准。\n\n注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。\n\n\n# 样式导入\n\n使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。\n\n示例代码：\n\n/** common.wxss **/\n.small-p {\n  padding: 5px;\n}\n/** app.wxss **/\n@import "common.wxss";\n.middle-p {\n  padding: 15px;\n}\n\n\n\n# 内联样式\n\n框架组件上支持使用 style、class 属性来控制组件的样式。\n\n * style：静态的样式统一写到 class 中。style 接收动态的样式，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度。\n\n<view style="color:{{color}};" />\n\n\n * class：用于指定样式规则，其属性值是样式规则中类选择器名(样式类名)的集合，样式类名不需要带上.，样式类名之间用空格分隔。\n\n<view class="normal_view" />\n\n\n\n# 选择器\n\n目前支持的选择器有：\n\n选择器                样例               样例描述\n.class             .intro           选择所有拥有 class="intro" 的组件\n#id                #firstname       选择拥有 id="firstname" 的组件\nelement            view             选择所有 view 组件\nelement, element   view, checkbox   选择所有文档的 view 组件和所有的 checkbox 组件\n::after            view::after      在 view 组件后边插入内容\n::before           view::before     在 view 组件前边插入内容\n\n\n# 全局样式与局部样式\n\n定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。',charsets:{cjk:!0}},{title:"Home",frontmatter:{home:!0,heroText:null,tagline:null,search:!1},regularPath:"/private/0yyy0qaq==/",relativePath:"private/0yyy0qaq==/index.md",key:"v-246dd3ca",path:"/private/0yyy0qaq==/",headersStr:null,content:"# 0yyy0qaq== Index\n\n * 麻将",normalizedContent:"# 0yyy0qaq== index\n\n * 麻将",charsets:{cjk:!0}},{title:"创建 Mount 函数",frontmatter:{},regularPath:"/vue3-deep-dive/creating-a-mount-function.html",relativePath:"vue3-deep-dive/creating-a-mount-function.md",key:"v-4bb39c46",path:"/vue3-deep-dive/creating-a-mount-function.html",headersStr:null,content:"# 创建 Mount 函数\n\n第一件事就是 h 函数。很简单，因为我们真的只是把三个参数放进一个对象。更有趣的是，我们如何在这里实现这个挂载函数。现在有很多假设，我们只是想让这更简单。\n\n首先让我们假设一切都是一个元素。第二件事是，我们还假设调用参数总是一样的顺序，所以如果你没有任何 props，您必须显式地传递 null。\n\n我们知道我们假设这总是一个元素节点。所以 vnode.tag 会告诉我们它是什么样的元素。所以当我们挂载一个虚拟 DOM 树时，我们正在创建相应的真实 DOM 节点。\n\n\n\n现在，我们接下来要做的就是把它插入容器。中间有一些事情我们还需要处理，包括 props 和 children，所以如果 vnode 有 props，我们得反复检查 props 把它们分别放在元素上作为 DOM property 或 attribute。\n\n\n\n在实际执行中，我们必须考虑很多事情，例如检查是否应该设置作为 property 或 attribute 或者是一个事件监听者。但为了简单起见，我们假设一切都是 attribute，如果你有一个 id，它就会作为元素的 attribute 或者一个 class 被设置，在这种情况下，我们这里确实有一个 class。\n\n\n\n如果我们有孩子，我们再次做一个假设。我们假设孩子是一个字符串或虚拟节点数组，这样可以使我们的算法更容易处理。\n\n我们会说如果vnode.children等于字符串。如果我们有 child 在这里，我们能做的是...但是如果我们有一个 vNode 数组，这里我们知道这只能是子 vnode。这是我们可以进行一点递归的区域，因为我们已经有了挂载功能。所以我们可以说mount(child)，child 是 vnode。然后我们需要给它一个容器，是我们刚刚创建的元素，现在我们已经完成了一个非常基本的挂载功能。\n\n\n\n以上就是 mount 的部分了。\n\n下一个练习是关于 patch 的部分，即更新虚拟 DOM。\n\n对于要构建的应用程序，最初的挂载就是创造一些东西。以前没有以及随后的更新，我们希望尽可能多地重用。所以我们只修改其中的内容，而不是重新创建它们。\n\n所以如果我们有一个叫 patch 的东西。patch 函数将接收我们称之为n1，n2。n1 代表旧的虚拟 DOM，之前的快照，基本上表示当前屏幕上的内容。n2 将是新的快照，它代表了我们希望屏幕更新的内容。\n\n是的，所以这是我们的工作，或者是 patch 函数的工作——找出它需要执行的，将屏幕更新到所需的状态的，最小数量的 DOM 操作。\n\n我们已经渲染了原始组件，它渲染了一次模板，把它变成了虚拟 DOM，然后一个响应式属性被更新，所以它触发了重新渲染，重新生成另一个表示形式虚拟 DOM。\n\n现在我们有两个虚拟 DOM，我们需要对两者进行比较。\n\n这是另一个快照\n\n\n\n想象一下我们点击按钮，按钮改变了我们的组件状态。基本上说这个类现在应该是绿色的，并且应该修改这段文字。\n\n我们希望 DOM 反映更新后的状态，所以它（patch）将执行所有的需要更新的 DOM 操作\n\n所以在我们这么做之前，我们需要对我们的算法做些小小的改变。\n\n\n\n我们存储了相应的实际 DOM 元素到 vnode 本身，所以现在当你看到以前的 vDOM 时，您可以使用.el访问旧的真实 DOM 树。所以有了这个改变，我们应该把一切都准备好了。",normalizedContent:"# 创建 mount 函数\n\n第一件事就是 h 函数。很简单，因为我们真的只是把三个参数放进一个对象。更有趣的是，我们如何在这里实现这个挂载函数。现在有很多假设，我们只是想让这更简单。\n\n首先让我们假设一切都是一个元素。第二件事是，我们还假设调用参数总是一样的顺序，所以如果你没有任何 props，您必须显式地传递 null。\n\n我们知道我们假设这总是一个元素节点。所以 vnode.tag 会告诉我们它是什么样的元素。所以当我们挂载一个虚拟 dom 树时，我们正在创建相应的真实 dom 节点。\n\n\n\n现在，我们接下来要做的就是把它插入容器。中间有一些事情我们还需要处理，包括 props 和 children，所以如果 vnode 有 props，我们得反复检查 props 把它们分别放在元素上作为 dom property 或 attribute。\n\n\n\n在实际执行中，我们必须考虑很多事情，例如检查是否应该设置作为 property 或 attribute 或者是一个事件监听者。但为了简单起见，我们假设一切都是 attribute，如果你有一个 id，它就会作为元素的 attribute 或者一个 class 被设置，在这种情况下，我们这里确实有一个 class。\n\n\n\n如果我们有孩子，我们再次做一个假设。我们假设孩子是一个字符串或虚拟节点数组，这样可以使我们的算法更容易处理。\n\n我们会说如果vnode.children等于字符串。如果我们有 child 在这里，我们能做的是...但是如果我们有一个 vnode 数组，这里我们知道这只能是子 vnode。这是我们可以进行一点递归的区域，因为我们已经有了挂载功能。所以我们可以说mount(child)，child 是 vnode。然后我们需要给它一个容器，是我们刚刚创建的元素，现在我们已经完成了一个非常基本的挂载功能。\n\n\n\n以上就是 mount 的部分了。\n\n下一个练习是关于 patch 的部分，即更新虚拟 dom。\n\n对于要构建的应用程序，最初的挂载就是创造一些东西。以前没有以及随后的更新，我们希望尽可能多地重用。所以我们只修改其中的内容，而不是重新创建它们。\n\n所以如果我们有一个叫 patch 的东西。patch 函数将接收我们称之为n1，n2。n1 代表旧的虚拟 dom，之前的快照，基本上表示当前屏幕上的内容。n2 将是新的快照，它代表了我们希望屏幕更新的内容。\n\n是的，所以这是我们的工作，或者是 patch 函数的工作——找出它需要执行的，将屏幕更新到所需的状态的，最小数量的 dom 操作。\n\n我们已经渲染了原始组件，它渲染了一次模板，把它变成了虚拟 dom，然后一个响应式属性被更新，所以它触发了重新渲染，重新生成另一个表示形式虚拟 dom。\n\n现在我们有两个虚拟 dom，我们需要对两者进行比较。\n\n这是另一个快照\n\n\n\n想象一下我们点击按钮，按钮改变了我们的组件状态。基本上说这个类现在应该是绿色的，并且应该修改这段文字。\n\n我们希望 dom 反映更新后的状态，所以它（patch）将执行所有的需要更新的 dom 操作\n\n所以在我们这么做之前，我们需要对我们的算法做些小小的改变。\n\n\n\n我们存储了相应的实际 dom 元素到 vnode 本身，所以现在当你看到以前的 vdom 时，您可以使用.el访问旧的真实 dom 树。所以有了这个改变，我们应该把一切都准备好了。",charsets:{cjk:!0}},{title:"介绍",frontmatter:{},regularPath:"/vue3-deep-dive/intro.html",relativePath:"vue3-deep-dive/intro.md",key:"v-04117fc6",path:"/vue3-deep-dive/intro.html",headersStr:null,content:"# 介绍\n\nVue 基于我们的模板创建一个渲染函数，返回一个虚拟 DOM 节点。\n\n虚拟 DOM 使用简化的 JavaScript 对象来表示 DOM 结构，比操作实际 DOM 效率更高。\n\n当组件更改时，render 函数将重新运行，它将创建另一个虚拟节点。然后发送旧的 VNode 和新的 VNode 到 Vue 中进行比较，并以最高效的方式在我们的网页上更新。\n\n我们可以将虚拟 DOM 和实际 DOM 的关系类比为蓝图和实际建筑的关系。\n\n假设我更改了 29 楼的一些数据。我改变了家具的布局，还加了一些橱柜。我有两种方法可以改变。\n\n首先，我可以拆除 29 楼的一切，从头开始重建。或者我可以创造新的蓝图，比较新旧蓝图。并进行更新以尽可能减少工作量。\n\n这就是虚拟 DOM 的工作原理。Vue 3 让这些更新更快，并且更高效。\n\nVue 有三个核心模块：\n\n * 响应式模块\n * 编译器模块\n * 渲染模块\n\n响应式模块允许我们创建 JavaScript 响应对象并可以观察其变化。当使用这些对象的代码运行时，它们会被跟踪。因此，如果响应对象发生变化，它们可以在以后运行。\n\n接下来是编译器模块。它知道如何获取 HTML 模板并将它们编译成渲染函数。这可能在运行时在浏览器中发生，但在构建 Vue 项目时更常见。这样浏览器就可以只接收渲染函数。\n\n最后，渲染模块的代码包含在网页上渲染组件的三个不同阶段。\n\n * 渲染阶段：调用 render 函数。它返回一个虚拟 DOM 节点\n * 挂载阶段：使用虚拟 DOM 节点并调用 DOM API 来创建网页\n * 补丁阶段：渲染器将旧的虚拟节点和新的虚拟节点进行比较并只更新网页变化的部分\n\n现在让我们来看一个例子，看看一个简单组件的执行。\n\n在这里你可以看到我的简单组件，它有一个模板，以及在模板内部使用的响应对象。\n\n首先，模板编译器将 HTML 转换为一个渲染函数。然后初始化响应对象使用响应式模块。\n\n接下来，在渲染模块中，我们进入渲染阶段。\n\n这将调用 render 函数，它引用了响应对象。我们现在观察这个响应对象的变化，render 函数返回一个虚拟 DOM 节点。接下来，在挂载阶段，调用 mount 函数。使用虚拟 DOM 节点创建 web 页面。\n\n最后，如果我们的响应对象发生任何变化，正在被监视，渲染器再次调用 render 函数，创建一个新的虚拟 DOM 节点。\n\n新的和旧的虚拟 DOM 节点发送到补丁函数中，然后根据需要更新我们的网页。",normalizedContent:"# 介绍\n\nvue 基于我们的模板创建一个渲染函数，返回一个虚拟 dom 节点。\n\n虚拟 dom 使用简化的 javascript 对象来表示 dom 结构，比操作实际 dom 效率更高。\n\n当组件更改时，render 函数将重新运行，它将创建另一个虚拟节点。然后发送旧的 vnode 和新的 vnode 到 vue 中进行比较，并以最高效的方式在我们的网页上更新。\n\n我们可以将虚拟 dom 和实际 dom 的关系类比为蓝图和实际建筑的关系。\n\n假设我更改了 29 楼的一些数据。我改变了家具的布局，还加了一些橱柜。我有两种方法可以改变。\n\n首先，我可以拆除 29 楼的一切，从头开始重建。或者我可以创造新的蓝图，比较新旧蓝图。并进行更新以尽可能减少工作量。\n\n这就是虚拟 dom 的工作原理。vue 3 让这些更新更快，并且更高效。\n\nvue 有三个核心模块：\n\n * 响应式模块\n * 编译器模块\n * 渲染模块\n\n响应式模块允许我们创建 javascript 响应对象并可以观察其变化。当使用这些对象的代码运行时，它们会被跟踪。因此，如果响应对象发生变化，它们可以在以后运行。\n\n接下来是编译器模块。它知道如何获取 html 模板并将它们编译成渲染函数。这可能在运行时在浏览器中发生，但在构建 vue 项目时更常见。这样浏览器就可以只接收渲染函数。\n\n最后，渲染模块的代码包含在网页上渲染组件的三个不同阶段。\n\n * 渲染阶段：调用 render 函数。它返回一个虚拟 dom 节点\n * 挂载阶段：使用虚拟 dom 节点并调用 dom api 来创建网页\n * 补丁阶段：渲染器将旧的虚拟节点和新的虚拟节点进行比较并只更新网页变化的部分\n\n现在让我们来看一个例子，看看一个简单组件的执行。\n\n在这里你可以看到我的简单组件，它有一个模板，以及在模板内部使用的响应对象。\n\n首先，模板编译器将 html 转换为一个渲染函数。然后初始化响应对象使用响应式模块。\n\n接下来，在渲染模块中，我们进入渲染阶段。\n\n这将调用 render 函数，它引用了响应对象。我们现在观察这个响应对象的变化，render 函数返回一个虚拟 dom 节点。接下来，在挂载阶段，调用 mount 函数。使用虚拟 dom 节点创建 web 页面。\n\n最后，如果我们的响应对象发生任何变化，正在被监视，渲染器再次调用 render 函数，创建一个新的虚拟 dom 节点。\n\n新的和旧的虚拟 dom 节点发送到补丁函数中，然后根据需要更新我们的网页。",charsets:{cjk:!0}},{title:"渲染机制",frontmatter:{},regularPath:"/vue3-deep-dive/rendering-mechanism.html",relativePath:"vue3-deep-dive/rendering-mechanism.md",key:"v-c2f12d76",path:"/vue3-deep-dive/rendering-mechanism.html",headersStr:null,content:"# 渲染机制\n\n拥有虚拟 DOM 层有一些好处。最重要的是，它让组件的渲染逻辑完全从真实 DOM 中解耦，并让它更直接地重用框架的运行时。\n\n在其他环境中，例如，Vue 允许第三方开发人员创建自定义渲染解决方案，目标不仅仅是浏览器，也包括 iOS 和 Android 等原生环境，也可以使用 API 创建自定义渲染器直接渲染到 WebGL 而不是 DOM 节点。\n\n所以，在 Vue 2 中我们实际上已经有了这种能力。但是，我们在 Vue 2 中提供的 API 没有正式记录。并且需要分叉源代码，所以对开发这些定制解决方案的开发人员来说，维护代码成为了很大的负担。\n\n在 Vue 3 中，我们让自定义渲染器 API 成为一等公民，因此开发人员可以直接拉取 Vue 运行时核心作为依赖项，然后利用自定义渲染器 API 构建自己的自定义渲染器。事实上，我们已经有了早期用户报告他们已经使用 Vue 3 API 成功地构建了一个 WebGL 渲染器。\n\n关于虚拟 DOM 的另一个重要方面是它提供了能力，以编程方式构造、检查、克隆以及操作所需的 DOM结构。在实际返回渲染引擎之前，你可以利用 JavaScript 的全部能力。\n\n现在，这个能力很重要。因为总会有某些情况下，在 UI 编程中，使用模板语法会有一些限制。你只需要一种有充分灵活性的合适的编程语言来表达潜在的逻辑。\n\n在日常 UI 开发中，这种情况实际上是相当罕见的。但当你在创作一个库或编写 UI 组件套件供第三方开发者使用的时候，这种情况更常见。\n\n让我们想象一下一个像复杂类型的顶部框这样的组件，或者一个与一堆文本相关联的输入框。这些类型的组件通常包含很少的标记，但它们将包含很多交互逻辑。\n\n在这些情况下，模板语法有时候会限制你更容易地表达潜在的逻辑，或者有时候你会发现自己在模板中加入了很多逻辑，但你在 JavaScript 中还是有很多逻辑。而 render 函数允许你把这些逻辑组合在一个地方。你通常不需要想太多，在 99% 的情况模板会完成你要做的事下你只需要写出 HTML 就好了，但偶尔你可能想做些更可控的事情，在这种情况下，你需要编写一个渲染函数。\n\nVue 2 中的渲染函数如下所示：\n\nrender(h) {\n    return h('div', {\n        attrs: {\n            id: 'foo'\n        },\n        on: {\n            click: this.onClick\n        }\n    }, 'hello')\n}\n\n\n这是组件定义中的一个选项，相比于提供一个 template 选项，你可以为组件提供一个渲染函数。在 Vue 2 中，你会得到 h 参数。我们之前说过的，直接作为渲染函数的参数。你可以用它来创造虚拟 DOM 节点，简称 vnode。\n\nvnode 接受第一个参数是类型，所以我们在这里创建一个 div。第二个参数是一个对象，包含 vnode 上的所有数据或属性。\n\n在 Vue 2 中，API有点冗长。从某种意义上说，你必须指明传递给节点的绑定类型。\n\n例如，如果要绑定属性，你必须把它嵌套在 attrs 对象下。如果要绑定事件侦听器，你得把它列在 on 下面。\n\n第三个参数是这个 vnode 的子节点，所以直接传递一个字符串，是一个方便的 API，表明此节点只包含文本子节点，但它也可以是数组，包含更多子节点，所以你可以在这里有一个数组，并且嵌套了更多的嵌套 h 调用。\n\n现在，我们改变了 API。目标是在 Vue 3 中简化它。\n\nimport { h } from 'vue'\n\nrender() {\n    return h('div', {\n        id: 'foo',\n        onClick: this.onClick\n    }, 'hello')\n}\n\n\n第一个显著的变化是，我们现在有了一个扁平的 props 结构。在这个意义上，当你调用h时，第二个参数现在总是一个扁平的对象，你可以直接给它传递一个属性。\n\n这里我们只是给它一个 ID，按惯例监听器以 on 开头，所以任何带 on 的都会自动绑定为一个监听器，所以你不必考虑太多嵌套的问题。\n\n在大多数情况下，你也不需要思考是应将其作为 attribute 绑定，还是 DOM 属性绑定，因为 Vue 将智能地，找出为你做这件事的最好方法。\n\n实际上，我们检查这个 key 是否存在在原生 DOM 中作为属性。如果存在，我们会将其设置为 property，如果它不存在，我们将它设置为一个 attribute，到目前为止在实践中效果良好。\n\nrender API 的另一项改动是 h 函数。helper 现在是全局导入的，直接从 Vue 本身。这个变化主要来自一种挫折感。\n\n在 Vue 2 中，因为 h 函数绑定到当前组件实例。所以当你想拆分一个大的渲染函数变成小一点的时候，你必须把这个 h 函数一路传递给这些分割函数。但有了全局引入的 h 函数。你导入一次就可以分割你的渲染函数，在同一个文件里分割多少个都行，就不用考虑这个问题。",normalizedContent:"# 渲染机制\n\n拥有虚拟 dom 层有一些好处。最重要的是，它让组件的渲染逻辑完全从真实 dom 中解耦，并让它更直接地重用框架的运行时。\n\n在其他环境中，例如，vue 允许第三方开发人员创建自定义渲染解决方案，目标不仅仅是浏览器，也包括 ios 和 android 等原生环境，也可以使用 api 创建自定义渲染器直接渲染到 webgl 而不是 dom 节点。\n\n所以，在 vue 2 中我们实际上已经有了这种能力。但是，我们在 vue 2 中提供的 api 没有正式记录。并且需要分叉源代码，所以对开发这些定制解决方案的开发人员来说，维护代码成为了很大的负担。\n\n在 vue 3 中，我们让自定义渲染器 api 成为一等公民，因此开发人员可以直接拉取 vue 运行时核心作为依赖项，然后利用自定义渲染器 api 构建自己的自定义渲染器。事实上，我们已经有了早期用户报告他们已经使用 vue 3 api 成功地构建了一个 webgl 渲染器。\n\n关于虚拟 dom 的另一个重要方面是它提供了能力，以编程方式构造、检查、克隆以及操作所需的 dom结构。在实际返回渲染引擎之前，你可以利用 javascript 的全部能力。\n\n现在，这个能力很重要。因为总会有某些情况下，在 ui 编程中，使用模板语法会有一些限制。你只需要一种有充分灵活性的合适的编程语言来表达潜在的逻辑。\n\n在日常 ui 开发中，这种情况实际上是相当罕见的。但当你在创作一个库或编写 ui 组件套件供第三方开发者使用的时候，这种情况更常见。\n\n让我们想象一下一个像复杂类型的顶部框这样的组件，或者一个与一堆文本相关联的输入框。这些类型的组件通常包含很少的标记，但它们将包含很多交互逻辑。\n\n在这些情况下，模板语法有时候会限制你更容易地表达潜在的逻辑，或者有时候你会发现自己在模板中加入了很多逻辑，但你在 javascript 中还是有很多逻辑。而 render 函数允许你把这些逻辑组合在一个地方。你通常不需要想太多，在 99% 的情况模板会完成你要做的事下你只需要写出 html 就好了，但偶尔你可能想做些更可控的事情，在这种情况下，你需要编写一个渲染函数。\n\nvue 2 中的渲染函数如下所示：\n\nrender(h) {\n    return h('div', {\n        attrs: {\n            id: 'foo'\n        },\n        on: {\n            click: this.onclick\n        }\n    }, 'hello')\n}\n\n\n这是组件定义中的一个选项，相比于提供一个 template 选项，你可以为组件提供一个渲染函数。在 vue 2 中，你会得到 h 参数。我们之前说过的，直接作为渲染函数的参数。你可以用它来创造虚拟 dom 节点，简称 vnode。\n\nvnode 接受第一个参数是类型，所以我们在这里创建一个 div。第二个参数是一个对象，包含 vnode 上的所有数据或属性。\n\n在 vue 2 中，api有点冗长。从某种意义上说，你必须指明传递给节点的绑定类型。\n\n例如，如果要绑定属性，你必须把它嵌套在 attrs 对象下。如果要绑定事件侦听器，你得把它列在 on 下面。\n\n第三个参数是这个 vnode 的子节点，所以直接传递一个字符串，是一个方便的 api，表明此节点只包含文本子节点，但它也可以是数组，包含更多子节点，所以你可以在这里有一个数组，并且嵌套了更多的嵌套 h 调用。\n\n现在，我们改变了 api。目标是在 vue 3 中简化它。\n\nimport { h } from 'vue'\n\nrender() {\n    return h('div', {\n        id: 'foo',\n        onclick: this.onclick\n    }, 'hello')\n}\n\n\n第一个显著的变化是，我们现在有了一个扁平的 props 结构。在这个意义上，当你调用h时，第二个参数现在总是一个扁平的对象，你可以直接给它传递一个属性。\n\n这里我们只是给它一个 id，按惯例监听器以 on 开头，所以任何带 on 的都会自动绑定为一个监听器，所以你不必考虑太多嵌套的问题。\n\n在大多数情况下，你也不需要思考是应将其作为 attribute 绑定，还是 dom 属性绑定，因为 vue 将智能地，找出为你做这件事的最好方法。\n\n实际上，我们检查这个 key 是否存在在原生 dom 中作为属性。如果存在，我们会将其设置为 property，如果它不存在，我们将它设置为一个 attribute，到目前为止在实践中效果良好。\n\nrender api 的另一项改动是 h 函数。helper 现在是全局导入的，直接从 vue 本身。这个变化主要来自一种挫折感。\n\n在 vue 2 中，因为 h 函数绑定到当前组件实例。所以当你想拆分一个大的渲染函数变成小一点的时候，你必须把这个 h 函数一路传递给这些分割函数。但有了全局引入的 h 函数。你导入一次就可以分割你的渲染函数，在同一个文件里分割多少个都行，就不用考虑这个问题。",charsets:{cjk:!0}},{title:"使用渲染函数",frontmatter:{},regularPath:"/vue3-deep-dive/use-render-function.html",relativePath:"vue3-deep-dive/use-render-function.md",key:"v-981a8bba",path:"/vue3-deep-dive/use-render-function.html",headersStr:null,content:"# 使用渲染函数\n\n让我们做一个高层次的介绍，看看渲染函数在 Vue 中是什么样子。\n\n假设我们有一个 Vue 组件。传统上，我们有一个 template 选项，但是为了重用渲染函数，我们可以用一个名为 render 的函数来代替它。\n\n在 Vue 2，我们会通过参数得到这个称为 h 的东西，这是 hyperscript 的缩写。但在这里，我们只是示范一下我们如何在 Vue 3 中使用它。我们会从 vue 导入 h。\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n\t\n\t}\n}\n\n\n我们可以用它来...比如返回h(div)。所以这是等效的，跟模板中的普通 div 一样。它返回 div 的 JavaScript 对象表示。\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        return h('div')\n\t}\n}\n\n\n渲染器接收参数，然后它实际上进行 dom 调用将其带入浏览器，所以我们可以给这个虚拟节点一些 props 属性：\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        return h('div', {\n            id: 'hello'\n        })\n\t}\n}\n\n\n在最终的 dom 里将得到类似于<div id=\"hello\"></div>的东西。\n\n然后，你可以给它更多的嵌套子元素。这样你就可以写：\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        return h('div', {\n            id: 'hello'\n        }, [h('span', 'world')])\n\t}\n}\n\n\n所以这会产生类似这样的结构：\n\n<div id=\"hello\">\n    <span>world</span>\n</div>\n\n\n现在，我们知道如何生成静态结构。\n\n但是当人们第一次使用 render 函数会问：“我该怎么写 v-if 或者 v-for？”\n\n在 render 函数中，我们没有，像 v-if 或者类似的东西。请直接使用 JavaScript。\n\n和 v-if=\"ok\"等价的是，我们可以用一个三元表达式，像这样...\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        // v-if=\"ok\"\n        return this.ok\n            ? h('div', { id: 'hello' }, [h('span', 'world')])\n            : h('p', 'other branch')\n\t}\n}\n\n\n如果你想做v-else-if\n\n你可以这样使用：\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        let nodeToReturn\n        if (this.ok) {\n            nodeToReturn = ...\n        } else if () {\n            ...\n        } else {\n            ...\n        }\n        ...\n\t}\n}\n\n\n那 v-for...类似的...在 JavaScript 中，在 render 函数中它看起来更像这样...\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        // v-for=\"item in list\"\n        return this.list.map(item => {\n            return h('div', { key: item.id }, item.text)\n        })\n\t}\n}\n\n\n这是渲染函数中的渲染列表。\n\n还有一件事你要处理。实际上，在渲染函数中，您可能会总是要处理的...是插槽。\n\n这是因为通常，当你写一个重标记的组件，或者我更喜欢称之为特性组件。它与你的应用程序的外观有关，布局结构，实际的标记语言，显示给用户的。对于那些类型的组件，我更喜欢始终使用模板。\n\n只有在我必须使用渲染函数的时候。比如，我在写一些功能型的组件，一个有时会期望获取一些插槽内容，将其打包或者以某种方式操纵他们，这是最常见的情况，我们会使用渲染函数。\n\n为了应付在某些渲染函数中的插槽，你通常会把这样写...\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        this.$slots\n\t}\n}\n\n\n在Vue 3里，所有默认插槽将被暴露在这个this.$slot.default并且总是函数。但是如果什么都没有提供、这将返回 undefined，所以你得先检查一下它的存在，然后你才能调用它。\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        this.$slots.default && this.$slots.default()\n\t}\n}\n\n\n这会给你插槽的内容，它将是一个 vnode 的数组。所以如果它存在，它将永远是一个数组。\n\n现在，如果你熟悉的话，有了作用域槽，我们可以将 props 传递给作用域槽，所以把数据传递到作用域槽，只是通过传递一个参数到这个函数调用中，所以这真的很有用。因为我们想确定这总是一个数组，所以通常会这样写：\n\nimport { h } from 'vue'\n\nconst App = {\n\trender() {\n        const slot = this.$slots.default\n        \t? this.$slots.default({...})\n        \t: []\n\t}\n}\n\n\n如果你愿意的话，我们可以直接返回这个插槽。或者你可以，因为这是一个数组，你可以直接放在 children 身上，另一个元素的位置。你想怎么写就怎么写。\n\n你可以用插槽做一件很强大的事：在 render 函数中，以某种方式操纵插槽。你可以检查它们，因为这真的只是一个 JavaScript 对象数组。你也可以在这个过程中加工它们。\n\n举个例子：\n\n假设我们有一个堆栈组件，我在一些用户界面库中见过这种情况。\n\n其中堆栈组件（Stack）是布局组件。你可以这样使用它，可以传递很多东西，也可以有嵌套的堆栈。\n\n<Stack size=\"4\">\n    <div>hello</div>\n    <Stack size=\"4\">\n        <div>hello</div>\n        <div>hello</div>\n    </Stack>\n</Stack>\n\n\n渲染结果是它将包裹每个子对象，直接的孩子给了它一些 margin。当你像这样嵌套，你得到了嵌套的边距布局。有点像 HTML 中 UL 和 OL 的默认样式。\n\n因此想要的渲染输出会是...\n\n<div class=\"stack\">\n    <div class=\"mt-4\">\n        <div>hello</div>\n    </div>\n    <div class=\"mt-4\">\n        <div class=\"stack\">\n            <div class=\"mt-4\">\n                <div>hello</div>\n                <div>hello</div>\n            </div>\n        </div>\n    </div>\n</div>\n\n\n事实上，每个都会被包起来的。mt-4 是一个功能类，它将给它一些边距，然后你会有另一个 mt-4，又包了另一个 stack。这个列表也是一样的。\n\n好吧，所以它只是制造了一堆包裹元素，唯一的目的是给予一些额外的填充或边距用于布局。\n\n那么，我们怎么做，比如说，在里面使用一个普通的基于模板的语法？因为你想要的就是这些在同一个插槽内。它们都是默认插槽。\n\n\n\n对于模板语法，只有你能做的就是渲染这个部分，一炮而过。\n\n所以在模板里面，没有机会程序化的遍历插槽内的每个项目，然后把它们变成别的东西。但是你可以用渲染函数来实现。所以，如果我们要实现这样的堆栈组件，我们可以像这样：\n\nimport { h } from 'vue'\n\nconst Stack = {\n\trender() {\n        const slot = this.$slots.default\n        \t? this.$slots.default({...})\n        \t: []\n        return h('div', { class: 'stack' }, slot.map(child => {\n            return h('div', { class: `mt-${this.$props.size}` }, [\n                child\n            ])\n        }))\n\t}\n}\n\n\n我们把孩子放在里面，所以我们用的是一个slot.map生成新的 vnode 列表，原来的子插槽被包装在里面。\n\n所以我认为这是一个很好的例子，当你创作这些底层的公用设施组件，有时你真的会遇到麻烦，这时渲染函数更有效。但话说回来，也需要了解每种方法的利弊。我们希望这样过一遍，所有这些都是为了让你更好地理解，在什么情况下应该使用模板或使用渲染函数。\n\n总的来说，从我的经验来看，这种情况在您创作可重用的功能组件时更常见。\n\n在日常开发中，你主要是在编写特性组件。模板通常是有效的方式。\n\n模板的好处是更简单，优化通过编译器优化，尤其当你有很多标记的时候。它的另一个好处是它更容易让设计师接管组件，并用 CSS 设计样式。\n\n因此，Vue 提供了这两个选项，当情况出现的时候，以便您可以选择合适的工具。",normalizedContent:"# 使用渲染函数\n\n让我们做一个高层次的介绍，看看渲染函数在 vue 中是什么样子。\n\n假设我们有一个 vue 组件。传统上，我们有一个 template 选项，但是为了重用渲染函数，我们可以用一个名为 render 的函数来代替它。\n\n在 vue 2，我们会通过参数得到这个称为 h 的东西，这是 hyperscript 的缩写。但在这里，我们只是示范一下我们如何在 vue 3 中使用它。我们会从 vue 导入 h。\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n\t\n\t}\n}\n\n\n我们可以用它来...比如返回h(div)。所以这是等效的，跟模板中的普通 div 一样。它返回 div 的 javascript 对象表示。\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        return h('div')\n\t}\n}\n\n\n渲染器接收参数，然后它实际上进行 dom 调用将其带入浏览器，所以我们可以给这个虚拟节点一些 props 属性：\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        return h('div', {\n            id: 'hello'\n        })\n\t}\n}\n\n\n在最终的 dom 里将得到类似于<div id=\"hello\"></div>的东西。\n\n然后，你可以给它更多的嵌套子元素。这样你就可以写：\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        return h('div', {\n            id: 'hello'\n        }, [h('span', 'world')])\n\t}\n}\n\n\n所以这会产生类似这样的结构：\n\n<div id=\"hello\">\n    <span>world</span>\n</div>\n\n\n现在，我们知道如何生成静态结构。\n\n但是当人们第一次使用 render 函数会问：“我该怎么写 v-if 或者 v-for？”\n\n在 render 函数中，我们没有，像 v-if 或者类似的东西。请直接使用 javascript。\n\n和 v-if=\"ok\"等价的是，我们可以用一个三元表达式，像这样...\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        // v-if=\"ok\"\n        return this.ok\n            ? h('div', { id: 'hello' }, [h('span', 'world')])\n            : h('p', 'other branch')\n\t}\n}\n\n\n如果你想做v-else-if\n\n你可以这样使用：\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        let nodetoreturn\n        if (this.ok) {\n            nodetoreturn = ...\n        } else if () {\n            ...\n        } else {\n            ...\n        }\n        ...\n\t}\n}\n\n\n那 v-for...类似的...在 javascript 中，在 render 函数中它看起来更像这样...\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        // v-for=\"item in list\"\n        return this.list.map(item => {\n            return h('div', { key: item.id }, item.text)\n        })\n\t}\n}\n\n\n这是渲染函数中的渲染列表。\n\n还有一件事你要处理。实际上，在渲染函数中，您可能会总是要处理的...是插槽。\n\n这是因为通常，当你写一个重标记的组件，或者我更喜欢称之为特性组件。它与你的应用程序的外观有关，布局结构，实际的标记语言，显示给用户的。对于那些类型的组件，我更喜欢始终使用模板。\n\n只有在我必须使用渲染函数的时候。比如，我在写一些功能型的组件，一个有时会期望获取一些插槽内容，将其打包或者以某种方式操纵他们，这是最常见的情况，我们会使用渲染函数。\n\n为了应付在某些渲染函数中的插槽，你通常会把这样写...\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        this.$slots\n\t}\n}\n\n\n在vue 3里，所有默认插槽将被暴露在这个this.$slot.default并且总是函数。但是如果什么都没有提供、这将返回 undefined，所以你得先检查一下它的存在，然后你才能调用它。\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        this.$slots.default && this.$slots.default()\n\t}\n}\n\n\n这会给你插槽的内容，它将是一个 vnode 的数组。所以如果它存在，它将永远是一个数组。\n\n现在，如果你熟悉的话，有了作用域槽，我们可以将 props 传递给作用域槽，所以把数据传递到作用域槽，只是通过传递一个参数到这个函数调用中，所以这真的很有用。因为我们想确定这总是一个数组，所以通常会这样写：\n\nimport { h } from 'vue'\n\nconst app = {\n\trender() {\n        const slot = this.$slots.default\n        \t? this.$slots.default({...})\n        \t: []\n\t}\n}\n\n\n如果你愿意的话，我们可以直接返回这个插槽。或者你可以，因为这是一个数组，你可以直接放在 children 身上，另一个元素的位置。你想怎么写就怎么写。\n\n你可以用插槽做一件很强大的事：在 render 函数中，以某种方式操纵插槽。你可以检查它们，因为这真的只是一个 javascript 对象数组。你也可以在这个过程中加工它们。\n\n举个例子：\n\n假设我们有一个堆栈组件，我在一些用户界面库中见过这种情况。\n\n其中堆栈组件（stack）是布局组件。你可以这样使用它，可以传递很多东西，也可以有嵌套的堆栈。\n\n<stack size=\"4\">\n    <div>hello</div>\n    <stack size=\"4\">\n        <div>hello</div>\n        <div>hello</div>\n    </stack>\n</stack>\n\n\n渲染结果是它将包裹每个子对象，直接的孩子给了它一些 margin。当你像这样嵌套，你得到了嵌套的边距布局。有点像 html 中 ul 和 ol 的默认样式。\n\n因此想要的渲染输出会是...\n\n<div class=\"stack\">\n    <div class=\"mt-4\">\n        <div>hello</div>\n    </div>\n    <div class=\"mt-4\">\n        <div class=\"stack\">\n            <div class=\"mt-4\">\n                <div>hello</div>\n                <div>hello</div>\n            </div>\n        </div>\n    </div>\n</div>\n\n\n事实上，每个都会被包起来的。mt-4 是一个功能类，它将给它一些边距，然后你会有另一个 mt-4，又包了另一个 stack。这个列表也是一样的。\n\n好吧，所以它只是制造了一堆包裹元素，唯一的目的是给予一些额外的填充或边距用于布局。\n\n那么，我们怎么做，比如说，在里面使用一个普通的基于模板的语法？因为你想要的就是这些在同一个插槽内。它们都是默认插槽。\n\n\n\n对于模板语法，只有你能做的就是渲染这个部分，一炮而过。\n\n所以在模板里面，没有机会程序化的遍历插槽内的每个项目，然后把它们变成别的东西。但是你可以用渲染函数来实现。所以，如果我们要实现这样的堆栈组件，我们可以像这样：\n\nimport { h } from 'vue'\n\nconst stack = {\n\trender() {\n        const slot = this.$slots.default\n        \t? this.$slots.default({...})\n        \t: []\n        return h('div', { class: 'stack' }, slot.map(child => {\n            return h('div', { class: `mt-${this.$props.size}` }, [\n                child\n            ])\n        }))\n\t}\n}\n\n\n我们把孩子放在里面，所以我们用的是一个slot.map生成新的 vnode 列表，原来的子插槽被包装在里面。\n\n所以我认为这是一个很好的例子，当你创作这些底层的公用设施组件，有时你真的会遇到麻烦，这时渲染函数更有效。但话说回来，也需要了解每种方法的利弊。我们希望这样过一遍，所有这些都是为了让你更好地理解，在什么情况下应该使用模板或使用渲染函数。\n\n总的来说，从我的经验来看，这种情况在您创作可重用的功能组件时更常见。\n\n在日常开发中，你主要是在编写特性组件。模板通常是有效的方式。\n\n模板的好处是更简单，优化通过编译器优化，尤其当你有很多标记的时候。它的另一个好处是它更容易让设计师接管组件，并用 css 设计样式。\n\n因此，vue 提供了这两个选项，当情况出现的时候，以便您可以选择合适的工具。",charsets:{cjk:!0}},{title:"组件模板和样式",frontmatter:{},regularPath:"/mp/component-programming/template-style.html",relativePath:"mp/component-programming/template-style.md",key:"v-65b54a42",path:"/mp/component-programming/template-style.html",headers:[{level:2,title:"组件模板",slug:"组件模板",normalizedTitle:"组件模板",charIndex:2},{level:2,title:"模板数据绑定",slug:"模板数据绑定",normalizedTitle:"模板数据绑定",charIndex:490},{level:2,title:"组件 wxml 的 slot",slug:"组件-wxml-的-slot",normalizedTitle:"组件 wxml 的 slot",charIndex:920},{level:2,title:"组件样式",slug:"组件样式",normalizedTitle:"组件样式",charIndex:1700},{level:2,title:"组件样式隔离",slug:"组件样式隔离",normalizedTitle:"组件样式隔离",charIndex:2008},{level:2,title:"外部样式类",slug:"外部样式类",normalizedTitle:"外部样式类",charIndex:3785},{level:2,title:"引用页面或父组件的样式",slug:"引用页面或父组件的样式",normalizedTitle:"引用页面或父组件的样式",charIndex:4582},{level:2,title:"虚拟化组件节点",slug:"虚拟化组件节点",normalizedTitle:"虚拟化组件节点",charIndex:5e3}],headersStr:"组件模板 模板数据绑定 组件 wxml 的 slot 组件样式 组件样式隔离 外部样式类 引用页面或父组件的样式 虚拟化组件节点",content:'# 组件模板和样式\n\n类似于页面，自定义组件拥有自己的 wxml 模板和 wxss 样式。\n\n\n# 组件模板\n\n组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。\n\n在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 组件模板 --\x3e\n<view class="wrapper">\n  <view>这里是组件的内部节点</view>\n  <slot></slot>\n</view>\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name>\n    \x3c!-- 这部分内容将被放置在组件 <slot> 的位置上 --\x3e\n    <view>这里是插入到组件slot中的内容</view>\n  </component-tag-name>\n</view>\n\n\n注意，在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为抽象节点。\n\n\n# 模板数据绑定\n\n与普通的 WXML 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">\n    \x3c!-- 这部分内容将被放置在组件 <slot> 的位置上 --\x3e\n    <view>这里是插入到组件slot中的内容</view>\n  </component-tag-name>\n</view>\n\n\n在以上例子中，组件的属性 propA 和 propB 将收到页面传递的数据。页面可以通过 setData 来改变绑定的数据字段。\n\n注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 WXML 中直接调用，只能传递给子组件）。\n\n\n# 组件 wxml 的 slot\n\n在组件的 wxml 中可以包含 slot 节点，用于承载组件使用者提供的 wxml 结构。\n\n默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。\n\nComponent({\n  options: {\n    multipleSlots: true // 在组件定义时的选项中启用多slot支持\n  },\n  properties: { /* ... */ },\n  methods: { /* ... */ }\n})\n\n\n此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。\n\n\x3c!-- 组件模板 --\x3e\n<view class="wrapper">\n  <slot name="before"></slot>\n  <view>这里是组件的内部细节</view>\n  <slot name="after"></slot>\n</view>\n\n\n使用时，用 slot 属性来将节点插入到不同的 slot 上。\n\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name>\n    \x3c!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 --\x3e\n    <view slot="before">这里是插入到组件slot name="before"中的内容</view>\n    \x3c!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 --\x3e\n    <view slot="after">这里是插入到组件slot name="after"中的内容</view>\n  </component-tag-name>\n</view>\n\n\n\n# 组件样式\n\n组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：\n\n * 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。\n * 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。\n * 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。\n * 继承样式，如 font 、 color ，会从组件外继承到组件内。\n * 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。\n\n#a { } /* 在组件中不能使用 */\n[a] { } /* 在组件中不能使用 */\nbutton { } /* 在组件中不能使用 */\n.a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */\n\n\n除此以外，组件可以指定它所在节点的默认样式，使用 :host 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。\n\n代码示例：\n\n在开发者工具中预览效果\n\n/* 组件 custom-component.wxss */\n:host {\n  color: yellow;\n}\n\x3c!-- 页面的 WXML --\x3e\n<custom-component>这段文本是黄色的</custom-component>\n\n\n\n# 组件样式隔离\n\n默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：\n\n * app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。\n * 指定特殊的样式隔离选项 styleIsolation 。\n\nComponent({\n  options: {\n    styleIsolation: \'isolated\'\n  }\n})\n\n\n在开发者工具中预览效果\n\nstyleIsolation 选项从基础库版本 2.6.5 开始支持。它支持以下取值：\n\n * isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；\n * apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；\n * shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）\n\n使用后两者时，请务必注意组件间样式的相互影响。\n\n如果这个 Component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：\n\n * page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；\n * page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；\n * page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。\n\n从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleIsolation （这样就不需在 js 文件的 options 中再配置）。例如：\n\n{\n  "styleIsolation": "isolated"\n}\n\n\n此外，小程序基础库版本 2.2.3 以上支持 addGlobalClass 选项，即在 Component 的 options 中设置 addGlobalClass: true 。 这个选项等价于设置 styleIsolation: apply-shared ，但设置了 styleIsolation 选项后这个选项会失效。\n\n代码示例：\n\n在开发者工具中预览效果\n\n/* 组件 custom-component.js */\nComponent({\n  options: {\n    addGlobalClass: true,\n  }\n})\n\x3c!-- 组件 custom-component.wxml --\x3e\n<text class="red-text">这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text>\n/* app.wxss */\n.red-text {\n  color: red;\n}\n\n\n\n# 外部样式类\n\n> 基础库 1.9.90 开始支持，低版本需做兼容处理。\n\n有时，组件希望接受外部传入的样式类。此时可以在 Component 中用 externalClasses 定义段定义若干个外部样式类。\n\n这个特性可以用于实现类似于 view 组件的 hover-class 属性：页面可以提供一个样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。\n\n注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。\n\n代码示例：\n\n/* 组件 custom-component.js */\nComponent({\n  externalClasses: [\'my-class\']\n})\n\x3c!-- 组件 custom-component.wxml --\x3e\n<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>\n\n\n这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 页面的 WXML --\x3e\n<custom-component my-class="red-text" />\n<custom-component my-class="large-text" />\n\x3c!-- 以下写法需要基础库版本 2.7.1 以上 --\x3e\n<custom-component my-class="red-text large-text" />\n.red-text {\n  color: red;\n}\n.large-text {\n  font-size: 1.5em;\n}\n\n\n\n# 引用页面或父组件的样式\n\n> 基础库 2.9.2 开始支持，低版本需做兼容处理。\n\n即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。\n\n例如，如果在页面 wxss 中定义了：\n\n.blue-text {\n  color: blue;\n}\n\n\n在这个组件中可以使用 ~ 来引用这个类的样式：\n\n<view class="~blue-text"> 这段文本是蓝色的 </view>\n\n\n如果在一个组件的父组件 wxss 中定义了：\n\n.red-text {\n  color: red;\n}\n\n\n在这个组件中可以使用 ^ 来引用这个类的样式：\n\n<view class="^red-text"> 这段文本是红色的 </view>\n\n\n也可以连续使用多个 ^ 来引用祖先组件中的样式。\n\n注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。\n\n\n# 虚拟化组件节点\n\n> 基础库 2.11.2 开始支持，低版本需做兼容处理。\n\n默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置 class style 、动画、 flex 布局等，就如同普通的 view 组件节点一样。\n\n\x3c!-- 页面的 WXML --\x3e\n<view style="display: flex">\n  \x3c!-- 默认情况下，这是一个普通的节点 --\x3e\n  <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>\n</view>\n\n\n但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。\n\n这种情况下，可以将这个自定义组件设置为“虚拟的”：\n\nComponent({\n  options: {\n    virtualHost: true\n  },\n  properties: {\n    style: { // 定义 style 属性可以拿到 style 属性上设置的值\n      type: String,\n    }\n  },\n  externalClasses: [\'class\'], // 可以将 class 设为 externalClasses\n})\n\n\n这样，可以将 flex 放入自定义组件内：\n\n\x3c!-- 页面的 WXML --\x3e\n<view style="display: flex">\n  \x3c!-- 如果设置了 virtualHost ，节点上的样式将失效 --\x3e\n  <custom-component style="color: blue">不是蓝色的</custom-component>\n</view>\n\x3c!-- custom-component.wxml --\x3e\n<view style="flex: 1">\n  满宽的\n  <slot></slot>\n</view>\n\n\n需要注意的是，自定义组件节点上的 class style 和动画将不再生效，但仍可以：\n\n * 将 style 定义成 properties 属性来获取 style 上设置的值；\n * 将 class 定义成 externalClasses 外部样式类使得自定义组件 wxml 可以使用 class 值。\n\n代码示例：\n\n在开发者工具中预览效果',normalizedContent:'# 组件模板和样式\n\n类似于页面，自定义组件拥有自己的 wxml 模板和 wxss 样式。\n\n\n# 组件模板\n\n组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。\n\n在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 组件模板 --\x3e\n<view class="wrapper">\n  <view>这里是组件的内部节点</view>\n  <slot></slot>\n</view>\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name>\n    \x3c!-- 这部分内容将被放置在组件 <slot> 的位置上 --\x3e\n    <view>这里是插入到组件slot中的内容</view>\n  </component-tag-name>\n</view>\n\n\n注意，在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为抽象节点。\n\n\n# 模板数据绑定\n\n与普通的 wxml 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name prop-a="{{datafielda}}" prop-b="{{datafieldb}}">\n    \x3c!-- 这部分内容将被放置在组件 <slot> 的位置上 --\x3e\n    <view>这里是插入到组件slot中的内容</view>\n  </component-tag-name>\n</view>\n\n\n在以上例子中，组件的属性 propa 和 propb 将收到页面传递的数据。页面可以通过 setdata 来改变绑定的数据字段。\n\n注意：这样的数据绑定只能传递 json 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 wxml 中直接调用，只能传递给子组件）。\n\n\n# 组件 wxml 的 slot\n\n在组件的 wxml 中可以包含 slot 节点，用于承载组件使用者提供的 wxml 结构。\n\n默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。\n\ncomponent({\n  options: {\n    multipleslots: true // 在组件定义时的选项中启用多slot支持\n  },\n  properties: { /* ... */ },\n  methods: { /* ... */ }\n})\n\n\n此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。\n\n\x3c!-- 组件模板 --\x3e\n<view class="wrapper">\n  <slot name="before"></slot>\n  <view>这里是组件的内部细节</view>\n  <slot name="after"></slot>\n</view>\n\n\n使用时，用 slot 属性来将节点插入到不同的 slot 上。\n\n\x3c!-- 引用组件的页面模板 --\x3e\n<view>\n  <component-tag-name>\n    \x3c!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 --\x3e\n    <view slot="before">这里是插入到组件slot name="before"中的内容</view>\n    \x3c!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 --\x3e\n    <view slot="after">这里是插入到组件slot name="after"中的内容</view>\n  </component-tag-name>\n</view>\n\n\n\n# 组件样式\n\n组件对应 wxss 文件的样式，只对组件wxml内的节点生效。编写组件样式时，需要注意以下几点：\n\n * 组件和引用组件的页面不能使用id选择器（#a）、属性选择器（[a]）和标签名选择器，请改用class选择器。\n * 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。\n * 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。\n * 继承样式，如 font 、 color ，会从组件外继承到组件内。\n * 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。\n\n#a { } /* 在组件中不能使用 */\n[a] { } /* 在组件中不能使用 */\nbutton { } /* 在组件中不能使用 */\n.a > .b { } /* 除非 .a 是 view 组件节点，否则不一定会生效 */\n\n\n除此以外，组件可以指定它所在节点的默认样式，使用 :host 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。\n\n代码示例：\n\n在开发者工具中预览效果\n\n/* 组件 custom-component.wxss */\n:host {\n  color: yellow;\n}\n\x3c!-- 页面的 wxml --\x3e\n<custom-component>这段文本是黄色的</custom-component>\n\n\n\n# 组件样式隔离\n\n默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：\n\n * app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。\n * 指定特殊的样式隔离选项 styleisolation 。\n\ncomponent({\n  options: {\n    styleisolation: \'isolated\'\n  }\n})\n\n\n在开发者工具中预览效果\n\nstyleisolation 选项从基础库版本 2.6.5 开始支持。它支持以下取值：\n\n * isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；\n * apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；\n * shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）\n\n使用后两者时，请务必注意组件间样式的相互影响。\n\n如果这个 component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：\n\n * page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；\n * page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；\n * page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。\n\n从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleisolation （这样就不需在 js 文件的 options 中再配置）。例如：\n\n{\n  "styleisolation": "isolated"\n}\n\n\n此外，小程序基础库版本 2.2.3 以上支持 addglobalclass 选项，即在 component 的 options 中设置 addglobalclass: true 。 这个选项等价于设置 styleisolation: apply-shared ，但设置了 styleisolation 选项后这个选项会失效。\n\n代码示例：\n\n在开发者工具中预览效果\n\n/* 组件 custom-component.js */\ncomponent({\n  options: {\n    addglobalclass: true,\n  }\n})\n\x3c!-- 组件 custom-component.wxml --\x3e\n<text class="red-text">这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text>\n/* app.wxss */\n.red-text {\n  color: red;\n}\n\n\n\n# 外部样式类\n\n> 基础库 1.9.90 开始支持，低版本需做兼容处理。\n\n有时，组件希望接受外部传入的样式类。此时可以在 component 中用 externalclasses 定义段定义若干个外部样式类。\n\n这个特性可以用于实现类似于 view 组件的 hover-class 属性：页面可以提供一个样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。\n\n注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。\n\n代码示例：\n\n/* 组件 custom-component.js */\ncomponent({\n  externalclasses: [\'my-class\']\n})\n\x3c!-- 组件 custom-component.wxml --\x3e\n<custom-component class="my-class">这段文本的颜色由组件外的 class 决定</custom-component>\n\n\n这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。\n\n代码示例：\n\n在开发者工具中预览效果\n\n\x3c!-- 页面的 wxml --\x3e\n<custom-component my-class="red-text" />\n<custom-component my-class="large-text" />\n\x3c!-- 以下写法需要基础库版本 2.7.1 以上 --\x3e\n<custom-component my-class="red-text large-text" />\n.red-text {\n  color: red;\n}\n.large-text {\n  font-size: 1.5em;\n}\n\n\n\n# 引用页面或父组件的样式\n\n> 基础库 2.9.2 开始支持，低版本需做兼容处理。\n\n即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。\n\n例如，如果在页面 wxss 中定义了：\n\n.blue-text {\n  color: blue;\n}\n\n\n在这个组件中可以使用 ~ 来引用这个类的样式：\n\n<view class="~blue-text"> 这段文本是蓝色的 </view>\n\n\n如果在一个组件的父组件 wxss 中定义了：\n\n.red-text {\n  color: red;\n}\n\n\n在这个组件中可以使用 ^ 来引用这个类的样式：\n\n<view class="^red-text"> 这段文本是红色的 </view>\n\n\n也可以连续使用多个 ^ 来引用祖先组件中的样式。\n\n注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。\n\n\n# 虚拟化组件节点\n\n> 基础库 2.11.2 开始支持，低版本需做兼容处理。\n\n默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置 class style 、动画、 flex 布局等，就如同普通的 view 组件节点一样。\n\n\x3c!-- 页面的 wxml --\x3e\n<view style="display: flex">\n  \x3c!-- 默认情况下，这是一个普通的节点 --\x3e\n  <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>\n</view>\n\n\n但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。\n\n这种情况下，可以将这个自定义组件设置为“虚拟的”：\n\ncomponent({\n  options: {\n    virtualhost: true\n  },\n  properties: {\n    style: { // 定义 style 属性可以拿到 style 属性上设置的值\n      type: string,\n    }\n  },\n  externalclasses: [\'class\'], // 可以将 class 设为 externalclasses\n})\n\n\n这样，可以将 flex 放入自定义组件内：\n\n\x3c!-- 页面的 wxml --\x3e\n<view style="display: flex">\n  \x3c!-- 如果设置了 virtualhost ，节点上的样式将失效 --\x3e\n  <custom-component style="color: blue">不是蓝色的</custom-component>\n</view>\n\x3c!-- custom-component.wxml --\x3e\n<view style="flex: 1">\n  满宽的\n  <slot></slot>\n</view>\n\n\n需要注意的是，自定义组件节点上的 class style 和动画将不再生效，但仍可以：\n\n * 将 style 定义成 properties 属性来获取 style 上设置的值；\n * 将 class 定义成 externalclasses 外部样式类使得自定义组件 wxml 可以使用 class 值。\n\n代码示例：\n\n在开发者工具中预览效果',charsets:{cjk:!0}},{title:"App 实例",frontmatter:{},regularPath:"/mp/get-started/app-instance.html",relativePath:"mp/get-started/app-instance.md",key:"v-329dab7c",path:"/mp/get-started/app-instance.html",headers:[{level:2,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:13},{level:2,title:"生命周期方法",slug:"生命周期方法",normalizedTitle:"生命周期方法",charIndex:544},{level:2,title:"小程序运行机制",slug:"小程序运行机制",normalizedTitle:"小程序运行机制",charIndex:1661},{level:3,title:"生命周期过程",slug:"生命周期过程",normalizedTitle:"生命周期过程",charIndex:1707},{level:3,title:"小程序冷启动的页面",slug:"小程序冷启动的页面",normalizedTitle:"小程序冷启动的页面",charIndex:2832},{level:3,title:"小程序热启动的页面",slug:"小程序热启动的页面",normalizedTitle:"小程序热启动的页面",charIndex:3596},{level:3,title:"退出状态",slug:"退出状态",normalizedTitle:"退出状态",charIndex:3464},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:1166}],headersStr:"概要 生命周期方法 小程序运行机制 生命周期过程 小程序冷启动的页面 小程序热启动的页面 退出状态 注意事项",content:'# App 实例\n\n\n# 概要\n\n每个小程序都需要在 app.js 中调用 App 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。\n\n// app.js\nApp({\n  onLaunch (options) {\n    // Do something initial when launch.\n  },\n  onShow (options) {\n    // Do something when show.\n  },\n  onHide () {\n    // Do something when hide.\n  },\n  onError (msg) {\n    console.log(msg)\n  },\n  globalData: \'I am global data\'\n})\n\n\n整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。\n\n// xxx.js\nconst appInstance = getApp()\nconsole.log(appInstance.globalData) // I am global data\n\n\n\n# 生命周期方法\n\n属性                     类型         默认值   必填   说明                                                        最低版本\nonLaunch               function         否    小程序初始化完成时触发，全局只触发一次。参数也可以使用 wx.getLaunchOptionsSync 获取。   \nonShow                 function         否    小程序启动，或从后台进入前台显示时触发。也可以使用 wx.onAppShow 绑定监听。              \nonHide                 function         否    小程序从前台进入后台时触发。也可以使用 wx.onAppHide 绑定监听。                    \nonError                function         否    小程序发生脚本错误或 API 调用报错时触发。也可以使用 wx.onError 绑定监听。             \nonPageNotFound         function         否    小程序要打开的页面不存在时触发。也可以使用 wx.onPageNotFound 绑定监听。注意事项请参考      1.9.90\n                                             wx.onPageNotFound。\nonUnhandledRejection   function         否    小程序有未处理的 Promise 拒绝时触发。也可以使用 wx.onUnhandledRejection      2.10.0\n                                             绑定监听。注意事项请参考 wx.onUnhandledRejection。\nonThemeChange          function         否    系统切换主题时触发。也可以使用 wx.onThemeChange 绑定监听。                    2.11.0\n其他                     any              否    开发者可以添加任意的函数或数据变量到 Object 参数中，用 this 可以访问                 \n\n\n# 小程序运行机制\n\n提示\n\n这一节的内容对于初次阅读者不是必须的，你可以选择先跳过它\n\n\n# 生命周期过程\n\n小程序从启动到最终被销毁，会经历很多不同的状态，小程序在不同状态下会有不同的表现。\n\n\n\n# 小程序启动\n\n从用户认知的角度看，广义的小程序启动可以分为两种情况，一种是冷启动，一种是热启动。\n\n * 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。\n * 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。\n\n从小程序生命周期的角度来看，我们一般讲的「启动」专指冷启动，热启动一般被称为后台切前台。\n\n# 前台与后台\n\n小程序启动后，界面被展示给用户，此时小程序处于「前台」状态。\n\n当用户「关闭」小程序时，小程序并没有真正被关闭，而是进入了「后台」状态，此时小程序还可以短暂运行一小段时间，但部分 API 的使用会收到限制。切后台的方式包括但不限于以下几种：\n\n * 点击右上角胶囊按钮离开小程序\n * iOS 从屏幕左侧右滑离开小程序\n * 安卓点击返回键离开小程序\n * 小程序前台运行时直接把微信切后台（手势或 Home 键）\n * 小程序前台运行时直接锁屏\n\n当用户再次进入微信并打开小程序，小程序又会重新进入「前台」状态。\n\n# 挂起\n\n小程序进入「后台」状态一段时间后（目前是 5 秒），微信会停止小程序 JS 线程的执行，小程序进入「挂起」状态。此时小程序的内存状态会被保留，但开发者代码执行会停止，事件和接口回调会在小程序再次进入「前台」时触发。\n\n当开发者使用了后台音乐播放、后台地理位置等能力时，小程序可以在「后台」持续运行，不会进入到「挂起」状态\n\n# 小程序销毁\n\n如果用户很久没有使用小程序，或者系统资源紧张，小程序会被「销毁」，即完全终止运行。具体而言包括以下几种情形：\n\n * 当小程序进入后台并被「挂起」后，如果很长时间（目前是 30 分钟）都未再次进入前台，小程序会被销毁。\n * 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。\n   * 在 iOS 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。\n   * 建议小程序在必要时使用 wx.onMemoryWarning 监听内存告警事件，进行必要的内存清理。\n\n> 基础库 1.1.0 及以上，1.4.0 以下版本: 当用户从扫一扫、转发等入口（场景值为1007, 1008, 1011, 1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。\n\n\n# 小程序冷启动的页面\n\n小程序冷启动时，打开的页面有以下情况\n\n * （A 类场景）若启动的场景中不带 path\n   * 基础库 2.8.0 以下版本，进入首页\n   * 基础库 2.8.0 及以上版本遵循「重新启动策略」，可能是首页或上次退出的页面\n * （B 类场景）若启动的场景中带有 path，则启动进入对应 path 的页面\n\n# 重新启动策略\n\n> 基础库 2.8.0 开始支持，低版本需做兼容处理。\n\n小程序冷启动时，如果启动时不带 path（A 类场景），默认情况下将会进入小程序的首页。 在页面对应的 json 文件中（也可以全局配置在 app.json 的 window 段中），指定 restartStrategy 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 A 类场景的冷启动可以回到这个页面。\n\n代码示例：\n\n{\n  "restartStrategy": "homePage"\n}\n\n\nrestartStrategy 可选值：\n\n可选值                     含义\nhomePage                （默认值）如果从这个页面退出小程序，下次将从首页冷启动\nhomePageAndLatestPage   如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）\n\n注意：即使不配置为 homePage ，小程序如果退出过久（当前默认一天时间，可以使用退出状态来调整），下次冷启动时也将不再遵循 restartStrategy 的配置，而是直接从首页冷启动。\n\n无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用退出状态。\n\n\n# 小程序热启动的页面\n\n小程序冷启动时，打开的页面有以下情况\n\n * （A 类场景）若启动的场景中不带 path，则保留上次的浏览的状态\n * （B 类场景）若启动的场景中带有 path，则 relaunch 到对应 path 的页面\n\nA 类场景常见的有下列场景值：\n\n场景值ID   说明\n1001    发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）\n1003    星标小程序列表\n1023    系统桌面小图标打开小程序\n1038    从其他小程序返回小程序\n1056    聊天顶部音乐播放器右上角菜单，打开小程序\n1080    客服会话菜单小程序入口，打开小程序\n1083    公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）\n1089    聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）\n1090    长按小程序右上角菜单，打开小程序\n1103    发现-小程序主入口我的小程序，打开小程序\n1104    聊天主界面下拉，从我的小程序，打开小程序\n1113    安卓手机负一屏，打开小程序\n1114    安卓手机侧边栏，打开小程序\n1117    后台运行小程序的管理页中，打开小程序\n\n\n# 退出状态\n\n> 基础库 2.7.4 开始支持，低版本需做兼容处理。\n\n每当小程序可能被销毁之前，页面回调函数 onSaveExitState 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 exitState 获得这些已保存数据。\n\n代码示例：\n\n{\n  "restartStrategy": "homePageAndLatestPage"\n}\nPage({\n  onLoad: function() {\n    var prevExitState = this.exitState // 尝试获得上一次退出前 onSaveExitState 保存的数据\n    if (prevExitState !== undefined) { // 如果是根据 restartStrategy 配置进行的冷启动，就可以获取到\n      prevExitState.myDataField === \'myData\' \n    }\n  },\n  onSaveExitState: function() {\n    var exitState = { myDataField: \'myData\' } // 需要保存的数据\n    return {\n      data: exitState,\n      expireTimeStamp: Date.now() + 24 * 60 * 60 * 1000 // 超时时刻\n    }\n  }\n})\n\n\nonSaveExitState 返回值可以包含两项：\n\n字段名               类型       含义\ndata              Any      需要保存的数据（只能是 JSON 兼容的数据）\nexpireTimeStamp   Number   超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)\n\n一个更完整的示例：在开发者工具中预览效果\n\n\n# 注意事项\n\n * 如果超过 expireTimeStamp ，保存的数据将被丢弃，且冷启动时不遵循 restartStrategy 的配置，而是直接从首页冷启动。\n * expireTimeStamp 有可能被自动提前，如微信客户端需要清理数据的时候。\n * 在小程序存活期间， onSaveExitState 可能会被多次调用，此时以最后一次的调用结果作为最终结果。\n * 在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循 restartStrategy 的配置，而是直接从首页冷启动。',normalizedContent:'# app 实例\n\n\n# 概要\n\n每个小程序都需要在 app.js 中调用 app 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。\n\n// app.js\napp({\n  onlaunch (options) {\n    // do something initial when launch.\n  },\n  onshow (options) {\n    // do something when show.\n  },\n  onhide () {\n    // do something when hide.\n  },\n  onerror (msg) {\n    console.log(msg)\n  },\n  globaldata: \'i am global data\'\n})\n\n\n整个小程序只有一个 app 实例，是全部页面共享的。开发者可以通过 getapp 方法获取到全局唯一的 app 实例，获取app上的数据或调用开发者注册在 app 上的函数。\n\n// xxx.js\nconst appinstance = getapp()\nconsole.log(appinstance.globaldata) // i am global data\n\n\n\n# 生命周期方法\n\n属性                     类型         默认值   必填   说明                                                        最低版本\nonlaunch               function         否    小程序初始化完成时触发，全局只触发一次。参数也可以使用 wx.getlaunchoptionssync 获取。   \nonshow                 function         否    小程序启动，或从后台进入前台显示时触发。也可以使用 wx.onappshow 绑定监听。              \nonhide                 function         否    小程序从前台进入后台时触发。也可以使用 wx.onapphide 绑定监听。                    \nonerror                function         否    小程序发生脚本错误或 api 调用报错时触发。也可以使用 wx.onerror 绑定监听。             \nonpagenotfound         function         否    小程序要打开的页面不存在时触发。也可以使用 wx.onpagenotfound 绑定监听。注意事项请参考      1.9.90\n                                             wx.onpagenotfound。\nonunhandledrejection   function         否    小程序有未处理的 promise 拒绝时触发。也可以使用 wx.onunhandledrejection      2.10.0\n                                             绑定监听。注意事项请参考 wx.onunhandledrejection。\nonthemechange          function         否    系统切换主题时触发。也可以使用 wx.onthemechange 绑定监听。                    2.11.0\n其他                     any              否    开发者可以添加任意的函数或数据变量到 object 参数中，用 this 可以访问                 \n\n\n# 小程序运行机制\n\n提示\n\n这一节的内容对于初次阅读者不是必须的，你可以选择先跳过它\n\n\n# 生命周期过程\n\n小程序从启动到最终被销毁，会经历很多不同的状态，小程序在不同状态下会有不同的表现。\n\n\n\n# 小程序启动\n\n从用户认知的角度看，广义的小程序启动可以分为两种情况，一种是冷启动，一种是热启动。\n\n * 冷启动：如果用户首次打开，或小程序销毁后被用户再次打开，此时小程序需要重新加载启动，即冷启动。\n * 热启动：如果用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时小程序并未被销毁，只是从后台状态进入前台状态，这个过程就是热启动。\n\n从小程序生命周期的角度来看，我们一般讲的「启动」专指冷启动，热启动一般被称为后台切前台。\n\n# 前台与后台\n\n小程序启动后，界面被展示给用户，此时小程序处于「前台」状态。\n\n当用户「关闭」小程序时，小程序并没有真正被关闭，而是进入了「后台」状态，此时小程序还可以短暂运行一小段时间，但部分 api 的使用会收到限制。切后台的方式包括但不限于以下几种：\n\n * 点击右上角胶囊按钮离开小程序\n * ios 从屏幕左侧右滑离开小程序\n * 安卓点击返回键离开小程序\n * 小程序前台运行时直接把微信切后台（手势或 home 键）\n * 小程序前台运行时直接锁屏\n\n当用户再次进入微信并打开小程序，小程序又会重新进入「前台」状态。\n\n# 挂起\n\n小程序进入「后台」状态一段时间后（目前是 5 秒），微信会停止小程序 js 线程的执行，小程序进入「挂起」状态。此时小程序的内存状态会被保留，但开发者代码执行会停止，事件和接口回调会在小程序再次进入「前台」时触发。\n\n当开发者使用了后台音乐播放、后台地理位置等能力时，小程序可以在「后台」持续运行，不会进入到「挂起」状态\n\n# 小程序销毁\n\n如果用户很久没有使用小程序，或者系统资源紧张，小程序会被「销毁」，即完全终止运行。具体而言包括以下几种情形：\n\n * 当小程序进入后台并被「挂起」后，如果很长时间（目前是 30 分钟）都未再次进入前台，小程序会被销毁。\n * 当小程序占用系统资源过高，可能会被系统销毁或被微信客户端主动回收。\n   * 在 ios 上，当微信客户端在一定时间间隔内连续收到系统内存告警时，会根据一定的策略，主动销毁小程序，并提示用户 「运行内存不足，请重新打开该小程序」。具体策略会持续进行调整优化。\n   * 建议小程序在必要时使用 wx.onmemorywarning 监听内存告警事件，进行必要的内存清理。\n\n> 基础库 1.1.0 及以上，1.4.0 以下版本: 当用户从扫一扫、转发等入口（场景值为1007, 1008, 1011, 1025）进入小程序，且没有置顶小程序的情况下退出，小程序会被销毁。\n\n\n# 小程序冷启动的页面\n\n小程序冷启动时，打开的页面有以下情况\n\n * （a 类场景）若启动的场景中不带 path\n   * 基础库 2.8.0 以下版本，进入首页\n   * 基础库 2.8.0 及以上版本遵循「重新启动策略」，可能是首页或上次退出的页面\n * （b 类场景）若启动的场景中带有 path，则启动进入对应 path 的页面\n\n# 重新启动策略\n\n> 基础库 2.8.0 开始支持，低版本需做兼容处理。\n\n小程序冷启动时，如果启动时不带 path（a 类场景），默认情况下将会进入小程序的首页。 在页面对应的 json 文件中（也可以全局配置在 app.json 的 window 段中），指定 restartstrategy 配置项可以改变这个默认的行为，使得从某个页面退出后，下次 a 类场景的冷启动可以回到这个页面。\n\n代码示例：\n\n{\n  "restartstrategy": "homepage"\n}\n\n\nrestartstrategy 可选值：\n\n可选值                     含义\nhomepage                （默认值）如果从这个页面退出小程序，下次将从首页冷启动\nhomepageandlatestpage   如果从这个页面退出小程序，下次冷启动后立刻加载这个页面，页面的参数保持不变（不可用于 tab 页）\n\n注意：即使不配置为 homepage ，小程序如果退出过久（当前默认一天时间，可以使用退出状态来调整），下次冷启动时也将不再遵循 restartstrategy 的配置，而是直接从首页冷启动。\n\n无论如何，页面中的状态并不会被保留，如输入框中的文本内容、 checkbox 的勾选状态等都不会还原。如果需要还原或部分还原，需要利用退出状态。\n\n\n# 小程序热启动的页面\n\n小程序冷启动时，打开的页面有以下情况\n\n * （a 类场景）若启动的场景中不带 path，则保留上次的浏览的状态\n * （b 类场景）若启动的场景中带有 path，则 relaunch 到对应 path 的页面\n\na 类场景常见的有下列场景值：\n\n场景值id   说明\n1001    发现栏小程序主入口，「最近使用」列表（基础库2.2.4版本起包含「我的小程序」列表）\n1003    星标小程序列表\n1023    系统桌面小图标打开小程序\n1038    从其他小程序返回小程序\n1056    聊天顶部音乐播放器右上角菜单，打开小程序\n1080    客服会话菜单小程序入口，打开小程序\n1083    公众号会话菜单小程序入口 ，打开小程序（只有腾讯客服小程序有）\n1089    聊天主界面下拉，打开小程序/微信聊天主界面下拉，「最近使用」栏（基础库2.2.4版本起包含「我的小程序」栏）\n1090    长按小程序右上角菜单，打开小程序\n1103    发现-小程序主入口我的小程序，打开小程序\n1104    聊天主界面下拉，从我的小程序，打开小程序\n1113    安卓手机负一屏，打开小程序\n1114    安卓手机侧边栏，打开小程序\n1117    后台运行小程序的管理页中，打开小程序\n\n\n# 退出状态\n\n> 基础库 2.7.4 开始支持，低版本需做兼容处理。\n\n每当小程序可能被销毁之前，页面回调函数 onsaveexitstate 会被调用。如果想保留页面中的状态，可以在这个回调函数中“保存”一些数据，下次启动时可以通过 exitstate 获得这些已保存数据。\n\n代码示例：\n\n{\n  "restartstrategy": "homepageandlatestpage"\n}\npage({\n  onload: function() {\n    var prevexitstate = this.exitstate // 尝试获得上一次退出前 onsaveexitstate 保存的数据\n    if (prevexitstate !== undefined) { // 如果是根据 restartstrategy 配置进行的冷启动，就可以获取到\n      prevexitstate.mydatafield === \'mydata\' \n    }\n  },\n  onsaveexitstate: function() {\n    var exitstate = { mydatafield: \'mydata\' } // 需要保存的数据\n    return {\n      data: exitstate,\n      expiretimestamp: date.now() + 24 * 60 * 60 * 1000 // 超时时刻\n    }\n  }\n})\n\n\nonsaveexitstate 返回值可以包含两项：\n\n字段名               类型       含义\ndata              any      需要保存的数据（只能是 json 兼容的数据）\nexpiretimestamp   number   超时时刻，在这个时刻后，保存的数据保证一定被丢弃，默认为 (当前时刻 + 1 天)\n\n一个更完整的示例：在开发者工具中预览效果\n\n\n# 注意事项\n\n * 如果超过 expiretimestamp ，保存的数据将被丢弃，且冷启动时不遵循 restartstrategy 的配置，而是直接从首页冷启动。\n * expiretimestamp 有可能被自动提前，如微信客户端需要清理数据的时候。\n * 在小程序存活期间， onsaveexitstate 可能会被多次调用，此时以最后一次的调用结果作为最终结果。\n * 在某些特殊情况下（如微信客户端直接被系统杀死），这个方法将不会被调用，下次冷启动也不遵循 restartstrategy 的配置，而是直接从首页冷启动。',charsets:{cjk:!0}},{title:"小程序代码构成",frontmatter:{},regularPath:"/mp/get-started/program-structure.html",relativePath:"mp/get-started/program-structure.md",key:"v-7ce715bc",path:"/mp/get-started/program-structure.html",headers:[{level:2,title:"JSON 配置",slug:"json-配置",normalizedTitle:"json 配置",charIndex:87},{level:3,title:"小程序配置 app.json",slug:"小程序配置-app-json",normalizedTitle:"小程序配置 app.json",charIndex:346},{level:3,title:"工具配置 project.config.json",slug:"工具配置-project-config-json",normalizedTitle:"工具配置 project.config.json",charIndex:856},{level:3,title:"页面配置 page.json",slug:"页面配置-page-json",normalizedTitle:"页面配置 page.json",charIndex:1150},{level:3,title:"JSON 语法",slug:"json-语法",normalizedTitle:"json 语法",charIndex:1404},{level:2,title:"WXML 模板",slug:"wxml-模板",normalizedTitle:"wxml 模板",charIndex:111},{level:2,title:"WXSS 样式",slug:"wxss-样式",normalizedTitle:"wxss 样式",charIndex:135},{level:2,title:"JS 逻辑交互",slug:"js-逻辑交互",normalizedTitle:"js 逻辑交互",charIndex:3754}],headersStr:"JSON 配置 小程序配置 app.json 工具配置 project.config.json 页面配置 page.json JSON 语法 WXML 模板 WXSS 样式 JS 逻辑交互",content:'# 小程序代码构成\n\n在上一章中，我们通过开发者工具快速创建了一个 QuickStart 项目。你可以留意到这个项目里边生成了不同类型的文件:\n\n 1. .json 后缀的 JSON 配置文件\n 2. .wxml 后缀的 WXML 模板文件\n 3. .wxss 后缀的 WXSS 样式文件\n 4. .js 后缀的 JS 脚本逻辑文件\n\n接下来我们分别看看这4种文件的作用。\n\n\n# JSON 配置\n\nJSON 是一种数据格式，并不是编程语言，在小程序中，JSON 扮演的静态配置的角色。\n\n我们可以看到在项目的根目录有一个 app.json 和 project.config.json，此外在 pages/logs 目录下还有一个 logs.json，我们依次来说明一下它们的用途。\n\n\n# 小程序配置 app.json\n\napp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 app.json 配置内容如下：\n\n{\n  "pages":[\n    "pages/index/index",\n    "pages/logs/logs"\n  ],\n  "window":{\n    "backgroundTextStyle":"light",\n    "navigationBarBackgroundColor": "#fff",\n    "navigationBarTitleText": "Weixin",\n    "navigationBarTextStyle":"black"\n  }\n}\n\n\n我们简单说一下这个配置各个项的含义:\n\n 1. pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。\n 2. window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。\n\n其他配置项细节可以参考文档 小程序的配置 app.json 。\n\n\n# 工具配置 project.config.json\n\n通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。\n\n考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。\n\n其他配置项细节可以参考文档 开发者工具的配置 。\n\n\n# 页面配置 page.json\n\n这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。\n\n如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。\n\n其他配置项细节可以参考文档 页面配置 。\n\n\n# JSON 语法\n\n这里说一下小程序里JSON配置的一些注意事项。\n\nJSON文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON 的 Key 必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。\n\nJSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。\n\n 1. 数字，包含浮点数和整数\n 2. 字符串，需要包裹在双引号中\n 3. Bool 值，true 或者 false\n 4. 数组，需要包裹在方括号中 []\n 5. 对象，需要包裹在大括号中 {}\n 6. Null\n\n还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错。\n\n\n# WXML 模板\n\n从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。\n\n同样道理，在小程序中也有同样的角色，其中 WXML 充当的就是类似 HTML 的角色。打开 pages/index/index.wxml，你会看到以下的内容:\n\n<view class="container">\n  <view class="userinfo">\n    <button wx:if="{{!hasUserInfo && canIUse}}"> 获取头像昵称 </button>\n    <block wx:else>\n      <image src="{{userInfo.avatarUrl}}" background-size="cover"></image>\n      <text class="userinfo-nickname">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class="usermotto">\n    <text class="user-motto">{{motto}}</text>\n  </view>\n</view>\n\n\n和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：\n\n 1. 标签名字有点不一样\n    \n    往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。\n    \n    从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。\n    \n    更多详细的组件讲述参考下个章节 小程序架构\n\n 2. 多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式\n    \n    在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。\n    \n    小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。\n    \n    WXML 是这么写 :\n    \n    <text>{{msg}}</text>\n    \n    \n    JS 只需要管理状态即可:\n    \n    this.setData({ msg: "Hello World" })\n    \n    \n    通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。\n\n更详细的文档可以参考 数据绑定与 WXML 模板、条件渲染 等章节。\n\n\n# WXSS 样式\n\nWXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。\n\n 1. 新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。\n 2. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。\n 3. 此外 WXSS 仅支持部分 CSS 选择器\n\n更详细的文档可以参考 样式与 WXSS 。\n\n\n# JS 逻辑交互\n\n一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。\n\n<view>{{ msg }}</view>\n<button bindtap="clickMe">点击我</button>\n\n\n点击 button 按钮的时候，我们希望把界面上 msg 显示成 "Hello World"，于是我们在 button 上声明一个属性: bindtap ，在 JS 文件里边声明了 clickMe 方法来响应这次点击操作：\n\nPage({\n  clickMe: function() {\n    this.setData({ msg: "Hello World" })\n  }\n})\n\n\n响应用户的操作就是这么简单，更详细的事件可以参考文档 事件处理 。\n\n此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 pages/index/index.js 就调用了 wx.getUserInfo 获取微信用户的头像和昵称，最后通过 setData 把获取到的信息显示到界面上。更多 API 可以参考文档 小程序的API 。\n\n通过这个章节，你了解了小程序涉及到的文件类型以及对应的角色，在下个章节中，我们把这一章所涉及到的文件通过 “小程序的框架” 给 “串” 起来，让他们都工作起来。',normalizedContent:'# 小程序代码构成\n\n在上一章中，我们通过开发者工具快速创建了一个 quickstart 项目。你可以留意到这个项目里边生成了不同类型的文件:\n\n 1. .json 后缀的 json 配置文件\n 2. .wxml 后缀的 wxml 模板文件\n 3. .wxss 后缀的 wxss 样式文件\n 4. .js 后缀的 js 脚本逻辑文件\n\n接下来我们分别看看这4种文件的作用。\n\n\n# json 配置\n\njson 是一种数据格式，并不是编程语言，在小程序中，json 扮演的静态配置的角色。\n\n我们可以看到在项目的根目录有一个 app.json 和 project.config.json，此外在 pages/logs 目录下还有一个 logs.json，我们依次来说明一下它们的用途。\n\n\n# 小程序配置 app.json\n\napp.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。quickstart 项目里边的 app.json 配置内容如下：\n\n{\n  "pages":[\n    "pages/index/index",\n    "pages/logs/logs"\n  ],\n  "window":{\n    "backgroundtextstyle":"light",\n    "navigationbarbackgroundcolor": "#fff",\n    "navigationbartitletext": "weixin",\n    "navigationbartextstyle":"black"\n  }\n}\n\n\n我们简单说一下这个配置各个项的含义:\n\n 1. pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。\n 2. window字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。\n\n其他配置项细节可以参考文档 小程序的配置 app.json 。\n\n\n# 工具配置 project.config.json\n\n通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。\n\n考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。\n\n其他配置项细节可以参考文档 开发者工具的配置 。\n\n\n# 页面配置 page.json\n\n这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。\n\n如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。\n\n其他配置项细节可以参考文档 页面配置 。\n\n\n# json 语法\n\n这里说一下小程序里json配置的一些注意事项。\n\njson文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。json 的 key 必须包裹在一个双引号中，在实践中，编写 json 的时候，忘了给 key 值加双引号或者是把双引号写成单引号是常见错误。\n\njson的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 javascript 中的 undefined。\n\n 1. 数字，包含浮点数和整数\n 2. 字符串，需要包裹在双引号中\n 3. bool 值，true 或者 false\n 4. 数组，需要包裹在方括号中 []\n 5. 对象，需要包裹在大括号中 {}\n 6. null\n\n还需要注意的是 json 文件中无法使用注释，试图添加注释将会引发报错。\n\n\n# wxml 模板\n\n从事过网页编程的人知道，网页编程采用的是 html + css + js 这样的组合，其中 html 是用来描述当前这个页面的结构，css 用来描述页面的样子，js 通常是用来处理这个页面和用户的交互。\n\n同样道理，在小程序中也有同样的角色，其中 wxml 充当的就是类似 html 的角色。打开 pages/index/index.wxml，你会看到以下的内容:\n\n<view class="container">\n  <view class="userinfo">\n    <button wx:if="{{!hasuserinfo && caniuse}}"> 获取头像昵称 </button>\n    <block wx:else>\n      <image src="{{userinfo.avatarurl}}" background-size="cover"></image>\n      <text class="userinfo-nickname">{{userinfo.nickname}}</text>\n    </block>\n  </view>\n  <view class="usermotto">\n    <text class="user-motto">{{motto}}</text>\n  </view>\n</view>\n\n\n和 html 非常相似，wxml 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：\n\n 1. 标签名字有点不一样\n    \n    往往写 html 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。\n    \n    从上边的例子可以看到，小程序的 wxml 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。\n    \n    更多详细的组件讲述参考下个章节 小程序架构\n\n 2. 多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式\n    \n    在网页的一般开发流程中，我们通常会通过 js 操作 dom (对应 html 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，js 会记录一些状态到 js 变量里边，同时通过 dom api 操控 dom 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 mvvm 的开发模式（例如 react, vue），提倡把渲染和逻辑分离。简单来说就是不要再让 js 直接操控 dom，js 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。\n    \n    小程序的框架也是用到了这个思路，如果你需要把一个 hello world 的字符串显示在界面上。\n    \n    wxml 是这么写 :\n    \n    <text>{{msg}}</text>\n    \n    \n    js 只需要管理状态即可:\n    \n    this.setdata({ msg: "hello world" })\n    \n    \n    通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。\n\n更详细的文档可以参考 数据绑定与 wxml 模板、条件渲染 等章节。\n\n\n# wxss 样式\n\nwxss 具有 css 大部分的特性，小程序在 wxss 也做了一些扩充和修改。\n\n 1. 新增了尺寸单位。在写 css 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。wxss 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。\n 2. 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。\n 3. 此外 wxss 仅支持部分 css 选择器\n\n更详细的文档可以参考 样式与 wxss 。\n\n\n# js 逻辑交互\n\n一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 js 脚本文件来处理用户的操作。\n\n<view>{{ msg }}</view>\n<button bindtap="clickme">点击我</button>\n\n\n点击 button 按钮的时候，我们希望把界面上 msg 显示成 "hello world"，于是我们在 button 上声明一个属性: bindtap ，在 js 文件里边声明了 clickme 方法来响应这次点击操作：\n\npage({\n  clickme: function() {\n    this.setdata({ msg: "hello world" })\n  }\n})\n\n\n响应用户的操作就是这么简单，更详细的事件可以参考文档 事件处理 。\n\n此外你还可以在 js 中调用小程序提供的丰富的 api，利用这些 api 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 quickstart 例子中，在 pages/index/index.js 就调用了 wx.getuserinfo 获取微信用户的头像和昵称，最后通过 setdata 把获取到的信息显示到界面上。更多 api 可以参考文档 小程序的api 。\n\n通过这个章节，你了解了小程序涉及到的文件类型以及对应的角色，在下个章节中，我们把这一章所涉及到的文件通过 “小程序的框架” 给 “串” 起来，让他们都工作起来。',charsets:{cjk:!0}},{title:"编译器和渲染器 API",frontmatter:{},regularPath:"/vue3-deep-dive/compiler-and-renderer-api.html",relativePath:"vue3-deep-dive/compiler-and-renderer-api.md",key:"v-647c498d",path:"/vue3-deep-dive/compiler-and-renderer-api.html",headersStr:null,content:"# 编译器和渲染器 API\n\n这就是我们所说的模板浏览器（https://vue-next-template-explorer.netlify.app）\n\n\n\n我们在 Vue 2 也有一个，但是 Vue 3 模板浏览器功能更加丰富。\n\n如您所见，左边是源模板，右边是生成的渲染函数代码。\n\n在开发过程中，实际上我用这个来调试编译器，所以如果我有什么事情不能如愿，我只是在源模板中粘贴，我可以直接看到代码生成了什么，看看出了什么问题。\n\n如果我们看一下模板浏览器，这里有很多选择：\n\n\n\n所以我们可以启用某些类型的优化，例如：\n\n如果我们有一个嵌套的 div，这个 div 是完全静态的，你可以打开这个（hoistStatic），然后看它是否确实被从渲染函数中提升，以便可以在每个渲染器上重用它。\n\n\n\n所以每次组件更新时，这个渲染函数将被调用。一旦一个节点被提升，它就会被创建一次。在渲染函数之外，在以后的每一次渲染中，它将在这里重新使用。这有两个好处：\n\n首先是避免重新创建对象，然后扔掉。另一个好处是在我们的模式算法中，当你看到两个节点在同一位置时，在严格平等的情况下，我们可以跳过它。因为我们知道它永远不会改变。所以，是的，有很多有趣的优化。\n\n我们做的另一个有趣的优化：\n\n当你有一个点击侦听器，我们可以注意到我们绑定了 click 侦听器，编译器会生成一个补丁标志。\n\n\n\n这个节点有动态 props 需要修补一下，以及动态 props 的名称，需要修补的是 onClick。通常使用简单的虚拟 DOM 渲染算法。\n\n不管有多少东西在 div 自身上，这整个对象必须作为一个整体来 diff。\n\n\n\n所以即使从模板中我们可以看到，这个 ID 实际上是静态的，永远不会改变。\n\n我们还需要穿过整个对象，只是为了确保它不会改变，因为运行时没有足够的信息来推断。\n\n但是，使用 Vue 3 的编译器，这个补丁（PROPS）和这个数组（[\"onClick\"]）结合在一起，为运行时提供足够的信息。\n\n好吧，所以有些 props 会改变的，但唯一可能改变的是 onClick，因为它和暴露在外的东西结合在一起，所以你可以决定在某个时间改变它。\n\n我们可以跳过此 props 上的对象枚举，忽略那些已经被编译器推断永远不会改变的 props。\n\n确切地说，这些是编译器生成的提示，以帮助运行时更高效，在手动编写的渲染函数中，这不是一件容易的事。因为分析 JavaScript 比分析模板困难得多。\n\n我们现在看到的是是生成的渲染函数，相比你自己写的代码总是更加的冗长。因为编译器总是优先考虑更加优化，更加明确。\n\n我们一会儿就会看到，这里有很多便利。当你自己使用 API 时，我们所提供的使它更容易和更流畅。\n\n所以我们看看这个点击处理程序：\n\n\n\n现在我们知道在这个节点上，每次被更新或被 diff。我们需要看一下 onClick 以确保它不会改变。但在很多情况下，当你绑定一个事件监听器。实际上，您并不打算更改事件处理程序。所以当你用 Vue3 时，有一个选项（cacheHandlers）是默认打开的。\n\n\n\n注意我们使用了一些智能 JavaScript 来缓存事件处理程序：我们把它变成一个内联函数，并在第一次渲染时将其缓存。因此在后续渲染中，我们将始终使用同一个内联处理程序，所以我们总是传递相同的函数，但是里面的函数会访问 ctx.onClick。它保证它总是最新的函数被调用。\n\n我们可以注意到补丁标志，onClick 数组不见了。这意味着现在这个 vnode，当我们试图修补它时，它实际上并不需要被修补，因为这是静态的。当它被调用时，此事件处理程序已缓存，它总是指向最新的 onClick。所以即使 onClick 下面发生了变化，我们不需要对 vnode 本身做任何事情，我们只找到了一次相同的事件处理程序，我们可以忘掉它。在修补过程中，现在可以完全跳过整个节点，这是另一个层次的优化。\n\n这一点尤其重要，因为在组件上如果要将事件处理程序添加到组件中，我们防止子组件不必要地重新渲染的最常见情况之一是指使用类似这里的内联事件处理程序。\n\n\n\n或者当你写 foo 的时候，你给它一个参数，这也是一个隐式的内联处理程序。\n\n\n\n所以所有这些在 Vue 2 中，对于这个组件，即使什么都没有改变，它仍然会导致子组件在父组件重新渲染时重新渲染。在大型应用中，这会引起连锁效应。因为你在向下传递函数，在每次渲染时，都会创建一个新的内联函数。会导致所有这些收到那个 prop 的子组件重新渲染。\n\n所以在 Vue 3 中使用句柄缓存，这基本上减少了很大的面积的，在大型组件树中发生不必要的渲染，所以这也是一个不错的性能改进。\n\n事实上，这也是 React 中一个很常见的陷阱。这就是为什么 React 中有一个名为 useMemo 的 API，或者叫 useCallback ，它们几乎是一样的。为了防止子组件重新渲染，允许开发人员手动缓存像这样的事件处理程序。\n\n但是在 Vue 3 中有了模板，我们可以为用户自动完成，所以你不需要去想它。\n\n> 块和 vnode 有什么区别？\n\n让我们回到这个例子：\n\n我们看到根 div 被创建了，就像块一样。所以我们有一个这样的临时结构，在右边，我们看到它被提升了，但我们暂时不要担心。\n\n\n\n想象一下这是一个手动写的非优化虚拟 DOM 树，在更新时，你要确保 DOM 结构是一致的。如果这是手动编写的，那么运行时就没有信息了。关于这个 DOM 树结构是否稳定，它不能做出任何假设，因为节点顺序可能已经改变，或者这个可以从 div 变成 p，对吗？\n\n当它是 JavaScript 时，任何事情都可能发生，所以运行时必须格外小心，它必须检查每个节点以确保它没有变成别的东西。如果有 props 的话就要把所有的 props 都区分开来，确保 props 没有改变。\n\n说到孩子（children）...\n\n\n\n事实上，它必须区分两个子数组以确保他们没有四处走动，或者没有新的孩子加入，或者孩子被删除。\n\n为了清楚起见，我们指向的是 HTML 代码，但实际上是一个虚拟 DOM 结构，看起来像 JSON。它是一堆 JavaScript 对象。\n\n如果我们有一个渲染函数并且我们要复制我们刚才看到的这个模板，我们最终会得到这样的结果。\n\nfunction render() {\n    return h('div', [\n        h('div', [\n            h('span', 'hello')\n        ])\n    ])\n}\n\n\n因此，您可以想象最终的底层数据结构，可能看起来更像这样：\n\nconst vdom = {\n    tag: 'div',\n    children: [\n        tag: 'div',\n        children: [{\n        \ttag: 'span',\n        \tchildren: 'hello'\n        }]\n    ]\n}\n\n\n所以当我们调用这个生成的 JavaScript 结构，看起来像这样简单的结构。\n\n渲染器的工作，更新时，它将有两个快照。像这样的虚拟 DOM 树，它的某些部分可能已经改变了。\n\n例如，从“hello”更新到“msg”。如果我们不提供更多的提示，渲染器并不真正知道发生了什么变化。所以它必须经过一个相对暴力的算法，以递归方式遍历整棵树，比较旧节点和新节点找出什么改变了。\n\n一般来说，在大多数情况下够快了。对于中型应用程序，您可能不会注意到任何性能瓶颈。因为现代 JavaScript 引擎处理普通对象优化得很好了。\n\n但是，当你有一个大型应用程序时，当你开始注意到最终这些小的迭代成本加起来。比如，当你点击某个东西时，也许你的应用程序中会有 10 个组件同时被触发再更新。这就是 JavaScript 成本开始增加的时候，这可能阻塞或卡顿你的应用程序。\n\n所以这就是人们开始了解如何手动优化组件树，避免不必要的重新渲染，这就是 Vue 的优势所在。所以我们添加了一些提示，以及如何实现这一目标的优化。\n\n让我们回到块。\n\n\n\n在这里，我们可以看到。但这可能不是一个完美的例子。因为这棵树实际上是静止的，所以被提升。\n\n但是想象一下，让我们在这里加一点信息。\n\n\n\n这会使这部分变为动态，整棵树都不能被提升。因为它里面有动态的东西。\n\n{{ msg }}\n\n\n但是，理想情况下，当我们看模板时，我们知道这个 div 不会改变。唯一可能改变的事实上就是这个 span。\n\n事实上，如果我在其他区域添加一些不相关的节点，作为人类，我们可以立即在整个模板中看到这一点——只有这个东西（span）可以改变，但是如果没有编译器生成的提示，虚拟 DOM 渲染器只看到 JavaScript 树，它不知道哪个部分会改变，所以编译器的工作就是提供这些信息。\n\n所以运行时可以说：“好吧，看看你给我的数据，我知道我可以跳过很多不必要的工作，直接跳到这（span）上面去。”\n\n我们的方法是用 block。我们将模板的根变成我们所称的块，注意这里有一个 openBlock 调用。\n\n\n\n所以当块打开时，所有表达式，所有的孩子都会被评估。\n\n当当前块打开时，所以这是一种 JavaScript 骗术。但想法是，当你创建这样一个节点时，因为它是动态的，它有我们称之为补丁标志的东西。补丁标志表示此节点是动态的，它应该被跟踪。当我们说tracked时，这个节点就会被添加到当前打开的 block 作为动态节点。\n\n所以在整个调用之后，这个根 div 将有一个额外的属性称为动态子节点，它将只包含此节点。\n\n我们还有完整的结构，通过正常的子层级，但是每个块都有一个额外的数组，只跟踪其中的动态节点，这个可以任意深。\n\n如果你有一个非常复杂的 DOM 结构，但不管有多复杂，在一个扁平数组中块将只跟踪动态节点。所以当它到达那个块时，通过虚拟 DOM 跟踪，它到达块。块告诉我们，这正是可能改变的。\n\n我们让编译器在生成的虚拟 DOM 树中去直接为我们编码信息，所以这些是当你只是手工写的时候，你通常得不到的额外信息。\n\n我们可能需要做其他事情。当你有一个指令，比如 v-if，这就是我们所说的结构指令，因为它可能会改变节点结构。当这个被切换时，整个 div 就会从树上消失。所以，对于这个根 block，它再也不能对此做出安全的假设了。\n\n\n\n相反，我们把这个完整的 if 部分变成一个块。这个块作为其父块的动态子级被跟踪了。\n\n所以我们有嵌套的块和每个块，将在扁平数组中跟踪它自己的动态子对象。\n\n现在，因为在我们的整个模板中，模板中可能有数百个 DOM 节点，但通常你只会有一些这样的 v-if 和 v -for。所以，我们基本上还是需要遍历块树。\n\n然而，大多数情况下是扁平数组迭代而不是去 diff 和比较检查潜在的节点移动，所以效率更高。我们也基本上减少了递归的数量，在大多数情况下减少一个数量级，因为不必检查每个 vnode 的变化。\n\n我现在就去找 block，而且关于值内部可能发生的变化，我还有其他信息。\n\n对于每个节点，补丁标志本身还编码了关于你需要在这个节点上做什么样的工作的信息。\n\n例如，这个文本标志意味着，当你试图区分这个节点时，你只需要检查它的文本内容，你不必担心它的 props，将所有这些结合起来，编译器将真正生成一个运行时渲染函数，它允许运行时利用所有这些提示，做尽可能少的工作。\n\n让我们考虑一下虚拟 DOM 渲染 API 看起来是什么样的。\n\n你要做的第一件事就是我们需要有 h 函数本身，以及 h 函数的特征会是像 tag，props，children。\n\n我们也想要一些我们称之为挂载函数的东西，所以 mount 会接收我们所说的 vnode，也就是每次调用的结果。还有一个容器，容器只是 DOM 元素，我们可以把东西放进去。\n\n现在，如果我们页面上有一个 ID 为 app 的 div，如果在 Vue 中直接使用虚拟 dom API，这是您通常会编写的代码：\n\n<div id=\"app\"></div>\n\n<script>\nfunction h(tag, props, children) {\n    \n}\n    \nfunction mount(vnode, container) {\n    \n}\n    \nconst vdom = h('div', { class: 'red' }, [\n    h('span', null, ['hello'])\n])\nmount(vdom, document.getElementById('app'))\n<\/script>\n\n\n所以我们希望能够创造虚拟 DOM 的快照，使用 h 函数，然后我们可以加载虚拟的 DOM 树变成了真正的 DOM 节点。\n\n看到他们出现在这里，这会给你一个想法。作为一个顶层或基层的角度，Vue 内部的事情是如何运作的。所以，很明显，这个例子会有很多边缘情况，我们就忽略了。\n\n是的，为了得到一个想法，它应该如何工作，整个要点就是得到一个非常非常小的版本。\n\n如果你想要一个好的挑战，就试试看吧。然后在下一课中，我们将向您展示 Evan 将如何实现。",normalizedContent:"# 编译器和渲染器 api\n\n这就是我们所说的模板浏览器（https://vue-next-template-explorer.netlify.app）\n\n\n\n我们在 vue 2 也有一个，但是 vue 3 模板浏览器功能更加丰富。\n\n如您所见，左边是源模板，右边是生成的渲染函数代码。\n\n在开发过程中，实际上我用这个来调试编译器，所以如果我有什么事情不能如愿，我只是在源模板中粘贴，我可以直接看到代码生成了什么，看看出了什么问题。\n\n如果我们看一下模板浏览器，这里有很多选择：\n\n\n\n所以我们可以启用某些类型的优化，例如：\n\n如果我们有一个嵌套的 div，这个 div 是完全静态的，你可以打开这个（hoiststatic），然后看它是否确实被从渲染函数中提升，以便可以在每个渲染器上重用它。\n\n\n\n所以每次组件更新时，这个渲染函数将被调用。一旦一个节点被提升，它就会被创建一次。在渲染函数之外，在以后的每一次渲染中，它将在这里重新使用。这有两个好处：\n\n首先是避免重新创建对象，然后扔掉。另一个好处是在我们的模式算法中，当你看到两个节点在同一位置时，在严格平等的情况下，我们可以跳过它。因为我们知道它永远不会改变。所以，是的，有很多有趣的优化。\n\n我们做的另一个有趣的优化：\n\n当你有一个点击侦听器，我们可以注意到我们绑定了 click 侦听器，编译器会生成一个补丁标志。\n\n\n\n这个节点有动态 props 需要修补一下，以及动态 props 的名称，需要修补的是 onclick。通常使用简单的虚拟 dom 渲染算法。\n\n不管有多少东西在 div 自身上，这整个对象必须作为一个整体来 diff。\n\n\n\n所以即使从模板中我们可以看到，这个 id 实际上是静态的，永远不会改变。\n\n我们还需要穿过整个对象，只是为了确保它不会改变，因为运行时没有足够的信息来推断。\n\n但是，使用 vue 3 的编译器，这个补丁（props）和这个数组（[\"onclick\"]）结合在一起，为运行时提供足够的信息。\n\n好吧，所以有些 props 会改变的，但唯一可能改变的是 onclick，因为它和暴露在外的东西结合在一起，所以你可以决定在某个时间改变它。\n\n我们可以跳过此 props 上的对象枚举，忽略那些已经被编译器推断永远不会改变的 props。\n\n确切地说，这些是编译器生成的提示，以帮助运行时更高效，在手动编写的渲染函数中，这不是一件容易的事。因为分析 javascript 比分析模板困难得多。\n\n我们现在看到的是是生成的渲染函数，相比你自己写的代码总是更加的冗长。因为编译器总是优先考虑更加优化，更加明确。\n\n我们一会儿就会看到，这里有很多便利。当你自己使用 api 时，我们所提供的使它更容易和更流畅。\n\n所以我们看看这个点击处理程序：\n\n\n\n现在我们知道在这个节点上，每次被更新或被 diff。我们需要看一下 onclick 以确保它不会改变。但在很多情况下，当你绑定一个事件监听器。实际上，您并不打算更改事件处理程序。所以当你用 vue3 时，有一个选项（cachehandlers）是默认打开的。\n\n\n\n注意我们使用了一些智能 javascript 来缓存事件处理程序：我们把它变成一个内联函数，并在第一次渲染时将其缓存。因此在后续渲染中，我们将始终使用同一个内联处理程序，所以我们总是传递相同的函数，但是里面的函数会访问 ctx.onclick。它保证它总是最新的函数被调用。\n\n我们可以注意到补丁标志，onclick 数组不见了。这意味着现在这个 vnode，当我们试图修补它时，它实际上并不需要被修补，因为这是静态的。当它被调用时，此事件处理程序已缓存，它总是指向最新的 onclick。所以即使 onclick 下面发生了变化，我们不需要对 vnode 本身做任何事情，我们只找到了一次相同的事件处理程序，我们可以忘掉它。在修补过程中，现在可以完全跳过整个节点，这是另一个层次的优化。\n\n这一点尤其重要，因为在组件上如果要将事件处理程序添加到组件中，我们防止子组件不必要地重新渲染的最常见情况之一是指使用类似这里的内联事件处理程序。\n\n\n\n或者当你写 foo 的时候，你给它一个参数，这也是一个隐式的内联处理程序。\n\n\n\n所以所有这些在 vue 2 中，对于这个组件，即使什么都没有改变，它仍然会导致子组件在父组件重新渲染时重新渲染。在大型应用中，这会引起连锁效应。因为你在向下传递函数，在每次渲染时，都会创建一个新的内联函数。会导致所有这些收到那个 prop 的子组件重新渲染。\n\n所以在 vue 3 中使用句柄缓存，这基本上减少了很大的面积的，在大型组件树中发生不必要的渲染，所以这也是一个不错的性能改进。\n\n事实上，这也是 react 中一个很常见的陷阱。这就是为什么 react 中有一个名为 usememo 的 api，或者叫 usecallback ，它们几乎是一样的。为了防止子组件重新渲染，允许开发人员手动缓存像这样的事件处理程序。\n\n但是在 vue 3 中有了模板，我们可以为用户自动完成，所以你不需要去想它。\n\n> 块和 vnode 有什么区别？\n\n让我们回到这个例子：\n\n我们看到根 div 被创建了，就像块一样。所以我们有一个这样的临时结构，在右边，我们看到它被提升了，但我们暂时不要担心。\n\n\n\n想象一下这是一个手动写的非优化虚拟 dom 树，在更新时，你要确保 dom 结构是一致的。如果这是手动编写的，那么运行时就没有信息了。关于这个 dom 树结构是否稳定，它不能做出任何假设，因为节点顺序可能已经改变，或者这个可以从 div 变成 p，对吗？\n\n当它是 javascript 时，任何事情都可能发生，所以运行时必须格外小心，它必须检查每个节点以确保它没有变成别的东西。如果有 props 的话就要把所有的 props 都区分开来，确保 props 没有改变。\n\n说到孩子（children）...\n\n\n\n事实上，它必须区分两个子数组以确保他们没有四处走动，或者没有新的孩子加入，或者孩子被删除。\n\n为了清楚起见，我们指向的是 html 代码，但实际上是一个虚拟 dom 结构，看起来像 json。它是一堆 javascript 对象。\n\n如果我们有一个渲染函数并且我们要复制我们刚才看到的这个模板，我们最终会得到这样的结果。\n\nfunction render() {\n    return h('div', [\n        h('div', [\n            h('span', 'hello')\n        ])\n    ])\n}\n\n\n因此，您可以想象最终的底层数据结构，可能看起来更像这样：\n\nconst vdom = {\n    tag: 'div',\n    children: [\n        tag: 'div',\n        children: [{\n        \ttag: 'span',\n        \tchildren: 'hello'\n        }]\n    ]\n}\n\n\n所以当我们调用这个生成的 javascript 结构，看起来像这样简单的结构。\n\n渲染器的工作，更新时，它将有两个快照。像这样的虚拟 dom 树，它的某些部分可能已经改变了。\n\n例如，从“hello”更新到“msg”。如果我们不提供更多的提示，渲染器并不真正知道发生了什么变化。所以它必须经过一个相对暴力的算法，以递归方式遍历整棵树，比较旧节点和新节点找出什么改变了。\n\n一般来说，在大多数情况下够快了。对于中型应用程序，您可能不会注意到任何性能瓶颈。因为现代 javascript 引擎处理普通对象优化得很好了。\n\n但是，当你有一个大型应用程序时，当你开始注意到最终这些小的迭代成本加起来。比如，当你点击某个东西时，也许你的应用程序中会有 10 个组件同时被触发再更新。这就是 javascript 成本开始增加的时候，这可能阻塞或卡顿你的应用程序。\n\n所以这就是人们开始了解如何手动优化组件树，避免不必要的重新渲染，这就是 vue 的优势所在。所以我们添加了一些提示，以及如何实现这一目标的优化。\n\n让我们回到块。\n\n\n\n在这里，我们可以看到。但这可能不是一个完美的例子。因为这棵树实际上是静止的，所以被提升。\n\n但是想象一下，让我们在这里加一点信息。\n\n\n\n这会使这部分变为动态，整棵树都不能被提升。因为它里面有动态的东西。\n\n{{ msg }}\n\n\n但是，理想情况下，当我们看模板时，我们知道这个 div 不会改变。唯一可能改变的事实上就是这个 span。\n\n事实上，如果我在其他区域添加一些不相关的节点，作为人类，我们可以立即在整个模板中看到这一点——只有这个东西（span）可以改变，但是如果没有编译器生成的提示，虚拟 dom 渲染器只看到 javascript 树，它不知道哪个部分会改变，所以编译器的工作就是提供这些信息。\n\n所以运行时可以说：“好吧，看看你给我的数据，我知道我可以跳过很多不必要的工作，直接跳到这（span）上面去。”\n\n我们的方法是用 block。我们将模板的根变成我们所称的块，注意这里有一个 openblock 调用。\n\n\n\n所以当块打开时，所有表达式，所有的孩子都会被评估。\n\n当当前块打开时，所以这是一种 javascript 骗术。但想法是，当你创建这样一个节点时，因为它是动态的，它有我们称之为补丁标志的东西。补丁标志表示此节点是动态的，它应该被跟踪。当我们说tracked时，这个节点就会被添加到当前打开的 block 作为动态节点。\n\n所以在整个调用之后，这个根 div 将有一个额外的属性称为动态子节点，它将只包含此节点。\n\n我们还有完整的结构，通过正常的子层级，但是每个块都有一个额外的数组，只跟踪其中的动态节点，这个可以任意深。\n\n如果你有一个非常复杂的 dom 结构，但不管有多复杂，在一个扁平数组中块将只跟踪动态节点。所以当它到达那个块时，通过虚拟 dom 跟踪，它到达块。块告诉我们，这正是可能改变的。\n\n我们让编译器在生成的虚拟 dom 树中去直接为我们编码信息，所以这些是当你只是手工写的时候，你通常得不到的额外信息。\n\n我们可能需要做其他事情。当你有一个指令，比如 v-if，这就是我们所说的结构指令，因为它可能会改变节点结构。当这个被切换时，整个 div 就会从树上消失。所以，对于这个根 block，它再也不能对此做出安全的假设了。\n\n\n\n相反，我们把这个完整的 if 部分变成一个块。这个块作为其父块的动态子级被跟踪了。\n\n所以我们有嵌套的块和每个块，将在扁平数组中跟踪它自己的动态子对象。\n\n现在，因为在我们的整个模板中，模板中可能有数百个 dom 节点，但通常你只会有一些这样的 v-if 和 v -for。所以，我们基本上还是需要遍历块树。\n\n然而，大多数情况下是扁平数组迭代而不是去 diff 和比较检查潜在的节点移动，所以效率更高。我们也基本上减少了递归的数量，在大多数情况下减少一个数量级，因为不必检查每个 vnode 的变化。\n\n我现在就去找 block，而且关于值内部可能发生的变化，我还有其他信息。\n\n对于每个节点，补丁标志本身还编码了关于你需要在这个节点上做什么样的工作的信息。\n\n例如，这个文本标志意味着，当你试图区分这个节点时，你只需要检查它的文本内容，你不必担心它的 props，将所有这些结合起来，编译器将真正生成一个运行时渲染函数，它允许运行时利用所有这些提示，做尽可能少的工作。\n\n让我们考虑一下虚拟 dom 渲染 api 看起来是什么样的。\n\n你要做的第一件事就是我们需要有 h 函数本身，以及 h 函数的特征会是像 tag，props，children。\n\n我们也想要一些我们称之为挂载函数的东西，所以 mount 会接收我们所说的 vnode，也就是每次调用的结果。还有一个容器，容器只是 dom 元素，我们可以把东西放进去。\n\n现在，如果我们页面上有一个 id 为 app 的 div，如果在 vue 中直接使用虚拟 dom api，这是您通常会编写的代码：\n\n<div id=\"app\"></div>\n\n<script>\nfunction h(tag, props, children) {\n    \n}\n    \nfunction mount(vnode, container) {\n    \n}\n    \nconst vdom = h('div', { class: 'red' }, [\n    h('span', null, ['hello'])\n])\nmount(vdom, document.getelementbyid('app'))\n<\/script>\n\n\n所以我们希望能够创造虚拟 dom 的快照，使用 h 函数，然后我们可以加载虚拟的 dom 树变成了真正的 dom 节点。\n\n看到他们出现在这里，这会给你一个想法。作为一个顶层或基层的角度，vue 内部的事情是如何运作的。所以，很明显，这个例子会有很多边缘情况，我们就忽略了。\n\n是的，为了得到一个想法，它应该如何工作，整个要点就是得到一个非常非常小的版本。\n\n如果你想要一个好的挑战，就试试看吧。然后在下一课中，我们将向您展示 evan 将如何实现。",charsets:{cjk:!0}},{title:"麻将的基础概念",frontmatter:{search:!1},regularPath:"/private/0yyy0qaq==/majiang/ch01.html",relativePath:"private/0yyy0qaq==/majiang/ch01.md",key:"v-1e4261d6",path:"/private/0yyy0qaq==/majiang/ch01.html",headers:[{level:2,title:"1. 基本规则",slug:"_1-基本规则",normalizedTitle:"1. 基本规则",charIndex:14},{level:2,title:"2. 概率",slug:"_2-概率",normalizedTitle:"2. 概率",charIndex:177},{level:3,title:"2.1 配牌概率",slug:"_2-1-配牌概率",normalizedTitle:"2.1 配牌概率",charIndex:187},{level:3,title:"2.2 摸牌概率",slug:"_2-2-摸牌概率",normalizedTitle:"2.2 摸牌概率",charIndex:1165},{level:3,title:"2.3 好坏牌",slug:"_2-3-好坏牌",normalizedTitle:"2.3 好坏牌",charIndex:1514},{level:2,title:"3. 摸牌顺序",slug:"_3-摸牌顺序",normalizedTitle:"3. 摸牌顺序",charIndex:1729},{level:2,title:"4. 数牌的特性",slug:"_4-数牌的特性",normalizedTitle:"4. 数牌的特性",charIndex:3317},{level:3,title:"4.1 对称性",slug:"_4-1-对称性",normalizedTitle:"4.1 对称性",charIndex:3401},{level:3,title:"4.2 一路性",slug:"_4-2-一路性",normalizedTitle:"4.2 一路性",charIndex:3710},{level:3,title:"4.3 向下压原则",slug:"_4-3-向下压原则",normalizedTitle:"4.3 向下压原则",charIndex:4232},{level:3,title:"4.4 封闭性与开放性",slug:"_4-4-封闭性与开放性",normalizedTitle:"4.4 封闭性与开放性",charIndex:4657}],headersStr:"1. 基本规则 2. 概率 2.1 配牌概率 2.2 摸牌概率 2.3 好坏牌 3. 摸牌顺序 4. 数牌的特性 4.1 对称性 4.2 一路性 4.3 向下压原则 4.4 封闭性与开放性",content:"# 麻将的基础概念\n\n\n# 1. 基本规则\n\n麻将是由万、筒、条三种一到九的数牌各四张，加上七张大字各四张的组合。所以共有 136 张牌。牌局进行的规则，是逆时针顺序施打，手牌是顺子组合可吃上家牌，对子组合可碰三家牌。有四张可杠，当手牌组合成四面一眼时（胡牌时要有 13 张牌，不论顺子或刻子，共要有3*4+2，称为四面一眼），达成胡牌的条件。\n\n\n# 2. 概率\n\n\n# 2.1 配牌概率\n\n四面一眼，这四个半的面子，会是什么？这里要先谈第一种概率问题。\n\n手牌 13 张，里面的基础组合应该长什么样？\n\n依据机率来配牌的话，四种花色，手牌里有万筒条的各是 9/34 （0.265），持有大字的机率是 7/34 （0.205），拥有数牌的机率大致上是 1/4，拥有大字的机率是 1/5，所以手牌「平均机率」分配下是：13x0.265+13x0.265+13x0.265+13x0.205，数字是万子 3.445 张，筒子 3.445 张，条子 3.445 张，大字 2.665 张。\n\n接着是面子的观念。连号叫做顺，同号叫做刻，在未完成三张的面子之前，我们称搭子。那么，四张牌，可以有几个搭子？举例：23 78，有四张，是两个搭子。或者22 99，四张。两个搭子。但四张也有可能只有一个搭子，比如12 28，13 59，所以：一搭必是 1-4 张（因为最后一搭可以是一眼，一眼可以单吊获得，所以可以一张），而两搭，可是 4-N 张，三搭，6-N 张 ... 张数多不一定就有搭子，但搭子的基础，一定是两张。\n\n那我们就清楚了，手牌立起来，13 张里面，我们大致会有万子 1 搭，筒子 1 搭，条子 1 搭，大字 1 搭或者没有。请将这样的数字记在头脑里。上面是平均分配的状况，但牌张要平均分配的机率不大，机率不会让你赢钱，机率也不会让你会打麻将，机率只是参考分析用，不是打错牌的尙方宝剑。但不知道机率，打的越久，输的越多，因为机率打越久，就会越趋近真实。\n\n这些面子，这样的配牌机率，要分析的是什么？就是战术的基本概念，也是百战要诀的第一条：我多敌少，我少敌多。\n\n手牌万子有八张，条子只有一张，你可以这样认为：下家条子有七张，万子却只有一两张。意思明确，你手牌越少的，敌人越多，手牌越多的，敌人越少，这也就是孤张经常被下家啃掉的原因。这样的配牌机率在扑克牌里最明显，当你有七张红心，敌人可能只有两张甚至缺门。麻将的道理也类似，但麻将一门有 36 张（4 x 9），你拿走 8 张，事实上还有 24 张，敌人也拿 8 张不是不可能，但谈机率就是谈「最可能」发生的状况，而不是一定会发生。\n\n这道理虽简单，但许多人不理会，造成打错牌时经常说这一句：「有什么办法，我的孤张都被下家吃走。」这就是对基础知识不了解所犯的错误。\n\n\n# 2.2 摸牌概率\n\n根据这平均配牌机率，拥有数牌的机率大致上是 1/4 。拥有大字的概率是 1/5 ，我们要想到的是第二个概率：摸到牌种的概率。一样，伸手摸牌，摸到数牌的概率大致上是 1/4 ，摸到大字的概率是 1/5 ，换句话说，平均每四巡会摸一张万子，每四巡会摸一张筒子，每四巡会摸一张条子，每五巡会中一张流弹： 大字。\n\n这样的概念有什么用？当你手上只有孤一张万子，你可以这样想：打到第十二巡，「正常」概率下会摸到三张万子，加上手上那张，共有四张（当然，全部不打的状况）。意思指：如果把那张孤张万子打掉，打到第十二巡，会共打掉四张万子（也就是打了四手废牌）。\n\n那么手牌 13 张，最多有几搭？ 6 x 2，最多会有 6 搭，但我们只需要 5 搭就会胡牌，这是后面找到五搭牌的概念。\n\n\n# 2.3 好坏牌\n\n而面子最后一个槪念，就是「好坏牌」，拿起来是顺子困难，还是暗刻困难？答案当然是暗刻，我们可以这样说：起手经常有暗刻的牌，表示当日牌运还不错。手牌 13 张，怎样算好牌？怎样算烂牌？当手牌立起来，有五搭牌以上就是好牌，4 搭左右要看牌质，好搭就是好牌，烂搭多也是偏烂。三搭是尚可，两搭以下就是烂牌了。\n\n诸君这基础机率知识不可不察啊，打牌虽然经常遇到见鬼的小机率，但这种最可能出现的机率，是不可不知道的。\n\n\n# 3. 摸牌顺序\n\n规则依逆时钟顺序各家摸打一张、这「顺序」狸面有什么奥秘？\n\n首先，吃牌，牌会向下掉，称为吃落。吃上家的牌，原本我们要摸的牌，变樊成下家摸，下家的牌变成对家摸，对家的牌变成 上家摸，而上家原本的牌，被我们摸走了，这就是为什么称为吃落的原因，因为吃牌，造成牌掉落下去，顺差一位。有可能我们要的牌，被敌家吃落，也有可能上家要的牌，被我们吃落。\n\n其次是碰牌，碰牌会因位置的不同造成三种变化。依次是上家打，本家碰，跟吃牌一样，吃落一位。对家打，本家碰，会造成「对碰对摸」术语的出现。接着是下家打，上家碰，牌会逆推回来一个位置。横牌与碰牌道理相同但多了一张岭上的牌会被取走。\n\n顺序有什么用？麻将打到最高阶，就是顺序的掌握了，张某称为「牌流」。胜败的关键经常是一张牌的顺序，而这个顺序，就是吃与不吃、碰与不碰之间。要改变顺序的方法，也就是依照吃碰杠，来变化摸牌顺序，这在牌流部分，我们将再讨论。\n\n接下来要谈的，是吃碰牌有什么影响？吃牌，造成牌的暴露，吃越多搭，牌情就越明朗，吃到剩下手牌四张，要不知道你听什么也难，这就是张某称的玻璃牌：里面是什么一清二楚。这是吃牌的缺点之一，其次，吃牌会造成手牌的局限，手牌四张，最多听三洞，但手牌七张可以听五洞，手牌十张就会飞了，可以听八洞。手牌越长，樊化性越多，进牌机率越高，手牌越少，就会偏限在很小的范围内。最后是吃牌必不能摸牌，摸牌是「所有」机率都产生，意思是手内所需要的任何一张，都有可能摸到，而吃牌，必不能摸到（但必可以得到吃的那一张）。用张某的话说：一定摸的到的，不吃也无所谓。\n\n而碰牌呢，我每次笑朋友打牌打的软趴趴，偶尔会被顶这句：「我又没被下家吃到牌，哪有软趴趴？」是啊，是没被吃到几张，但自己碰了三搭，再眼下家吃一搭，还不够吗？那怎样才够呢？\n\n让下家吃牌要吃几张？难道要喂到三搭落地，才叫做喂牌？之前吃几张牌都不重要（因为前期可进的牌张多，不吃都可能自己摸进），最重要的是一进听时的吃牌。\n\n好，都不喂，下家把把门清，总算硬梆梆了吧!但每把都碰三搭在桌上，给下家多摸三张牌，又跟喂牌有什么两様？\n\n很多人不懂碰牌会被下家多摸牌的道理，尤其是碰下家牌最危险。为什么？当下家摸到一张孤7万，打出北风，你碰，你可以猜猜，下家会摸到什么？8万？6万？9万？为什么？因为再怎么洗牌，都没办法完全均匀，678洗在一起的机会奇大无比，你连碰两张，下家恰恰可以凑成一搭，危害甚巨。你让下家自由摸牌，他的孤7万可能五巡都靠不到邻牌，但你一碰之下，好搭就出现了。\n\n其次是时效性。下家13条12筒不知道要拆哪边。两三巡过去，就逼的他搭子溢满，只得蒙着眼睛拆，这就是打错牌蚀搭的开始，一旦蚀搭，气势就会滑落。 但是当他还留着13条12筒时，你就碰牌，他可能会摸到12345条，可能摸到123筒，让他毫无困难的打出最大机率，自然促进你的灭亡。\n\n再次是生死。你的下家有孤9条孤9筒要跑，当他打出9筒让你碰，接着他摸了一张，打出9条听牌，没事。接着对家摸到北风打出來（或者手里北风），你上家碰，听牌，听69条。请问，你的敌人现在有谁？有一个听69超级好搭的上家，与一个你培植出的下家，试问，谁会活着？是那个侥悻于难的下家，还是没胡到可能变自摸的上家？如果你9筒不碰，对家摸一张打北，或者不打北打别张给你上家吃听牌，听69，抑是你上家自己摸到北听牌，甚至摸到69听北，你下家那张孤9条已然死定，或者你对家那张北死定，你已经安如泰山。就因为多嘴多碰一声，钱就从自己口袋到别人口袋。\n\n所以，少碰两张牌，尤其是下家打的。很多人认为碰下家的最有经济效应，刚摸就碰，牌气顺畅。没错，旺的时候，爱碰就碰，没有人阻止的了你，但当牌局开始不好打，尤其下家胡了几把摸了几把后，少碰两张吧。强与弱，就在爱碰与不爱碰之间。硬跟软，也是个碰字差别。\n\n\n# 4. 数牌的特性\n\n麻将里最重要的就是二十七种数牌。这二十七种数牌，事实上，是 1 到 9 的组合，再细分，就会看见更细微的概念，以下便针对数牌的特性来说明：\n\n\n# 4.1 对称性\n\n首先，我们来将数牌解剖：123456789\n\n\n\n * 19，称为么九，老头牌。\n * 28，称为肩张，在牌组肩膀的位置。\n * 34567，称为中间张。\n * 12345，数字为小，我们称为小褂。\n * 56789，数字为大，我们称为大褂。\n\n从上面的分类，我们不难看见数牌的对称性，1-5，5-9，不管顺布或逆布，拥有相同的造型与机率。 1等于9，2等于8，3等于7，4等于6，利用性与价值，都完全一样。\n\n所以將來我們讨论手牌，将以小掛或大掛择一説明・读者诸君再利用对称性的概念，来融会贯通。\n\n在对称性的内容中，中挂456是数牌的精华，会透露出最多的情報，在后編我們將做详细的解说。\n\n\n# 4.2 一路性\n\n因为麻将的规则为顺子可吃，所以数牌由此方式产生了「一路性」。23要吃14，所以14为同一路。34要吃25，所以25是同一路。因为面子是由三张做组合，所以一路的规律，便是相距3步。因此可得：\n\n * 14 47是一路\n * 25 58是一路\n * 36 69是一路\n\n我们可以粗略的做这样的结论：\n\n * 打 4 不吃，可视作 1 7 不吃\n * 打 5 不吃，可视作 2 8 不吃\n * 打 6 不吃，可视作 3 9 不吃\n\n这就是一路性。\n\n例外的存在是：\n\n当打4，敌家有11、77、68、89时，会要17，但我们谈论的是吃牌，所以会有68、89两种，能吃到7，所以更细节的说：\n\n * 打4，必不吃1。（下一巡可以打的安全牌）\n * 打6，必不吃9，但有12、24可吃3。\n\n打5呢，敌家还有13，79可吃28。\n\n综上所论，打5的一路性最差，为什么？因为12、89（甚至24、68）在中盘拆搭时经常被舍弃，而13、79却不会（自然要熟悉麻将好坏搭的敌家才会做出这样的施打），所以打5不吃，28并不保险。\n\n一路性是防御的重要准则，也是判断听张的工具，简单的说，打4，还要上卦，打6，还要下卦，打5，五花八门。\n\n\n# 4.3 向下压原则\n\n接下来要谈百战要诀第二：向下压原则。\n\n何谓向下压？意思是，在数牌号码下面的（依小挂的位置看），是被下压的牌。2向下压着1，3向下压着12，4向下压着123。5是数牌中间，没有向下压特性。\n\n向下压原则有许多用处，最大的用处是：序盘打出的孤张，向下压的牌不要。打2，1不要，打3，12不要，打4，123不要。为什么会有这样的特性？因为吃牌规则的利用性，所以打2，手牌必无34附近（否则也不会称为孤张），几乎肯定不能吃1，打3则不能吃12，打4不能吃123。根据向下压原则，就可以很简单的做好防御的工作。\n\n向下压只有两个例外，第一个例外是打4吊1，（114的造型），第二种打4吊3（124的造型，张某爱这样打，所以又称为横飞的老伎俩）。第二种严格来説不能当作孤张，但是序盘前几手就会出现的状况。所以需要说明。其他还有112、113大字不打先打23的，这种打法会妨害最大机率，可以不用理这种敌人，因为他打久了自己会堕落。\n\n\n# 4.4 封闭性与开放性\n\n依据吃牌的规则，再经过数牌的持有张数不同后，会产生新的机率。举个例：当我们持有2四张，敌家要1的机会，微乎其微。意指：当某一个号码持有越多张时，就会造成牌的封闭与开放变化。\n\n所谓封闭性，就是被自己的手牌持有的张数下压着，造成了封闭的效果。诸如1222、 1333、 2333，因为持有三张的23，所以23以下被封闭。而开放性，是2224、2223，3334、3335，不管持有多少张23，45都没有被控制住，所以存在着开放性。封闭性意味着安全性，开放性意味着为危险性。\n\n那么向下压的1444、2444、3444，是否具有封闭性？答案是没有，因为4抓三张，也没有影响到12、13、23的存在，所以123并不在安全的控制范围。所以谈到向下压，最好的例子是4号，谈到封闭性，则是3号。\n\n封闭性的概念，事实上是用在“半封闭”，当持有133时，1安不安全？事实上是好打的，我们可以做这样的结论：当手上持有能向下压的一对子，其下挂邻牌安全。 好比122233，许多会觉得自己持有三张2，觉得略有不安全，不如打1最安全，事实上有3一对，半封闭已经够安全。\n\n封闭性的概念也是防御原则的基本，这也就是熟悉基本知识的重要性。",normalizedContent:"# 麻将的基础概念\n\n\n# 1. 基本规则\n\n麻将是由万、筒、条三种一到九的数牌各四张，加上七张大字各四张的组合。所以共有 136 张牌。牌局进行的规则，是逆时针顺序施打，手牌是顺子组合可吃上家牌，对子组合可碰三家牌。有四张可杠，当手牌组合成四面一眼时（胡牌时要有 13 张牌，不论顺子或刻子，共要有3*4+2，称为四面一眼），达成胡牌的条件。\n\n\n# 2. 概率\n\n\n# 2.1 配牌概率\n\n四面一眼，这四个半的面子，会是什么？这里要先谈第一种概率问题。\n\n手牌 13 张，里面的基础组合应该长什么样？\n\n依据机率来配牌的话，四种花色，手牌里有万筒条的各是 9/34 （0.265），持有大字的机率是 7/34 （0.205），拥有数牌的机率大致上是 1/4，拥有大字的机率是 1/5，所以手牌「平均机率」分配下是：13x0.265+13x0.265+13x0.265+13x0.205，数字是万子 3.445 张，筒子 3.445 张，条子 3.445 张，大字 2.665 张。\n\n接着是面子的观念。连号叫做顺，同号叫做刻，在未完成三张的面子之前，我们称搭子。那么，四张牌，可以有几个搭子？举例：23 78，有四张，是两个搭子。或者22 99，四张。两个搭子。但四张也有可能只有一个搭子，比如12 28，13 59，所以：一搭必是 1-4 张（因为最后一搭可以是一眼，一眼可以单吊获得，所以可以一张），而两搭，可是 4-n 张，三搭，6-n 张 ... 张数多不一定就有搭子，但搭子的基础，一定是两张。\n\n那我们就清楚了，手牌立起来，13 张里面，我们大致会有万子 1 搭，筒子 1 搭，条子 1 搭，大字 1 搭或者没有。请将这样的数字记在头脑里。上面是平均分配的状况，但牌张要平均分配的机率不大，机率不会让你赢钱，机率也不会让你会打麻将，机率只是参考分析用，不是打错牌的尙方宝剑。但不知道机率，打的越久，输的越多，因为机率打越久，就会越趋近真实。\n\n这些面子，这样的配牌机率，要分析的是什么？就是战术的基本概念，也是百战要诀的第一条：我多敌少，我少敌多。\n\n手牌万子有八张，条子只有一张，你可以这样认为：下家条子有七张，万子却只有一两张。意思明确，你手牌越少的，敌人越多，手牌越多的，敌人越少，这也就是孤张经常被下家啃掉的原因。这样的配牌机率在扑克牌里最明显，当你有七张红心，敌人可能只有两张甚至缺门。麻将的道理也类似，但麻将一门有 36 张（4 x 9），你拿走 8 张，事实上还有 24 张，敌人也拿 8 张不是不可能，但谈机率就是谈「最可能」发生的状况，而不是一定会发生。\n\n这道理虽简单，但许多人不理会，造成打错牌时经常说这一句：「有什么办法，我的孤张都被下家吃走。」这就是对基础知识不了解所犯的错误。\n\n\n# 2.2 摸牌概率\n\n根据这平均配牌机率，拥有数牌的机率大致上是 1/4 。拥有大字的概率是 1/5 ，我们要想到的是第二个概率：摸到牌种的概率。一样，伸手摸牌，摸到数牌的概率大致上是 1/4 ，摸到大字的概率是 1/5 ，换句话说，平均每四巡会摸一张万子，每四巡会摸一张筒子，每四巡会摸一张条子，每五巡会中一张流弹： 大字。\n\n这样的概念有什么用？当你手上只有孤一张万子，你可以这样想：打到第十二巡，「正常」概率下会摸到三张万子，加上手上那张，共有四张（当然，全部不打的状况）。意思指：如果把那张孤张万子打掉，打到第十二巡，会共打掉四张万子（也就是打了四手废牌）。\n\n那么手牌 13 张，最多有几搭？ 6 x 2，最多会有 6 搭，但我们只需要 5 搭就会胡牌，这是后面找到五搭牌的概念。\n\n\n# 2.3 好坏牌\n\n而面子最后一个槪念，就是「好坏牌」，拿起来是顺子困难，还是暗刻困难？答案当然是暗刻，我们可以这样说：起手经常有暗刻的牌，表示当日牌运还不错。手牌 13 张，怎样算好牌？怎样算烂牌？当手牌立起来，有五搭牌以上就是好牌，4 搭左右要看牌质，好搭就是好牌，烂搭多也是偏烂。三搭是尚可，两搭以下就是烂牌了。\n\n诸君这基础机率知识不可不察啊，打牌虽然经常遇到见鬼的小机率，但这种最可能出现的机率，是不可不知道的。\n\n\n# 3. 摸牌顺序\n\n规则依逆时钟顺序各家摸打一张、这「顺序」狸面有什么奥秘？\n\n首先，吃牌，牌会向下掉，称为吃落。吃上家的牌，原本我们要摸的牌，变樊成下家摸，下家的牌变成对家摸，对家的牌变成 上家摸，而上家原本的牌，被我们摸走了，这就是为什么称为吃落的原因，因为吃牌，造成牌掉落下去，顺差一位。有可能我们要的牌，被敌家吃落，也有可能上家要的牌，被我们吃落。\n\n其次是碰牌，碰牌会因位置的不同造成三种变化。依次是上家打，本家碰，跟吃牌一样，吃落一位。对家打，本家碰，会造成「对碰对摸」术语的出现。接着是下家打，上家碰，牌会逆推回来一个位置。横牌与碰牌道理相同但多了一张岭上的牌会被取走。\n\n顺序有什么用？麻将打到最高阶，就是顺序的掌握了，张某称为「牌流」。胜败的关键经常是一张牌的顺序，而这个顺序，就是吃与不吃、碰与不碰之间。要改变顺序的方法，也就是依照吃碰杠，来变化摸牌顺序，这在牌流部分，我们将再讨论。\n\n接下来要谈的，是吃碰牌有什么影响？吃牌，造成牌的暴露，吃越多搭，牌情就越明朗，吃到剩下手牌四张，要不知道你听什么也难，这就是张某称的玻璃牌：里面是什么一清二楚。这是吃牌的缺点之一，其次，吃牌会造成手牌的局限，手牌四张，最多听三洞，但手牌七张可以听五洞，手牌十张就会飞了，可以听八洞。手牌越长，樊化性越多，进牌机率越高，手牌越少，就会偏限在很小的范围内。最后是吃牌必不能摸牌，摸牌是「所有」机率都产生，意思是手内所需要的任何一张，都有可能摸到，而吃牌，必不能摸到（但必可以得到吃的那一张）。用张某的话说：一定摸的到的，不吃也无所谓。\n\n而碰牌呢，我每次笑朋友打牌打的软趴趴，偶尔会被顶这句：「我又没被下家吃到牌，哪有软趴趴？」是啊，是没被吃到几张，但自己碰了三搭，再眼下家吃一搭，还不够吗？那怎样才够呢？\n\n让下家吃牌要吃几张？难道要喂到三搭落地，才叫做喂牌？之前吃几张牌都不重要（因为前期可进的牌张多，不吃都可能自己摸进），最重要的是一进听时的吃牌。\n\n好，都不喂，下家把把门清，总算硬梆梆了吧!但每把都碰三搭在桌上，给下家多摸三张牌，又跟喂牌有什么两様？\n\n很多人不懂碰牌会被下家多摸牌的道理，尤其是碰下家牌最危险。为什么？当下家摸到一张孤7万，打出北风，你碰，你可以猜猜，下家会摸到什么？8万？6万？9万？为什么？因为再怎么洗牌，都没办法完全均匀，678洗在一起的机会奇大无比，你连碰两张，下家恰恰可以凑成一搭，危害甚巨。你让下家自由摸牌，他的孤7万可能五巡都靠不到邻牌，但你一碰之下，好搭就出现了。\n\n其次是时效性。下家13条12筒不知道要拆哪边。两三巡过去，就逼的他搭子溢满，只得蒙着眼睛拆，这就是打错牌蚀搭的开始，一旦蚀搭，气势就会滑落。 但是当他还留着13条12筒时，你就碰牌，他可能会摸到12345条，可能摸到123筒，让他毫无困难的打出最大机率，自然促进你的灭亡。\n\n再次是生死。你的下家有孤9条孤9筒要跑，当他打出9筒让你碰，接着他摸了一张，打出9条听牌，没事。接着对家摸到北风打出來（或者手里北风），你上家碰，听牌，听69条。请问，你的敌人现在有谁？有一个听69超级好搭的上家，与一个你培植出的下家，试问，谁会活着？是那个侥悻于难的下家，还是没胡到可能变自摸的上家？如果你9筒不碰，对家摸一张打北，或者不打北打别张给你上家吃听牌，听69，抑是你上家自己摸到北听牌，甚至摸到69听北，你下家那张孤9条已然死定，或者你对家那张北死定，你已经安如泰山。就因为多嘴多碰一声，钱就从自己口袋到别人口袋。\n\n所以，少碰两张牌，尤其是下家打的。很多人认为碰下家的最有经济效应，刚摸就碰，牌气顺畅。没错，旺的时候，爱碰就碰，没有人阻止的了你，但当牌局开始不好打，尤其下家胡了几把摸了几把后，少碰两张吧。强与弱，就在爱碰与不爱碰之间。硬跟软，也是个碰字差别。\n\n\n# 4. 数牌的特性\n\n麻将里最重要的就是二十七种数牌。这二十七种数牌，事实上，是 1 到 9 的组合，再细分，就会看见更细微的概念，以下便针对数牌的特性来说明：\n\n\n# 4.1 对称性\n\n首先，我们来将数牌解剖：123456789\n\n\n\n * 19，称为么九，老头牌。\n * 28，称为肩张，在牌组肩膀的位置。\n * 34567，称为中间张。\n * 12345，数字为小，我们称为小褂。\n * 56789，数字为大，我们称为大褂。\n\n从上面的分类，我们不难看见数牌的对称性，1-5，5-9，不管顺布或逆布，拥有相同的造型与机率。 1等于9，2等于8，3等于7，4等于6，利用性与价值，都完全一样。\n\n所以將來我們讨论手牌，将以小掛或大掛择一説明・读者诸君再利用对称性的概念，来融会贯通。\n\n在对称性的内容中，中挂456是数牌的精华，会透露出最多的情報，在后編我們將做详细的解说。\n\n\n# 4.2 一路性\n\n因为麻将的规则为顺子可吃，所以数牌由此方式产生了「一路性」。23要吃14，所以14为同一路。34要吃25，所以25是同一路。因为面子是由三张做组合，所以一路的规律，便是相距3步。因此可得：\n\n * 14 47是一路\n * 25 58是一路\n * 36 69是一路\n\n我们可以粗略的做这样的结论：\n\n * 打 4 不吃，可视作 1 7 不吃\n * 打 5 不吃，可视作 2 8 不吃\n * 打 6 不吃，可视作 3 9 不吃\n\n这就是一路性。\n\n例外的存在是：\n\n当打4，敌家有11、77、68、89时，会要17，但我们谈论的是吃牌，所以会有68、89两种，能吃到7，所以更细节的说：\n\n * 打4，必不吃1。（下一巡可以打的安全牌）\n * 打6，必不吃9，但有12、24可吃3。\n\n打5呢，敌家还有13，79可吃28。\n\n综上所论，打5的一路性最差，为什么？因为12、89（甚至24、68）在中盘拆搭时经常被舍弃，而13、79却不会（自然要熟悉麻将好坏搭的敌家才会做出这样的施打），所以打5不吃，28并不保险。\n\n一路性是防御的重要准则，也是判断听张的工具，简单的说，打4，还要上卦，打6，还要下卦，打5，五花八门。\n\n\n# 4.3 向下压原则\n\n接下来要谈百战要诀第二：向下压原则。\n\n何谓向下压？意思是，在数牌号码下面的（依小挂的位置看），是被下压的牌。2向下压着1，3向下压着12，4向下压着123。5是数牌中间，没有向下压特性。\n\n向下压原则有许多用处，最大的用处是：序盘打出的孤张，向下压的牌不要。打2，1不要，打3，12不要，打4，123不要。为什么会有这样的特性？因为吃牌规则的利用性，所以打2，手牌必无34附近（否则也不会称为孤张），几乎肯定不能吃1，打3则不能吃12，打4不能吃123。根据向下压原则，就可以很简单的做好防御的工作。\n\n向下压只有两个例外，第一个例外是打4吊1，（114的造型），第二种打4吊3（124的造型，张某爱这样打，所以又称为横飞的老伎俩）。第二种严格来説不能当作孤张，但是序盘前几手就会出现的状况。所以需要说明。其他还有112、113大字不打先打23的，这种打法会妨害最大机率，可以不用理这种敌人，因为他打久了自己会堕落。\n\n\n# 4.4 封闭性与开放性\n\n依据吃牌的规则，再经过数牌的持有张数不同后，会产生新的机率。举个例：当我们持有2四张，敌家要1的机会，微乎其微。意指：当某一个号码持有越多张时，就会造成牌的封闭与开放变化。\n\n所谓封闭性，就是被自己的手牌持有的张数下压着，造成了封闭的效果。诸如1222、 1333、 2333，因为持有三张的23，所以23以下被封闭。而开放性，是2224、2223，3334、3335，不管持有多少张23，45都没有被控制住，所以存在着开放性。封闭性意味着安全性，开放性意味着为危险性。\n\n那么向下压的1444、2444、3444，是否具有封闭性？答案是没有，因为4抓三张，也没有影响到12、13、23的存在，所以123并不在安全的控制范围。所以谈到向下压，最好的例子是4号，谈到封闭性，则是3号。\n\n封闭性的概念，事实上是用在“半封闭”，当持有133时，1安不安全？事实上是好打的，我们可以做这样的结论：当手上持有能向下压的一对子，其下挂邻牌安全。 好比122233，许多会觉得自己持有三张2，觉得略有不安全，不如打1最安全，事实上有3一对，半封闭已经够安全。\n\n封闭性的概念也是防御原则的基本，这也就是熟悉基本知识的重要性。",charsets:{cjk:!0}},{title:"Page 注册与管理",frontmatter:{},regularPath:"/mp/get-started/page.html",relativePath:"mp/get-started/page.md",key:"v-2a365402",path:"/mp/get-started/page.html",headers:[{level:2,title:"data",slug:"data",normalizedTitle:"data",charIndex:94},{level:2,title:"生命周期回调函数",slug:"生命周期回调函数",normalizedTitle:"生命周期回调函数",charIndex:1566},{level:3,title:"onLoad(Object query)",slug:"onload-object-query",normalizedTitle:"onload(object query)",charIndex:1579},{level:3,title:"onShow()",slug:"onshow",normalizedTitle:"onshow()",charIndex:1711},{level:3,title:"onHide()",slug:"onhide",normalizedTitle:"onhide()",charIndex:1865},{level:3,title:"onUnload()",slug:"onunload",normalizedTitle:"onunload()",charIndex:1935},{level:2,title:"页面事件处理函数",slug:"页面事件处理函数",normalizedTitle:"页面事件处理函数",charIndex:1997},{level:3,title:"onPullDownRefresh()",slug:"onpulldownrefresh",normalizedTitle:"onpulldownrefresh()",charIndex:2010},{level:3,title:"onReachBottom()",slug:"onreachbottom",normalizedTitle:"onreachbottom()",charIndex:2217},{level:3,title:"onPageScroll(Object object)",slug:"onpagescroll-object-object",normalizedTitle:"onpagescroll(object object)",charIndex:2336},{level:3,title:"onAddToFavorites(Object object)",slug:"onaddtofavorites-object-object",normalizedTitle:"onaddtofavorites(object object)",charIndex:2602},{level:3,title:"onShareAppMessage(Object object)",slug:"onshareappmessage-object-object",normalizedTitle:"onshareappmessage(object object)",charIndex:3247},{level:3,title:"onShareTimeline()",slug:"onsharetimeline",normalizedTitle:"onsharetimeline()",charIndex:4652},{level:3,title:"onResize(Object object)",slug:"onresize-object-object",normalizedTitle:"onresize(object object)",charIndex:5196},{level:3,title:"onTabItemTap(Object object)",slug:"ontabitemtap-object-object",normalizedTitle:"ontabitemtap(object object)",charIndex:5277},{level:3,title:"onSaveExitState()",slug:"onsaveexitstate",normalizedTitle:"onsaveexitstate()",charIndex:5684},{level:2,title:"组件事件处理函数",slug:"组件事件处理函数",normalizedTitle:"组件事件处理函数",charIndex:5790},{level:3,title:"Page.route",slug:"page-route",normalizedTitle:"page.route",charIndex:5999},{level:3,title:"Page.prototype.setData(Object data, Function callback)",slug:"page-prototype-setdata-object-data-function-callback",normalizedTitle:"page.prototype.setdata(object data, function callback)",charIndex:6131},{level:2,title:"页面间通信",slug:"页面间通信",normalizedTitle:"页面间通信",charIndex:8063}],headersStr:"data 生命周期回调函数 onLoad(Object query) onShow() onHide() onUnload() 页面事件处理函数 onPullDownRefresh() onReachBottom() onPageScroll(Object object) onAddToFavorites(Object object) onShareAppMessage(Object object) onShareTimeline() onResize(Object object) onTabItemTap(Object object) onSaveExitState() 组件事件处理函数 Page.route Page.prototype.setData(Object data, Function callback) 页面间通信",content:"# Page 注册与管理\n\n对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。\n\n//index.js\nPage({\n  data: {\n    // 页面第一次渲染使用的初始数据\n    // 渲染层可以通过 WXML 对数据进行绑定\n    text: \"This is page data.\"\n  },\n  onLoad: function(options) {\n    // 页面加载时触发\n    // 一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数\n  },\n  onShow: function() {\n    // 页面显示/切入前台时触发\n  },\n  onReady: function() {\n    // 页面初次渲染完成时触发\n    // 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互\n  },\n  onHide: function() {\n    // 页面隐藏/切入后台时触发\n    // 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等\n  },\n  onUnload: function() {\n    // 页面卸载时触发\n    // 如 wx.redirectTo 或 wx.navigateBack 到其他页面时\n  },\n  onPullDownRefresh: function() {\n    // 监听用户下拉刷新事件\n  },\n  onReachBottom: function() {\n    // 监听用户上拉触底事件\n  },\n  onShareAppMessage: function () {\n    // 监听用户点击页面内转发按钮（button 组件 open-type=\"share\"）\n    // 或右上角菜单“转发”按钮的行为，并自定义转发内容\n  },\n  onPageScroll: function() {\n    // 监听用户滑动页面事件\n  },\n  onResize: function() {\n    // 小程序屏幕旋转时触发\n  },\n  onTabItemTap(item) {\n    console.log(item.index)\n    console.log(item.pagePath)\n    console.log(item.text)\n  },\n  // Event handler.\n  viewTap: function() {\n    this.setData({\n      text: 'Set some data for updating view.'\n    }, function() {\n      // this is setData callback\n    })\n  },\n  customData: {\n    hi: 'MINA'\n  }\n})\n\n\n\n# data\n\ndata 是页面第一次渲染使用的初始数据。\n\n页面加载时，data 将会以JSON字符串的形式由逻辑层传至渲染层，因此data中的数据必须是可以转成JSON的类型：字符串，数字，布尔值，对象，数组。\n\n渲染层可以通过 WXML 对数据进行绑定。\n\n示例代码：\n\n在开发者工具中预览效果\n\n<view>{{text}}</view>\n<view>{{array[0].msg}}</view>\nPage({\n  data: {\n    text: 'init data',\n    array: [{msg: '1'}, {msg: '2'}]\n  }\n})\n\n\n\n# 生命周期回调函数\n\n\n# onLoad(Object query)\n\n页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。\n\n参数：\n\n名称      类型       说明\nquery   Object   打开当前页面路径中的参数\n\n\n# onShow()\n\n页面显示/切入前台时触发。\n\n# onReady()\n\n页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。\n\n注意：对界面内容进行设置的 API 如wx.setNavigationBarTitle，请在onReady之后进行。详见生命周期\n\n\n# onHide()\n\n页面隐藏/切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。\n\n\n# onUnload()\n\n页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。\n\n\n# 页面事件处理函数\n\n\n# onPullDownRefresh()\n\n监听用户下拉刷新事件。\n\n * 需要在app.json的window选项中或页面配置中开启enablePullDownRefresh。\n * 可以通过wx.startPullDownRefresh触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。\n * 当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。\n\n\n# onReachBottom()\n\n监听用户上拉触底事件。\n\n * 可以在app.json的window选项中或页面配置中设置触发距离onReachBottomDistance。\n * 在触发距离内滑动期间，本事件只会被触发一次。\n\n\n# onPageScroll(Object object)\n\n监听用户滑动页面事件。\n\n参数 Object object:\n\n属性          类型       说明\nscrollTop   Number   页面在垂直方向已滚动的距离（单位px）\n\n注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。 注意：请避免在 onPageScroll 中过于频繁的执行 setData 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。\n\n\n# onAddToFavorites(Object object)\n\n> 本接口为 Beta 版本，安卓 7.0.15 版本起支持，暂只在安卓平台支持\n\n监听用户点击右上角菜单“收藏”按钮的行为，并自定义收藏内容。\n\n参数 Object object:\n\n参数           类型       说明\nwebViewUrl   String   页面中包含web-view组件时，返回当前web-view的url\n\n此事件处理函数需要 return 一个 Object，用于自定义收藏内容：\n\n字段         说明                   默认值\ntitle      自定义标题                页面标题或账号名称\nimageUrl   自定义图片，显示图片长宽比为 1：1   页面截图\nquery      自定义query字段           当前页面的query\n\n示例代码\n\nPage({\n  onAddToFavorites(res) {\n    // webview 页面返回 webViewUrl\n    console.log('webViewUrl: ', res.webViewUrl)\n    return {\n      title: '自定义标题',\n      imageUrl: 'http://demo.png',\n      query: 'name=xxx&age=xxx',\n    }\n  }\n})\n\n\n\n# onShareAppMessage(Object object)\n\n监听用户点击页面内转发按钮（button 组件 open-type=\"share\"）或右上角菜单“转发”按钮的行为，并自定义转发内容。\n\n注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮\n\n参数 Object object:\n\n参数           类型       说明                                                           最低版本\nfrom         String   转发事件来源。 button：页面内转发按钮； menu：右上角转发菜单                         1.2.4\ntarget       Object   如果 from 值是 button，则 target 是触发这次转发事件的 button，否则为 undefined   1.2.4\nwebViewUrl   String   页面中包含web-view组件时，返回当前web-view的url                            1.6.4\n\n此事件处理函数需要 return 一个 Object，用于自定义转发内容，返回内容如下：\n\n自定义转发内容 基础库 2.8.1 起，分享图支持云图片。\n\n字段         说明                                                          默认值                         最低版本\ntitle      转发标题                                                        当前小程序名称                     \npath       转发路径                                                        当前页面 path ，必须是以 / 开头的完整路径   \nimageUrl   自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。   使用默认截图                      1.5.0\npromise    如果该参数存在，则以 resolve 结果为准，如果三秒内不 resolve，分享会使用上面传入的默认参数                                   2.12.0\n\n示例代码\n\n在开发者工具中预览效果\n\nPage({\n  onShareAppMessage() {\n    const promise = new Promise(resolve => {\n      setTimeout(() => {\n        resolve({\n          title: '自定义转发标题'\n        })\n      }, 2000)\n    })\n    return {\n      title: '自定义转发标题',\n      path: '/page/user?id=123',\n      promise \n    }\n  }\n})\n\n\n\n# onShareTimeline()\n\n> 基础库 2.11.3 开始支持，低版本需做兼容处理。\n\n> 本接口为 Beta 版本，暂只在 Android 平台支持，详见分享到朋友圈 (Beta)\n\n监听右上角菜单“分享到朋友圈”按钮的行为，并自定义分享内容。\n\n注意：只有定义了此事件处理函数，右上角菜单才会显示“分享到朋友圈”按钮\n\n自定义转发内容\n\n事件处理函数返回一个 Object，用于自定义分享内容，不支持自定义页面路径，返回内容如下：\n\n字段         说明                                                 默认值            最低版本\ntitle      自定义标题，即朋友圈列表页上显示的标题                                当前小程序名称        \nquery      自定义页面路径中携带的参数，如 path?a=1&b=2 的 “?” 后面部分            当前页面路径携带的参数    \nimageUrl   自定义图片路径，可以是本地文件或者网络图片。支持 PNG 及 JPG，显示图片长宽比是 1:1。   默认使用小程序 Logo   \n\n\n# onResize(Object object)\n\n> 基础库 2.4.0 开始支持，低版本需做兼容处理。\n\n小程序屏幕旋转时触发。详见 响应显示区域变化\n\n\n# onTabItemTap(Object object)\n\n> 基础库 1.9.0 开始支持，低版本需做兼容处理。\n\n点击 tab 时触发\n\nObject 参数说明：\n\n参数         类型       说明                   最低版本\nindex      String   被点击tabItem的序号，从0开始   1.9.0\npagePath   String   被点击tabItem的页面路径      1.9.0\ntext       String   被点击tabItem的按钮文字      1.9.0\n\n示例代码：\n\nPage({\n  onTabItemTap(item) {\n    console.log(item.index)\n    console.log(item.pagePath)\n    console.log(item.text)\n  }\n})\n\n\n\n# onSaveExitState()\n\n> 基础库 2.7.4 开始支持，低版本需做兼容处理。\n\n每当小程序可能被销毁之前，页面回调函数 onSaveExitState 会被调用，可以进行退出状态的保存。\n\n\n# 组件事件处理函数\n\nPage 中还可以定义组件事件处理函数。在渲染层的组件中加入事件处理，当事件被触发时，就会执行 Page 中定义的事件处理函数。\n\n示例代码：\n\n在开发者工具中预览效果\n\n<view bindtap=\"viewTap\"> click me </view>\nPage({\n  viewTap: function() {\n    console.log('view tap')\n  }\n})\n\n\n\n# Page.route\n\n> 基础库 1.2.0 开始支持，低版本需做兼容处理。\n\n到当前页面的路径，类型为String。\n\nPage({\n  onShow: function() {\n    console.log(this.route)\n  }\n})\n\n\n\n# Page.prototype.setData(Object data, Function callback)\n\nsetData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。\n\n# 参数说明\n\n字段         类型         必填   描述                         最低版本\ndata       Object     是    这次要改变的数据                   \ncallback   Function   否    setData引起的界面更新渲染完毕后的回调函数   1.5.0\n\nObject 以 key: value 的形式表示，将 this.data 中的 key 对应的值改变成 value。\n\n其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。\n\n注意：\n\n 1. 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。\n 2. 仅支持设置可 JSON 化的数据。\n 3. 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。\n 4. 请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。\n\n示例代码：\n\n在开发者工具中预览效果\n\n\x3c!--index.wxml--\x3e\n<view>{{text}}</view>\n<button bindtap=\"changeText\"> Change normal data </button>\n<view>{{num}}</view>\n<button bindtap=\"changeNum\"> Change normal num </button>\n<view>{{array[0].text}}</view>\n<button bindtap=\"changeItemInArray\"> Change Array data </button>\n<view>{{object.text}}</view>\n<button bindtap=\"changeItemInObject\"> Change Object data </button>\n<view>{{newField.text}}</view>\n<button bindtap=\"addNewField\"> Add new data </button>\n// index.js\nPage({\n  data: {\n    text: 'init data',\n    num: 0,\n    array: [{text: 'init data'}],\n    object: {\n      text: 'init data'\n    }\n  },\n  changeText: function() {\n    // this.data.text = 'changed data' // 不要直接修改 this.data\n    // 应该使用 setData\n    this.setData({\n      text: 'changed data'\n    })\n  },\n  changeNum: function() {\n    // 或者，可以修改 this.data 之后马上用 setData 设置一下修改了的字段\n    this.data.num = 1\n    this.setData({\n      num: this.data.num\n    })\n  },\n  changeItemInArray: function() {\n    // 对于对象或数组字段，可以直接修改一个其下的子字段，这样做通常比修改整个对象或数组更好\n    this.setData({\n      'array[0].text':'changed data'\n    })\n  },\n  changeItemInObject: function(){\n    this.setData({\n      'object.text': 'changed data'\n    });\n  },\n  addNewField: function() {\n    this.setData({\n      'newField.text': 'new data'\n    })\n  }\n})\n\n\n\n# 页面间通信\n\n> 基础库 2.7.3 开始支持，低版本需做兼容处理。\n\n如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道：\n\n * 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；\n * wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。\n\n这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。\n\n在开发者工具中预览效果",normalizedContent:"# page 注册与管理\n\n对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。\n\n//index.js\npage({\n  data: {\n    // 页面第一次渲染使用的初始数据\n    // 渲染层可以通过 wxml 对数据进行绑定\n    text: \"this is page data.\"\n  },\n  onload: function(options) {\n    // 页面加载时触发\n    // 一个页面只会调用一次，可以在 onload 的参数中获取打开当前页面路径中的参数\n  },\n  onshow: function() {\n    // 页面显示/切入前台时触发\n  },\n  onready: function() {\n    // 页面初次渲染完成时触发\n    // 一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互\n  },\n  onhide: function() {\n    // 页面隐藏/切入后台时触发\n    // 如 wx.navigateto 或底部 tab 切换到其他页面，小程序切入后台等\n  },\n  onunload: function() {\n    // 页面卸载时触发\n    // 如 wx.redirectto 或 wx.navigateback 到其他页面时\n  },\n  onpulldownrefresh: function() {\n    // 监听用户下拉刷新事件\n  },\n  onreachbottom: function() {\n    // 监听用户上拉触底事件\n  },\n  onshareappmessage: function () {\n    // 监听用户点击页面内转发按钮（button 组件 open-type=\"share\"）\n    // 或右上角菜单“转发”按钮的行为，并自定义转发内容\n  },\n  onpagescroll: function() {\n    // 监听用户滑动页面事件\n  },\n  onresize: function() {\n    // 小程序屏幕旋转时触发\n  },\n  ontabitemtap(item) {\n    console.log(item.index)\n    console.log(item.pagepath)\n    console.log(item.text)\n  },\n  // event handler.\n  viewtap: function() {\n    this.setdata({\n      text: 'set some data for updating view.'\n    }, function() {\n      // this is setdata callback\n    })\n  },\n  customdata: {\n    hi: 'mina'\n  }\n})\n\n\n\n# data\n\ndata 是页面第一次渲染使用的初始数据。\n\n页面加载时，data 将会以json字符串的形式由逻辑层传至渲染层，因此data中的数据必须是可以转成json的类型：字符串，数字，布尔值，对象，数组。\n\n渲染层可以通过 wxml 对数据进行绑定。\n\n示例代码：\n\n在开发者工具中预览效果\n\n<view>{{text}}</view>\n<view>{{array[0].msg}}</view>\npage({\n  data: {\n    text: 'init data',\n    array: [{msg: '1'}, {msg: '2'}]\n  }\n})\n\n\n\n# 生命周期回调函数\n\n\n# onload(object query)\n\n页面加载时触发。一个页面只会调用一次，可以在 onload 的参数中获取打开当前页面路径中的参数。\n\n参数：\n\n名称      类型       说明\nquery   object   打开当前页面路径中的参数\n\n\n# onshow()\n\n页面显示/切入前台时触发。\n\n# onready()\n\n页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。\n\n注意：对界面内容进行设置的 api 如wx.setnavigationbartitle，请在onready之后进行。详见生命周期\n\n\n# onhide()\n\n页面隐藏/切入后台时触发。 如 wx.navigateto 或底部 tab 切换到其他页面，小程序切入后台等。\n\n\n# onunload()\n\n页面卸载时触发。如wx.redirectto或wx.navigateback到其他页面时。\n\n\n# 页面事件处理函数\n\n\n# onpulldownrefresh()\n\n监听用户下拉刷新事件。\n\n * 需要在app.json的window选项中或页面配置中开启enablepulldownrefresh。\n * 可以通过wx.startpulldownrefresh触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。\n * 当处理完数据刷新后，wx.stoppulldownrefresh可以停止当前页面的下拉刷新。\n\n\n# onreachbottom()\n\n监听用户上拉触底事件。\n\n * 可以在app.json的window选项中或页面配置中设置触发距离onreachbottomdistance。\n * 在触发距离内滑动期间，本事件只会被触发一次。\n\n\n# onpagescroll(object object)\n\n监听用户滑动页面事件。\n\n参数 object object:\n\n属性          类型       说明\nscrolltop   number   页面在垂直方向已滚动的距离（单位px）\n\n注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。 注意：请避免在 onpagescroll 中过于频繁的执行 setdata 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。\n\n\n# onaddtofavorites(object object)\n\n> 本接口为 beta 版本，安卓 7.0.15 版本起支持，暂只在安卓平台支持\n\n监听用户点击右上角菜单“收藏”按钮的行为，并自定义收藏内容。\n\n参数 object object:\n\n参数           类型       说明\nwebviewurl   string   页面中包含web-view组件时，返回当前web-view的url\n\n此事件处理函数需要 return 一个 object，用于自定义收藏内容：\n\n字段         说明                   默认值\ntitle      自定义标题                页面标题或账号名称\nimageurl   自定义图片，显示图片长宽比为 1：1   页面截图\nquery      自定义query字段           当前页面的query\n\n示例代码\n\npage({\n  onaddtofavorites(res) {\n    // webview 页面返回 webviewurl\n    console.log('webviewurl: ', res.webviewurl)\n    return {\n      title: '自定义标题',\n      imageurl: 'http://demo.png',\n      query: 'name=xxx&age=xxx',\n    }\n  }\n})\n\n\n\n# onshareappmessage(object object)\n\n监听用户点击页面内转发按钮（button 组件 open-type=\"share\"）或右上角菜单“转发”按钮的行为，并自定义转发内容。\n\n注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮\n\n参数 object object:\n\n参数           类型       说明                                                           最低版本\nfrom         string   转发事件来源。 button：页面内转发按钮； menu：右上角转发菜单                         1.2.4\ntarget       object   如果 from 值是 button，则 target 是触发这次转发事件的 button，否则为 undefined   1.2.4\nwebviewurl   string   页面中包含web-view组件时，返回当前web-view的url                            1.6.4\n\n此事件处理函数需要 return 一个 object，用于自定义转发内容，返回内容如下：\n\n自定义转发内容 基础库 2.8.1 起，分享图支持云图片。\n\n字段         说明                                                          默认值                         最低版本\ntitle      转发标题                                                        当前小程序名称                     \npath       转发路径                                                        当前页面 path ，必须是以 / 开头的完整路径   \nimageurl   自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持png及jpg。显示图片长宽比是 5:4。   使用默认截图                      1.5.0\npromise    如果该参数存在，则以 resolve 结果为准，如果三秒内不 resolve，分享会使用上面传入的默认参数                                   2.12.0\n\n示例代码\n\n在开发者工具中预览效果\n\npage({\n  onshareappmessage() {\n    const promise = new promise(resolve => {\n      settimeout(() => {\n        resolve({\n          title: '自定义转发标题'\n        })\n      }, 2000)\n    })\n    return {\n      title: '自定义转发标题',\n      path: '/page/user?id=123',\n      promise \n    }\n  }\n})\n\n\n\n# onsharetimeline()\n\n> 基础库 2.11.3 开始支持，低版本需做兼容处理。\n\n> 本接口为 beta 版本，暂只在 android 平台支持，详见分享到朋友圈 (beta)\n\n监听右上角菜单“分享到朋友圈”按钮的行为，并自定义分享内容。\n\n注意：只有定义了此事件处理函数，右上角菜单才会显示“分享到朋友圈”按钮\n\n自定义转发内容\n\n事件处理函数返回一个 object，用于自定义分享内容，不支持自定义页面路径，返回内容如下：\n\n字段         说明                                                 默认值            最低版本\ntitle      自定义标题，即朋友圈列表页上显示的标题                                当前小程序名称        \nquery      自定义页面路径中携带的参数，如 path?a=1&b=2 的 “?” 后面部分            当前页面路径携带的参数    \nimageurl   自定义图片路径，可以是本地文件或者网络图片。支持 png 及 jpg，显示图片长宽比是 1:1。   默认使用小程序 logo   \n\n\n# onresize(object object)\n\n> 基础库 2.4.0 开始支持，低版本需做兼容处理。\n\n小程序屏幕旋转时触发。详见 响应显示区域变化\n\n\n# ontabitemtap(object object)\n\n> 基础库 1.9.0 开始支持，低版本需做兼容处理。\n\n点击 tab 时触发\n\nobject 参数说明：\n\n参数         类型       说明                   最低版本\nindex      string   被点击tabitem的序号，从0开始   1.9.0\npagepath   string   被点击tabitem的页面路径      1.9.0\ntext       string   被点击tabitem的按钮文字      1.9.0\n\n示例代码：\n\npage({\n  ontabitemtap(item) {\n    console.log(item.index)\n    console.log(item.pagepath)\n    console.log(item.text)\n  }\n})\n\n\n\n# onsaveexitstate()\n\n> 基础库 2.7.4 开始支持，低版本需做兼容处理。\n\n每当小程序可能被销毁之前，页面回调函数 onsaveexitstate 会被调用，可以进行退出状态的保存。\n\n\n# 组件事件处理函数\n\npage 中还可以定义组件事件处理函数。在渲染层的组件中加入事件处理，当事件被触发时，就会执行 page 中定义的事件处理函数。\n\n示例代码：\n\n在开发者工具中预览效果\n\n<view bindtap=\"viewtap\"> click me </view>\npage({\n  viewtap: function() {\n    console.log('view tap')\n  }\n})\n\n\n\n# page.route\n\n> 基础库 1.2.0 开始支持，低版本需做兼容处理。\n\n到当前页面的路径，类型为string。\n\npage({\n  onshow: function() {\n    console.log(this.route)\n  }\n})\n\n\n\n# page.prototype.setdata(object data, function callback)\n\nsetdata 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。\n\n# 参数说明\n\n字段         类型         必填   描述                         最低版本\ndata       object     是    这次要改变的数据                   \ncallback   function   否    setdata引起的界面更新渲染完毕后的回调函数   1.5.0\n\nobject 以 key: value 的形式表示，将 this.data 中的 key 对应的值改变成 value。\n\n其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。\n\n注意：\n\n 1. 直接修改 this.data 而不调用 this.setdata 是无法改变页面的状态的，还会造成数据不一致。\n 2. 仅支持设置可 json 化的数据。\n 3. 单次设置的数据不能超过1024kb，请尽量避免一次设置过多的数据。\n 4. 请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。\n\n示例代码：\n\n在开发者工具中预览效果\n\n\x3c!--index.wxml--\x3e\n<view>{{text}}</view>\n<button bindtap=\"changetext\"> change normal data </button>\n<view>{{num}}</view>\n<button bindtap=\"changenum\"> change normal num </button>\n<view>{{array[0].text}}</view>\n<button bindtap=\"changeiteminarray\"> change array data </button>\n<view>{{object.text}}</view>\n<button bindtap=\"changeiteminobject\"> change object data </button>\n<view>{{newfield.text}}</view>\n<button bindtap=\"addnewfield\"> add new data </button>\n// index.js\npage({\n  data: {\n    text: 'init data',\n    num: 0,\n    array: [{text: 'init data'}],\n    object: {\n      text: 'init data'\n    }\n  },\n  changetext: function() {\n    // this.data.text = 'changed data' // 不要直接修改 this.data\n    // 应该使用 setdata\n    this.setdata({\n      text: 'changed data'\n    })\n  },\n  changenum: function() {\n    // 或者，可以修改 this.data 之后马上用 setdata 设置一下修改了的字段\n    this.data.num = 1\n    this.setdata({\n      num: this.data.num\n    })\n  },\n  changeiteminarray: function() {\n    // 对于对象或数组字段，可以直接修改一个其下的子字段，这样做通常比修改整个对象或数组更好\n    this.setdata({\n      'array[0].text':'changed data'\n    })\n  },\n  changeiteminobject: function(){\n    this.setdata({\n      'object.text': 'changed data'\n    });\n  },\n  addnewfield: function() {\n    this.setdata({\n      'newfield.text': 'new data'\n    })\n  }\n})\n\n\n\n# 页面间通信\n\n> 基础库 2.7.3 开始支持，低版本需做兼容处理。\n\n如果一个页面由另一个页面通过 wx.navigateto 打开，这两个页面间将建立一条数据通道：\n\n * 被打开的页面可以通过 this.getopenereventchannel() 方法来获得一个 eventchannel 对象；\n * wx.navigateto 的 success 回调中也包含一个 eventchannel 对象。\n\n这两个 eventchannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。\n\n在开发者工具中预览效果",charsets:{cjk:!0}},{title:"事件处理",frontmatter:{},regularPath:"/mp/get-started/event-binding.html",relativePath:"mp/get-started/event-binding.md",key:"v-03e20728",path:"/mp/get-started/event-binding.html",headers:[{level:2,title:"什么是事件",slug:"什么是事件",normalizedTitle:"什么是事件",charIndex:11},{level:2,title:"事件的使用方式",slug:"事件的使用方式",normalizedTitle:"事件的使用方式",charIndex:148},{level:2,title:"事件详解",slug:"事件详解",normalizedTitle:"事件详解",charIndex:917},{level:3,title:"事件分类",slug:"事件分类",normalizedTitle:"事件分类",charIndex:926},{level:3,title:"普通事件绑定",slug:"普通事件绑定",normalizedTitle:"普通事件绑定",charIndex:2087},{level:3,title:"绑定并阻止事件冒泡",slug:"绑定并阻止事件冒泡",normalizedTitle:"绑定并阻止事件冒泡",charIndex:2471},{level:3,title:"互斥事件绑定",slug:"互斥事件绑定",normalizedTitle:"互斥事件绑定",charIndex:2915},{level:3,title:"事件的捕获阶段",slug:"事件的捕获阶段",normalizedTitle:"事件的捕获阶段",charIndex:3450},{level:3,title:"事件对象",slug:"事件对象",normalizedTitle:"事件对象",charIndex:107}],headersStr:"什么是事件 事件的使用方式 事件详解 事件分类 普通事件绑定 绑定并阻止事件冒泡 互斥事件绑定 事件的捕获阶段 事件对象",content:'# 事件处理\n\n\n# 什么是事件\n\n * 事件是视图层到逻辑层的通讯方式。\n * 事件可以将用户的行为反馈到逻辑层进行处理。\n * 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\n * 事件对象可以携带额外信息，如 id, dataset, touches。\n\n\n# 事件的使用方式\n\n * 在组件中绑定一个事件处理函数。\n\n如 bindtap，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。\n\n<view id="tapTest" data-hi="Weixin" bindtap="tapName"> Click me! </view>\n\n\n * 在相应的 Page 定义中写上相应的事件处理函数，参数是 event。\n\nPage({\n  tapName: function(event) {\n    console.log(event)\n  }\n})\n\n\n * 可以看到 log 出来的信息大致如下：\n\n{\n  "type":"tap",\n  "timeStamp":895,\n  "target": {\n    "id": "tapTest",\n    "dataset":  {\n      "hi":"Weixin"\n    }\n  },\n  "currentTarget":  {\n    "id": "tapTest",\n    "dataset": {\n      "hi":"Weixin"\n    }\n  },\n  "detail": {\n    "x":53,\n    "y":14\n  },\n  "touches":[{\n    "identifier":0,\n    "pageX":53,\n    "pageY":14,\n    "clientX":53,\n    "clientY":14\n  }],\n  "changedTouches":[{\n    "identifier":0,\n    "pageX":53,\n    "pageY":14,\n    "clientX":53,\n    "clientY":14\n  }]\n}\n\n\n\n# 事件详解\n\n\n# 事件分类\n\n事件分为冒泡事件和非冒泡事件：\n\n 1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。\n 2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。\n\nWXML 的冒泡事件列表：\n\n类型                   触发条件                                              最低版本\ntouchstart           手指触摸动作开始                                          \ntouchmove            手指触摸后移动                                           \ntouchcancel          手指触摸动作被打断，如来电提醒，弹窗                                \ntouchend             手指触摸动作结束                                          \ntap                  手指触摸后马上离开                                         \nlongpress            手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发   1.5.0\nlongtap              手指触摸后，超过350ms再离开（推荐使用longpress事件代替）               \ntransitionend        会在 WXSS transition 或 wx.createAnimation 动画结束后触发   \nanimationstart       会在一个 WXSS animation 动画开始时触发                       \nanimationiteration   会在一个 WXSS animation 一次迭代结束时触发                     \nanimationend         会在一个 WXSS animation 动画完成时触发                       \ntouchforcechange     在支持 3D Touch 的 iPhone 设备，重按时会触发                   1.9.90\n\n注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个组件)\n\n\n# 普通事件绑定\n\n事件绑定的写法类似于组件的属性，如：\n\n<view bindtap="handleTap">\n    Click here!\n</view>\n\n\n如果用户点击这个 view ，则页面的 handleTap 会被调用。\n\n事件绑定函数可以是一个数据绑定，如：\n\n<view bindtap="{{ handlerName }}">\n    Click here!\n</view>\n\n\n此时，页面的 this.data.handlerName 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。\n\n自基础库版本 1.5.0 起，在大多数组件和自定义组件中， bind 后可以紧跟一个冒号，其含义不变，如 bind:tap 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。\n\n\n# 绑定并阻止事件冒泡\n\n除 bind 外，也可以用 catch 来绑定事件。与 bind 不同， catch 会阻止事件向上冒泡。\n\n例如在下边这个例子中，点击 inner view 会先后调用handleTap3和handleTap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handleTap2，点击 outer view 会触发handleTap1。\n\n<view id="outer" bindtap="handleTap1">\n  outer view\n  <view id="middle" catchtap="handleTap2">\n    middle view\n    <view id="inner" bindtap="handleTap3">\n      inner view\n    </view>\n  </view>\n</view>\n\n\n\n# 互斥事件绑定\n\n自基础库版本 2.8.2 起，除 bind 和 catch 外，还可以使用 mut-bind 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。\n\n换而言之，所有 mut-bind 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 bind 和 catch 的绑定效果。\n\n例如在下边这个例子中，点击 inner view 会先后调用 handleTap3 和 handleTap2 ，点击 middle view 会调用 handleTap2 和 handleTap1 。\n\n<view id="outer" mut-bind:tap="handleTap1">\n  outer view\n  <view id="middle" bindtap="handleTap2">\n    middle view\n    <view id="inner" mut-bind:tap="handleTap3">\n      inner view\n    </view>\n  </view>\n</view>\n\n\n\n# 事件的捕获阶段\n\n自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。\n\n在下面的代码中，点击 inner view 会先后调用handleTap2、handleTap4、handleTap3、handleTap1。\n\n<view id="outer" bind:touchstart="handleTap1" capture-bind:touchstart="handleTap2">\n  outer view\n  <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">\n    inner view\n  </view>\n</view>\n\n\n如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handleTap2。\n\n<view id="outer" bind:touchstart="handleTap1" capture-catch:touchstart="handleTap2">\n  outer view\n  <view id="inner" bind:touchstart="handleTap3" capture-bind:touchstart="handleTap4">\n    inner view\n  </view>\n</view>\n\n\n\n# 事件对象\n\n如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。\n\nBaseEvent 基础事件对象属性列表：\n\n属性              类型        说明                基础库版本\ntype            String    事件类型              \ntimeStamp       Integer   事件生成时的时间戳         \ntarget          Object    触发事件的组件的一些属性值集合   \ncurrentTarget   Object    当前组件的一些属性值集合      \nmark            Object    事件标记数据            2.7.1\n\nCustomEvent 自定义事件对象属性列表（继承 BaseEvent）：\n\n属性       类型       说明\ndetail   Object   额外的信息\n\nTouchEvent 触摸事件对象属性列表（继承 BaseEvent）：\n\n属性               类型      说明\ntouches          Array   触摸事件，当前停留在屏幕中的触摸点信息的数组\nchangedTouches   Array   触摸事件，当前变化的触摸点信息的数组\n\n特殊事件： canvas 中的触摸事件不可冒泡，所以没有 currentTarget。\n\n# type\n\n代表事件的类型。\n\n# timeStamp\n\n页面打开到触发事件所经过的毫秒数。\n\n# target\n\n触发事件的源组件。\n\n属性        类型       说明\nid        String   事件源组件的id\ndataset   Object   事件源组件上由data-开头的自定义属性组成的集合\n\n# currentTarget\n\n事件绑定的当前组件。\n\n属性        类型       说明\nid        String   当前组件的id\ndataset   Object   当前组件上由data-开头的自定义属性组成的集合\n\n说明： target 和 currentTarget 可以参考上例中，点击 inner view 时，handleTap3 收到的事件对象 target 和 currentTarget 都是 inner，而 handleTap2 收到的事件对象 target 就是 inner，currentTarget 就是 middle。\n\n# dataset\n\n在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。\n\n在 WXML 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：\n\n * data-element-type ，最终会呈现为 event.currentTarget.dataset.elementType ；\n * data-elementType ，最终会呈现为 event.currentTarget.dataset.elementtype 。\n\n示例：\n\n<view data-alpha-beta="1" data-alphaBeta="2" bindtap="bindViewTap"> DataSet Test </view>\nPage({\n  bindViewTap:function(event){\n    event.currentTarget.dataset.alphaBeta === 1 // - 会转为驼峰写法\n    event.currentTarget.dataset.alphabeta === 2 // 大写会转为小写\n  }\n})\n\n\n# mark\n\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。\n\n当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）\n\n代码示例：\n\n在开发者工具中预览效果\n\n<view mark:myMark="last" bindtap="bindViewTap">\n  <button mark:anotherMark="leaf" bindtap="bindButtonTap">按钮</button>\n</view>\n\n\n在上述 WXML 中，如果按钮被点击，将触发 bindViewTap 和 bindButtonTap 两个事件，事件携带的 event.mark 将包含 myMark 和 anotherMark 两项。\n\nPage({\n  bindViewTap: function(e) {\n    e.mark.myMark === "last" // true\n    e.mark.anotherMark === "leaf" // true\n  }\n})\n\n\nmark 和 dataset 很相似，主要区别在于： mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。\n\n细节注意事项：\n\n * 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。\n * 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。\n * 不同于 dataset ，节点的 mark 不会做连字符和大小写转换。\n\n# touches\n\ntouches 是一个数组，每个元素为一个 Touch 对象（canvas 触摸事件中携带的 touches 是 CanvasTouch 数组）。 表示当前停留在屏幕上的触摸点。\n\n# Touch 对象\n\n属性                 类型       说明\nidentifier         Number   触摸点的标识符\npageX, pageY       Number   距离文档左上角的距离，文档的左上角为原点 ，横向为X轴，纵向为Y轴\nclientX, clientY   Number   距离页面可显示区域（屏幕除去导航条）左上角距离，横向为X轴，纵向为Y轴\n\n# CanvasTouch 对象\n\n属性           类型       说明                                             特殊说明\nidentifier   Number   触摸点的标识符                                        \nx, y         Number   距离 Canvas 左上角的距离，Canvas 的左上角为原点 ，横向为X轴，纵向为Y轴   \n\n# changedTouches\n\nchangedTouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。\n\n# detail\n\n自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。\n\n点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。',normalizedContent:'# 事件处理\n\n\n# 什么是事件\n\n * 事件是视图层到逻辑层的通讯方式。\n * 事件可以将用户的行为反馈到逻辑层进行处理。\n * 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。\n * 事件对象可以携带额外信息，如 id, dataset, touches。\n\n\n# 事件的使用方式\n\n * 在组件中绑定一个事件处理函数。\n\n如 bindtap，当用户点击该组件的时候会在该页面对应的 page 中找到相应的事件处理函数。\n\n<view id="taptest" data-hi="weixin" bindtap="tapname"> click me! </view>\n\n\n * 在相应的 page 定义中写上相应的事件处理函数，参数是 event。\n\npage({\n  tapname: function(event) {\n    console.log(event)\n  }\n})\n\n\n * 可以看到 log 出来的信息大致如下：\n\n{\n  "type":"tap",\n  "timestamp":895,\n  "target": {\n    "id": "taptest",\n    "dataset":  {\n      "hi":"weixin"\n    }\n  },\n  "currenttarget":  {\n    "id": "taptest",\n    "dataset": {\n      "hi":"weixin"\n    }\n  },\n  "detail": {\n    "x":53,\n    "y":14\n  },\n  "touches":[{\n    "identifier":0,\n    "pagex":53,\n    "pagey":14,\n    "clientx":53,\n    "clienty":14\n  }],\n  "changedtouches":[{\n    "identifier":0,\n    "pagex":53,\n    "pagey":14,\n    "clientx":53,\n    "clienty":14\n  }]\n}\n\n\n\n# 事件详解\n\n\n# 事件分类\n\n事件分为冒泡事件和非冒泡事件：\n\n 1. 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。\n 2. 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。\n\nwxml 的冒泡事件列表：\n\n类型                   触发条件                                              最低版本\ntouchstart           手指触摸动作开始                                          \ntouchmove            手指触摸后移动                                           \ntouchcancel          手指触摸动作被打断，如来电提醒，弹窗                                \ntouchend             手指触摸动作结束                                          \ntap                  手指触摸后马上离开                                         \nlongpress            手指触摸后，超过350ms再离开，如果指定了事件回调函数并触发了这个事件，tap事件将不被触发   1.5.0\nlongtap              手指触摸后，超过350ms再离开（推荐使用longpress事件代替）               \ntransitionend        会在 wxss transition 或 wx.createanimation 动画结束后触发   \nanimationstart       会在一个 wxss animation 动画开始时触发                       \nanimationiteration   会在一个 wxss animation 一次迭代结束时触发                     \nanimationend         会在一个 wxss animation 动画完成时触发                       \ntouchforcechange     在支持 3d touch 的 iphone 设备，重按时会触发                   1.9.90\n\n注：除上表之外的其他组件自定义事件如无特殊声明都是非冒泡事件，如 form 的submit事件，input 的input事件，scroll-view 的scroll事件，(详见各个组件)\n\n\n# 普通事件绑定\n\n事件绑定的写法类似于组件的属性，如：\n\n<view bindtap="handletap">\n    click here!\n</view>\n\n\n如果用户点击这个 view ，则页面的 handletap 会被调用。\n\n事件绑定函数可以是一个数据绑定，如：\n\n<view bindtap="{{ handlername }}">\n    click here!\n</view>\n\n\n此时，页面的 this.data.handlername 必须是一个字符串，指定事件处理函数名；如果它是个空字符串，则这个绑定会失效（可以利用这个特性来暂时禁用一些事件）。\n\n自基础库版本 1.5.0 起，在大多数组件和自定义组件中， bind 后可以紧跟一个冒号，其含义不变，如 bind:tap 。基础库版本 2.8.1 起，在所有组件中开始提供这个支持。\n\n\n# 绑定并阻止事件冒泡\n\n除 bind 外，也可以用 catch 来绑定事件。与 bind 不同， catch 会阻止事件向上冒泡。\n\n例如在下边这个例子中，点击 inner view 会先后调用handletap3和handletap2(因为tap事件会冒泡到 middle view，而 middle view 阻止了 tap 事件冒泡，不再向父节点传递)，点击 middle view 会触发handletap2，点击 outer view 会触发handletap1。\n\n<view id="outer" bindtap="handletap1">\n  outer view\n  <view id="middle" catchtap="handletap2">\n    middle view\n    <view id="inner" bindtap="handletap3">\n      inner view\n    </view>\n  </view>\n</view>\n\n\n\n# 互斥事件绑定\n\n自基础库版本 2.8.2 起，除 bind 和 catch 外，还可以使用 mut-bind 来绑定事件。一个 mut-bind 触发后，如果事件冒泡到其他节点上，其他节点上的 mut-bind 绑定函数不会被触发，但 bind 绑定函数和 catch 绑定函数依旧会被触发。\n\n换而言之，所有 mut-bind 是“互斥”的，只会有其中一个绑定函数被触发。同时，它完全不影响 bind 和 catch 的绑定效果。\n\n例如在下边这个例子中，点击 inner view 会先后调用 handletap3 和 handletap2 ，点击 middle view 会调用 handletap2 和 handletap1 。\n\n<view id="outer" mut-bind:tap="handletap1">\n  outer view\n  <view id="middle" bindtap="handletap2">\n    middle view\n    <view id="inner" mut-bind:tap="handletap3">\n      inner view\n    </view>\n  </view>\n</view>\n\n\n\n# 事件的捕获阶段\n\n自基础库版本 1.5.0 起，触摸类事件支持捕获阶段。捕获阶段位于冒泡阶段之前，且在捕获阶段中，事件到达节点的顺序与冒泡阶段恰好相反。需要在捕获阶段监听事件时，可以采用capture-bind、capture-catch关键字，后者将中断捕获阶段和取消冒泡阶段。\n\n在下面的代码中，点击 inner view 会先后调用handletap2、handletap4、handletap3、handletap1。\n\n<view id="outer" bind:touchstart="handletap1" capture-bind:touchstart="handletap2">\n  outer view\n  <view id="inner" bind:touchstart="handletap3" capture-bind:touchstart="handletap4">\n    inner view\n  </view>\n</view>\n\n\n如果将上面代码中的第一个capture-bind改为capture-catch，将只触发handletap2。\n\n<view id="outer" bind:touchstart="handletap1" capture-catch:touchstart="handletap2">\n  outer view\n  <view id="inner" bind:touchstart="handletap3" capture-bind:touchstart="handletap4">\n    inner view\n  </view>\n</view>\n\n\n\n# 事件对象\n\n如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。\n\nbaseevent 基础事件对象属性列表：\n\n属性              类型        说明                基础库版本\ntype            string    事件类型              \ntimestamp       integer   事件生成时的时间戳         \ntarget          object    触发事件的组件的一些属性值集合   \ncurrenttarget   object    当前组件的一些属性值集合      \nmark            object    事件标记数据            2.7.1\n\ncustomevent 自定义事件对象属性列表（继承 baseevent）：\n\n属性       类型       说明\ndetail   object   额外的信息\n\ntouchevent 触摸事件对象属性列表（继承 baseevent）：\n\n属性               类型      说明\ntouches          array   触摸事件，当前停留在屏幕中的触摸点信息的数组\nchangedtouches   array   触摸事件，当前变化的触摸点信息的数组\n\n特殊事件： canvas 中的触摸事件不可冒泡，所以没有 currenttarget。\n\n# type\n\n代表事件的类型。\n\n# timestamp\n\n页面打开到触发事件所经过的毫秒数。\n\n# target\n\n触发事件的源组件。\n\n属性        类型       说明\nid        string   事件源组件的id\ndataset   object   事件源组件上由data-开头的自定义属性组成的集合\n\n# currenttarget\n\n事件绑定的当前组件。\n\n属性        类型       说明\nid        string   当前组件的id\ndataset   object   当前组件上由data-开头的自定义属性组成的集合\n\n说明： target 和 currenttarget 可以参考上例中，点击 inner view 时，handletap3 收到的事件对象 target 和 currenttarget 都是 inner，而 handletap2 收到的事件对象 target 就是 inner，currenttarget 就是 middle。\n\n# dataset\n\n在组件节点中可以附加一些自定义数据。这样，在事件中可以获取这些自定义的节点数据，用于事件的逻辑处理。\n\n在 wxml 中，这些自定义数据以 data- 开头，多个单词由连字符 - 连接。这种写法中，连字符写法会转换成驼峰写法，而大写字符会自动转成小写字符。如：\n\n * data-element-type ，最终会呈现为 event.currenttarget.dataset.elementtype ；\n * data-elementtype ，最终会呈现为 event.currenttarget.dataset.elementtype 。\n\n示例：\n\n<view data-alpha-beta="1" data-alphabeta="2" bindtap="bindviewtap"> dataset test </view>\npage({\n  bindviewtap:function(event){\n    event.currenttarget.dataset.alphabeta === 1 // - 会转为驼峰写法\n    event.currenttarget.dataset.alphabeta === 2 // 大写会转为小写\n  }\n})\n\n\n# mark\n\n在基础库版本 2.7.1 以上，可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。\n\n当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）\n\n代码示例：\n\n在开发者工具中预览效果\n\n<view mark:mymark="last" bindtap="bindviewtap">\n  <button mark:anothermark="leaf" bindtap="bindbuttontap">按钮</button>\n</view>\n\n\n在上述 wxml 中，如果按钮被点击，将触发 bindviewtap 和 bindbuttontap 两个事件，事件携带的 event.mark 将包含 mymark 和 anothermark 两项。\n\npage({\n  bindviewtap: function(e) {\n    e.mark.mymark === "last" // true\n    e.mark.anothermark === "leaf" // true\n  }\n})\n\n\nmark 和 dataset 很相似，主要区别在于： mark 会包含从触发事件的节点到根节点上所有的 mark: 属性值；而 dataset 仅包含一个节点的 data- 属性值。\n\n细节注意事项：\n\n * 如果存在同名的 mark ，父节点的 mark 会被子节点覆盖。\n * 在自定义组件中接收事件时， mark 不包含自定义组件外的节点的 mark 。\n * 不同于 dataset ，节点的 mark 不会做连字符和大小写转换。\n\n# touches\n\ntouches 是一个数组，每个元素为一个 touch 对象（canvas 触摸事件中携带的 touches 是 canvastouch 数组）。 表示当前停留在屏幕上的触摸点。\n\n# touch 对象\n\n属性                 类型       说明\nidentifier         number   触摸点的标识符\npagex, pagey       number   距离文档左上角的距离，文档的左上角为原点 ，横向为x轴，纵向为y轴\nclientx, clienty   number   距离页面可显示区域（屏幕除去导航条）左上角距离，横向为x轴，纵向为y轴\n\n# canvastouch 对象\n\n属性           类型       说明                                             特殊说明\nidentifier   number   触摸点的标识符                                        \nx, y         number   距离 canvas 左上角的距离，canvas 的左上角为原点 ，横向为x轴，纵向为y轴   \n\n# changedtouches\n\nchangedtouches 数据格式同 touches。 表示有变化的触摸点，如从无变有（touchstart），位置变化（touchmove），从有变无（touchend、touchcancel）。\n\n# detail\n\n自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。\n\n点击事件的detail 带有的 x, y 同 pagex, pagey 代表距离文档左上角的距离。',charsets:{cjk:!0}},{title:"浏览器工作流",frontmatter:{},regularPath:"/frontend-network/browser-workflow.html",relativePath:"frontend-network/browser-workflow.md",key:"v-155d8bd6",path:"/frontend-network/browser-workflow.html",headers:[{level:2,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:13},{level:3,title:"我们要讨论的浏览器",slug:"我们要讨论的浏览器",normalizedTitle:"我们要讨论的浏览器",charIndex:20},{level:3,title:"浏览器的主要功能",slug:"浏览器的主要功能",normalizedTitle:"浏览器的主要功能",charIndex:262},{level:3,title:"浏览器的高层结构",slug:"浏览器的高层结构",normalizedTitle:"浏览器的高层结构",charIndex:777},{level:2,title:"渲染引擎",slug:"渲染引擎",normalizedTitle:"渲染引擎",charIndex:885},{level:3,title:"渲染引擎",slug:"渲染引擎-2",normalizedTitle:"渲染引擎",charIndex:885},{level:3,title:"主流程",slug:"主流程",normalizedTitle:"主流程",charIndex:1719},{level:3,title:"解析 - 综述",slug:"解析-综述",normalizedTitle:"解析 - 综述",charIndex:2576},{level:3,title:"HTML 解析器",slug:"html-解析器",normalizedTitle:"html 解析器",charIndex:4987},{level:3,title:"CSS 解析",slug:"css-解析",normalizedTitle:"css 解析",charIndex:10912},{level:3,title:"处理脚本和样式表的顺序",slug:"处理脚本和样式表的顺序",normalizedTitle:"处理脚本和样式表的顺序",charIndex:12440},{level:3,title:"渲染树构建",slug:"渲染树构建",normalizedTitle:"渲染树构建",charIndex:1962},{level:3,title:"布局",slug:"布局",normalizedTitle:"布局",charIndex:1975},{level:3,title:"绘制",slug:"绘制",normalizedTitle:"绘制",charIndex:1034},{level:3,title:"动态变化",slug:"动态变化",normalizedTitle:"动态变化",charIndex:25251},{level:3,title:"渲染引擎的线程",slug:"渲染引擎的线程",normalizedTitle:"渲染引擎的线程",charIndex:25419},{level:3,title:"CSS2 可视化模型",slug:"css2-可视化模型",normalizedTitle:"css2 可视化模型",charIndex:25733},{level:3,title:"定位",slug:"定位",normalizedTitle:"定位",charIndex:14934},{level:3,title:"分层展示",slug:"分层展示",normalizedTitle:"分层展示",charIndex:27368}],headersStr:"概要 我们要讨论的浏览器 浏览器的主要功能 浏览器的高层结构 渲染引擎 渲染引擎 主流程 解析 - 综述 HTML 解析器 CSS 解析 处理脚本和样式表的顺序 渲染树构建 布局 绘制 动态变化 渲染引擎的线程 CSS2 可视化模型 定位 分层展示",content:'# 浏览器工作流\n\n\n# 概要\n\n\n# 我们要讨论的浏览器\n\n目前使用的主流浏览器有五个：Internet Explorer、Firefox、Safari、Chrome 浏览器和 Opera。本文中以开放源代码浏览器为例，即 Firefox、Chrome 浏览器和 Safari（部分开源）。根据 StatCounter 浏览器统计数据，目前（2011 年 8 月）Firefox、Safari 和 Chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。\n\n\n# 浏览器的主要功能\n\n浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。\n\n浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。 多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。\n\n浏览器的用户界面有很多彼此相同的元素，其中包括：\n\n * 用来输入 URI 的地址栏\n * 前进和后退按钮\n * 书签设置选项\n * 用于刷新和停止加载当前文档的刷新和停止按钮\n * 用于返回主页的主页按钮\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。\n\n\n# 浏览器的高层结构\n\n浏览器的主要组件为：\n\n 1. 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n 2. 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。\n 3. 渲染引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。\n 4. 网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。\n 5. 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n 6. JavaScript 解释器。用于解析和执行 JavaScript 代码。\n 7. 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。\n\n\n\n> 图：浏览器的主要组件。\n\n值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程。\n\n\n# 渲染引擎\n\n渲染引擎的作用嘛...当然就是“渲染”了，也就是在浏览器的屏幕上显示请求的内容。\n\n默认情况下，渲染引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。\n\n\n# 渲染引擎\n\n本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种渲染引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。\n\nWebKit 是一种开放源代码渲染引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。有关详情，请参阅 webkit.org。\n\n\n# 主流程\n\n渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程：\n\n\n\n> 图：渲染引擎的基本流程。\n\n渲染引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：渲染树。\n\n渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n渲染树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建渲染树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。\n\n# 主流程示例\n\n\n\n> 图 3：WebKit 主流程\n\n\n\n> 图 4：Mozilla 的 Gecko 渲染引擎主流程\n\n从图 3 和图 4 可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。\n\nGecko 将视觉格式化元素组成的树称为“框架树”(Frame Tree)。每个元素都是一个框架。WebKit 使用的术语是“渲染树”(Render Tree)，它由“渲染对象”组成。对于元素的放置，WebKit 使用的术语是“布局”(Layout)，而 Gecko 称之为“重排”(Reflow)。对于连接 DOM 节点和可视化信息从而创建渲染树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：\n\n\n# 解析 - 综述\n\n解析是渲染引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。\n\n解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。\n\n示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：\n\n\n\n> 图：数学表达式树节点\n\n# 语法\n\n解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。\n\n# 解析器和词法分析器的组合\n\n解析的过程可以分成两个子过程：词法分析和语法分析。\n\n词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。\n\n语法分析是应用语言的语法规则的过程。\n\n解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。\n\n\n\n> 图：从源文档到解析树\n\n解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。\n\n如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。\n\n# 翻译\n\n很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。\n\n\n\n> 图：编译流程\n\n# 解析示例\n\n在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。\n\n词汇：我们用的语言可包含整数、加号和减号。\n\n语法：\n\n 1. 构成语言的语法单位是表达式、项和运算符。\n 2. 我们用的语言可以包含任意数量的表达式。\n 3. 表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。\n 4. 运算符是加号或减号。\n 5. 项是一个整数或一个表达式。\n\n让我们分析一下 2 + 3 - 1。 匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。\n\n# 词汇和语法的正式定义\n\n词汇通常用正则表达式表示。\n\n例如，我们的示例语言可以定义如下：\n\nINTEGER :0|[1-9][0-9]*\nPLUS : +\nMINUS: -\n\n\n正如您所看到的，这里用正则表达式给出了整数的定义。\n\n语法通常使用一种称为 BNF 的格式来定义。我们的示例语言可以定义如下：\n\nexpression :=  term  operation  term\noperation :=  PLUS | MINUS\nterm := INTEGER | expression\n\n\n之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 BNF 格式表达的语法。有关正式定义，请参阅关于与上下文无关的语法的维基百科文章。\n\n# 解析器类型\n\n有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。\n\n让我们来看看这两种解析器会如何解析我们的示例：\n\n自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。\n\n自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。\n\n堆栈       输入\n         2 + 3 - 1\n项        + 3 - 1\n项运算      3 - 1\n表达式      - 1\n表达式运算符   1\n表达式      \n\n这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。\n\n# 自动生成解析器\n\n有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。\n\nWebKit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 Flex 以及用于创建解析器的 Bison（您也可能遇到 Lex 和 Yacc 这样的别名）。Flex 的输入是包含标记的正则表达式定义的文件。Bison 的输入是采用 BNF 格式的语言语法规则。\n\n\n# HTML 解析器\n\nHTML 解析器的任务是将 HTML 标记解析成解析树。\n\n# HTML 语法定义\n\nHTML 的词汇和语法在 W3C 组织创建的规范中进行了定义。当前的版本是 HTML4，HTML5 正在处理过程中。\n\n# 非与上下文无关的语法\n\n正如我们在解析过程的简介中已经了解到的，语法可以用 BNF 等格式进行正式定义。\n\n很遗憾，所有的常规解析器都不适用于 HTML（我并不是开玩笑，它们可以用于解析 CSS 和 JavaScript）。HTML 并不能很容易地用解析器所需的与上下文无关的语法来定义。\n\n有一种可以定义 HTML 的正规格式：DTD（Document Type Definition，文档类型定义），但它不是与上下文无关的语法。\n\n这初看起来很奇怪：HTML 和 XML 非常相似。有很多 XML 解析器可以使用。HTML 存在一个 XML 变体 (XHTML)，那么有什么大的区别呢？\n\n区别在于 HTML 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 XML 严格的语法不同，HTML 整体来看是一种“软性”的语法。\n\n显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 HTML 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，HTML 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 XML 解析器来解析。\n\n# HTML DTD\n\nHTML 的定义采用了 DTD 格式。此格式可用于定义 SGML 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，HTML DTD 无法构成与上下文无关的语法。\n\nDTD 存在一些变体。严格模式完全遵守 HTML 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 DTD 可以在这里找到：www.w3.org/TR/html4/strict.dtd\n\n# DOM\n\n解析器的输出“解析树”是由 DOM 元素和属性节点构成的树结构。DOM 是文档对象模型 (Document Object Model) 的缩写。它是 HTML 文档的对象表示，同时也是外部内容（例如 JavaScript）与 HTML 元素之间的接口。 解析树的根节点是“Document”对象。\n\nDOM 与标记之间几乎是一一对应的关系。比如下面这段标记：\n\n<html>\n  <body>\n    <p>\n      Hello World\n    </p>\n    <div> <img src="example.png"/></div>\n  </body>\n</html>\n\n\n可翻译成如下的 DOM 树：\n\n\n\n> 图：示例标记的 DOM 树\n\n和 HTML 一样，DOM 也是由 W3C 组织指定的。请参见 www.w3.org/DOM/DOMTR。这是关于文档操作的通用规范。其中一个特定模块描述针对 HTML 的元素。HTML 的定义可以在这里找到：www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html。\n\n我所说的树包含 DOM 节点，指的是树是由实现了某个 DOM 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。\n\n# 解析算法\n\n我们在之前章节已经说过，HTML 无法用常规的自上而下或自下而上的解析器进行解析。\n\n原因在于：\n\n 1. 语言的宽容本质。\n 2. 浏览器历来对一些常见的无效 HTML 用法采取包容态度。\n 3. 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 HTML 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。\n\n由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 HTML。\n\nHTML5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。\n\n标记化是词法分析过程，将输入内容解析成多个标记。HTML 标记包括起始标记、结束标记、属性名称和属性值。\n\n标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。\n\n\n\n> 图：HTML 解析流程（摘自 HTML5 规范)\n\n# 标记化算法\n\n该算法的输出结果是 HTML 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。\n\n基本示例 - 将下面的 HTML 代码标记化：\n\n<html>\n  <body>\n    Hello world\n  </body>\n</html>\n\n\n初始状态是数据状态。遇到字符 < 时，状态更改为标记打开状态。接收一个 a-z 字符会创建“起始标记”，状态更改为标记名称状态。这个状态会一直保持到接收 > 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。\n\n遇到 > 标记时，会发送当前的标记，状态改回数据状态。<body> 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到数据状态。接收到 Hello world 中的 H 字符时，将创建并发送字符标记，直到接收 </body> 中的 <。我们将为 Hello world 中的每个字符都发送一个字符标记。\n\n现在我们回到标记打开状态。接收下一个输入字符 / 时，会创建 end tag token 并改为标记名称状态。我们会再次保持这个状态，直到接收 >。然后将发送新的标记，并回到数据状态。</html> 输入也会进行同样的处理。\n\n\n\n> 图：对示例输入进行标记化\n\n# 树构建算法\n\n在创建解析器的同时，也会创建 Document 对象。在树构建阶段，以 Document 为根节点的 DOM 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 DOM 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 DOM 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。\n\n让我们来看看示例输入的树构建过程：\n\n<html>\n  <body>\n    Hello world\n  </body>\n</html>\n\n\n树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是initial mode。接收 HTML 标记后转为before html模式，并在这个模式下重新处理此标记。这样会创建一个 HTMLHtmlElement 元素，并将其附加到 Document 根对象上。\n\n然后状态将改为before head。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 HTMLHeadElement，并将其添加到树中。\n\n现在我们进入了in head模式，然后转入after head模式。系统对 body 标记进行重新处理，创建并插入 HTMLBodyElement，同时模式转变为in body。\n\n现在，接收由“Hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“Text”节点，而其他字符也将附加到该节点。\n\n接收 body 结束标记会触发after body模式。现在我们将接收 HTML 结束标记，然后进入after after body模式。接收到文件结束标记后，解析过程就此结束。\n\n\n\n> 图：示例 HTML 的树构建\n\n# 解析结束后的操作\n\n在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。\n\n您可以在 HTML5 规范中查看标记化和树构建的完整算法\n\n# 浏览器的容错机制\n\n您在浏览 HTML 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。\n\n以下面的 HTML 代码为例：\n\n<html>\n  <mytag>\n  </mytag>\n  <div>\n  <p>\n  </div>\n    Really lousy HTML\n  </p>\n</html>\n\n\n在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 HTML 网页作者的错误。\n\n不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 HTML 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 HTML 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。\n\nHTML5 规范定义了一部分这样的要求。WebKit 在 HTML 解析器类的开头注释中对此做了很好的概括。\n\n> 解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。\n> \n> 遗憾的是，我们不得不处理很多格式错误的 HTML 文档，所以解析器必须具备一定的容错性。\n> \n> 我们至少要能够处理以下错误情况：\n> \n>  1. 明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。\n>  2. 我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：HTML HEAD BODY TBODY TR TD LI（还有遗漏的吗？）。\n>  3. 向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。\n>  4. 如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。\n\n让我们看一些 WebKit 容错的示例：\n\n# 使用了 </br> 而不是 <br>\n\n有些网站使用了 </br> 而不是 <br>。为了与 IE 和 Firefox 兼容，WebKit 将其与 <br> 做同样的处理。 代码如下：\n\nif (t->isCloseTag(brTag) && m_document->inCompatMode()) {\n     reportError(MalformedBRError);\n     t->beginTag = true;\n}\n\n\n请注意，错误处理是在内部进行的，用户并不会看到这个过程。\n\n# 离散表格\n\n离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。 比如以下的示例：\n\n<table>\n    <table>\n        <tr><td>inner table</td></tr>\n    </table>\n    <tr><td>outer table</td></tr>\n</table>\n\n\nWebKit 会将其层次结构更改为两个同级表格：\n\n<table>\n    <tr><td>outer table</td></tr>\n</table>\n<table>\n    <tr><td>inner table</td></tr>\n</table>\n\n\n代码如下：\n\nif (m_inStrayTableContent && localName == tableTag)\n        popBlock(tableTag);\n\n\nWebKit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。\n\n# 嵌套的表单元素\n\n如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。 代码如下：\n\nif (!m_currentFormElement) {\n        m_currentFormElement = new HTMLFormElement(formTag,    m_document);\n}\n\n\n# 过于复杂的标记层次结构\n\n代码的注释已经说得很清楚了。\n\n> 示例网站 www.liceo.edu.mx 嵌套了约 1500 个标记，全都来自一堆 <b> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。\n\nbool HTMLParser::allowNestedRedundantTag(const AtomicString& tagName)\n{\n\nunsigned i = 0;\nfor (HTMLStackElem* curr = m_blockStack;\n         i < cMaxRedundantTagDepth && curr && curr->tagName == tagName;\n     curr = curr->next, i++) { }\nreturn i != cMaxRedundantTagDepth;\n}\n\n\n# 放错位置的 html 或者 body 结束标记\n\n同样，代码的注释已经说得很清楚了。\n\n> 支持格式非常糟糕的 HTML 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。\n\nif (t->tagName == htmlTag || t->tagName == bodyTag )\n        return;\n\n\n所以网页作者需要注意，除非您想作为反面教材出现在 WebKit 容错代码段的示例中，否则还请编写格式正确的 HTML 代码。\n\n\n# CSS 解析\n\n还记得简介中解析的概念吗？和 HTML 不同，CSS 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，CSS 规范定义了 CSS 的词法和语法。\n\n让我们来看一些示例： 词法语法（词汇）是针对各个标记用正则表达式定义的：\n\ncomment   \\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/\nnum   [0-9]+|[0-9]*"."[0-9]+\nnonascii  [\\200-\\377]\nnmstart   [_a-z]|{nonascii}|{escape}\nnmchar    [_a-z0-9-]|{nonascii}|{escape}\nname    {nmchar}+\nident   {nmstart}{nmchar}*\n\n\n“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 ID（通过“#”来引用）。\n\n语法是采用 BNF 格式描述的。\n\nruleset\n  : selector [ \',\' S* selector ]*\n    \'{\' S* declaration [ \';\' S* declaration ]* \'}\' S*\n  ;\nselector\n  : simple_selector [ combinator selector | S+ [ combinator? selector ]? ]?\n  ;\nsimple_selector\n  : element_name [ HASH | class | attrib | pseudo ]*\n  | [ HASH | class | attrib | pseudo ]+\n  ;\nclass\n  : \'.\' IDENT\n  ;\nelement_name\n  : IDENT | \'*\'\n  ;\nattrib\n  : \'[\' S* IDENT S* [ [ \'=\' | INCLUDES | DASHMATCH ] S*\n    [ IDENT | STRING ] S* ] \']\'\n  ;\npseudo\n  : \':\' [ IDENT | FUNCTION S* [IDENT S*] \')\' ]\n  ;\n\n\n解释：这是一个规则集的结构：\n\ndiv.error , a.error {\n  color:red;\n  font-weight:bold;\n}\n\n\ndiv.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：\n\nruleset\n  : selector [ \',\' S* selector ]*\n    \'{\' S* declaration [ \';\' S* declaration ]* \'}\' S*\n  ;\n\n\n这表示一个规则集就是一个选择器，或者由逗号和空格（S 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 BNF 格式定义。\n\n# WebKit CSS 解析器\n\nWebKit 使用 Flex 和 Bison 解析器生成器，通过 CSS 语法文件自动创建解析器。正如我们之前在解析器简介中所说，Bison 会创建自下而上的移位归约解析器。Firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。\n\n\n\n> 图：解析 CSS\n\n\n# 处理脚本和样式表的顺序\n\n# 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 HTML4 和 HTML5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。HTML5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n# 预解析\n\nWebKit 和 Firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n# 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n\n# 渲染树构建\n\n在 DOM 树构建的同时，浏览器还会构建另一个树结构：渲染树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。\n\nFirefox 将渲染树中的元素称为“框架”。WebKit 使用的术语是渲染器或渲染对象。 渲染器知道如何布局并将自身及其子元素绘制出来。 WebKits RenderObject 类是所有渲染器的基类，其定义如下：\n\nclass RenderObject{\n  virtual void layout();\n  virtual void paint(PaintInfo);\n  virtual void rect repaintRect();\n  Node* node;  //the DOM node\n  RenderStyle* style;  // the computed style\n  RenderLayer* containgLayer; //the containing z-index layer\n}\n\n\n每一个渲染器都代表了一个矩形的区域，通常对应于相关节点的 CSS 框，这一点在 CSS2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。 框的类型会受到与节点相关的“display”样式属性的影响（请参阅样式计算章节）。下面这段 WebKit 代码描述了根据 display 属性的不同，针对同一个 DOM 节点应创建什么类型的渲染器。\n\nRenderObject* RenderObject::createObject(Node* node, RenderStyle* style)\n{\n    Document* doc = node->document();\n    RenderArena* arena = doc->renderArena();\n    ...\n    RenderObject* o = 0;\n\n    switch (style->display()) {\n        case NONE:\n            break;\n        case INLINE:\n            o = new (arena) RenderInline(node);\n            break;\n        case BLOCK:\n            o = new (arena) RenderBlock(node);\n            break;\n        case INLINE_BLOCK:\n            o = new (arena) RenderBlock(node);\n            break;\n        case LIST_ITEM:\n            o = new (arena) RenderListItem(node);\n            break;\n       ...\n    }\n\n    return o;\n}\n\n\n元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。 在 WebKit 中，如果一个元素需要创建特殊的渲染器，就会替换 createRenderer 方法。渲染器所指向的样式对象中包含了一些和几何无关的信息。\n\n# 渲染树和 DOM 树的关系\n\n渲染器是和 DOM 元素相对应的，但并非一一对应。非可视化的 DOM 元素不会插入渲染树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在渲染树中（但是 visibility 属性值为“hidden”的元素仍会显示）。\n\n有一些 DOM 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的渲染器而添加。 另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 渲染器，以包裹 inline 元素。\n\n有一些渲染对象对应于 DOM 节点，但在树中所在的位置与 DOM 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。\n\n\n\n> 图：渲染树及其对应的 DOM 树。初始容器 block 为“viewport”，而在 WebKit 中则为“RenderView”对象。\n\n# 构建渲染树的流程\n\n在 Firefox 中，系统会针对 DOM 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 FrameConstructor，由该构造器解析样式（请参阅样式计算）并创建框架。\n\n在 WebKit 中，解析样式和创建渲染器的过程称为“附加”。每个 DOM 节点都有一个“attach”方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点“attach”方法。\n\n处理 html 和 body 标记就会构建渲染树根节点。这个根节点渲染对象对应于 CSS 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。Firefox 称之为 ViewPortFrame，而 WebKit 称之为 RenderView。这就是文档所指向的渲染对象。渲染树的其余部分以 DOM 树节点插入的形式来构建。\n\n请参阅关于处理模型的 CSS2 规范。\n\n# 样式计算\n\n构建渲染树时，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。\n\n样式包括来自各种来源的样式表、inline 样式元素和 HTML 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 CSS 样式属性。\n\n样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在“Firefox Profile”文件夹下）。\n\n样式计算存在以下难点：\n\n 1. 样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。\n\n 2. 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。\n    \n    例如下面这个组合选择器：\n    \n    div div div div{\n      ...\n    }\n    \n    \n    这意味着规则适用于作为 3 个 div 元素的子代的<div>。如果您要检查规则是否适用于某个指定的<div>元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。\n\n 3. 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。\n\n让我们来看看浏览器是如何处理这些问题的：\n\n# 共享样式数据\n\nWebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：\n\n 1.  这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）\n 2.  任何元素都没有 ID\n 3.  标记名称应匹配\n 4.  类属性应匹配\n 5.  映射属性的集合必须是完全相同的\n 6.  链接状态必须匹配\n 7.  焦点状态必须匹配\n 8.  任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配\n 9.  元素中不能有任何 inline 样式属性\n 10. 不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。\n\n# Firefox 规则树\n\n为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。\n\n\n\n> 图：Firefox 样式上下文树\n\n样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。\n\n所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。\n\n这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：\n\n\n\n假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 B - E - I（按照此顺序）。由于我们在树中已经计算出了路径 A - B - E - I - L，因此就已经有了此路径，这就减少了现在所需的工作量。\n\n让我们看看规则树如何帮助我们减少工作。\n\n# 结构划分\n\n样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。\n\n规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。\n\n# 使用规则树计算样式上下文\n\n在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。 如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。\n\n如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。\n\n如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。\n\n如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。\n\n让我们来看一个例子，假设我们有如下 HTML 代码：\n\n<html>\n  <body>\n    <div class="err" id="div1">\n      <p>\n        this is a <span class="big"> big error </span>\n        this is also a\n        <span class="big"> very  big  error</span> error\n      </p>\n    </div>\n    <div class="err" id="div2">another error</div>\n  </body>\n</html>\n\n\n还有如下规则：\n\ndiv {margin:5px;color:black}\n.err {color:red}\n.big {margin-top:3px}\ndiv span {margin-bottom:4px}\n#div1 {color:blue}\n#div2 {color:green}\n\n\n为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。 形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：\n\n\n\n> 图：规则树\n\n上下文树如下图所示（节点名 : 指向的规则节点）：\n\n\n\n> 图：上下文树\n\n假设我们解析 HTML 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。 经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。 我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。\n\n现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。\n\n我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 RGB 等）并在此节点上缓存经过计算的结构。\n\n第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。\n\n对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）。 例如，如果我们在某个段落中添加 font 规则：\n\np {font-family:Verdana;font size:10px;font-weight:bold}\n\n\n那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。\n\n在 WebKit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。\n\n因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 1 和问题 3。Firefox 规则树还有助于按照正确的顺序应用属性。\n\n# 对规则进行处理以简化匹配\n\n样式规则有一些来源：\n\n * 外部样式表或样式元素中的 CSS 规则\n   \n   p {color:blue}\n   \n\n * inline 样式属性及类似内容\n   \n   <p style="color:blue" />\n   \n\n * HTML 可视化属性（映射到相关的样式规则）\n   \n   <p bgcolor="blue" />\n   \n\n后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。\n\n我们之前在第 2 个问题中提到过，CSS 规则匹配可能比较棘手。为了解决这一难题，可以对 CSS 规则进行一些处理，以便访问。\n\n样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 ID，规则就会添加到 ID 表中；如果选择器是类，规则就会添加到类表中，依此类推。 这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了。\n\n我们以如下的样式规则为例：\n\np.error {color:red}\n#messageDiv {height:50px}\ndiv {margin:5px}\n\n\n第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。 对于下面的 HTML 代码段：\n\n<p class="error">an error occurred </p>\n<div id="messageDiv">this is a message</div>\n\n\n我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 ID 表（键为 ID）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。 例如，如果 div 的对应规则如下：\n\ntable div {margin:5px}\n\n\n这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。\n\nWebKit 和 Firefox 都进行了这一处理。\n\n# 以正确的层叠顺序应用规则\n\n样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。\n\n如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。\n\n# 样式表层叠顺序\n\n某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：\n\n 1. 浏览器声明\n 2. 用户普通声明\n 3. 作者普通声明\n 4. 作者重要声明\n 5. 用户重要声明\n\n浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。HTML 可视化属性会转换成匹配的 CSS 声明。它们被视为低优先级的网页作者规则。\n\n# 特异性\n\n选择器的特异性由 CSS2 规范定义如下：\n\n * 如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)\n * 记为选择器中 ID 属性的个数 (= b)\n * 记为选择器中其他属性和伪类的个数 (= c)\n * 记为选择器中元素名称和伪元素的个数 (= d)\n\n将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。\n\n您使用的进制取决于上述类别中的最高计数。 例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p ...（在选择器中出现了 17 个标记，这样的可能性极低）。\n\n一些示例：\n\n *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */\n li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */\n li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\n ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\n ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */\n h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */\n ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */\n li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */\n #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */\n style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */\n\n\n# 规则排序\n\n找到匹配的规则之后，应根据级联顺序将其排序。WebKit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，WebKit 通过替换“>”运算符来实现排序：\n\nstatic bool operator >(CSSRuleData& r1, CSSRuleData& r2)\n{\n    int spec1 = r1.selector()->specificity();\n    int spec2 = r2.selector()->specificity();\n    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;\n}\n\n\n# 渐进式处理\n\nWebKit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。\n\n\n# 布局\n\n渲染器在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。\n\nHTML 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 HTML 表格的计算就需要不止一次的遍历。\n\n坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。\n\n布局是一个递归的过程。它从根渲染器（对应于 HTML 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的渲染器计算几何信息。\n\n根渲染器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。\n\n所有的渲染器都有一个“layout”或者“reflow”方法，每一个渲染器都会调用其需要进行布局的子代的 layout 方法。\n\n# Dirty 位系统\n\n为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个渲染器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。\n\n有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管渲染器自身没有变化，但它至少有一个子代需要布局。\n\n# 全局布局和增量布局\n\n全局布局是指触发了整个渲染树范围的布局，触发原因可能包括：\n\n 1. 影响所有渲染器的全局样式更改，例如字体大小更改。\n 2. 屏幕大小调整。\n\n布局可以采用增量方式，也就是只对 dirty 渲染器进行布局（这样可能存在需要进行额外布局的弊端）。 当渲染器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 DOM 树之后，新的渲染器附加到了渲染树中。\n\n\n\n> 图：增量布局 - 只有 dirty 渲染器及其子代进行布局。\n\n# 异步布局和同步布局\n\n增量布局是异步执行的。Firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。WebKit 也有用于执行增量布局的计时器：对渲染树进行遍历，并对 dirty 渲染器进行布局。 请求样式信息（例如“offsetHeight”）的脚本可同步触发增量布局。 全局布局往往是同步触发的。 有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。\n\n# 优化\n\n如果布局是由“大小调整”或渲染器的位置（而非大小）改变而触发的，那么可以从缓存中获取渲染器的大小，而无需重新计算。 在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。\n\n# 布局处理\n\n布局通常具有以下模式：\n\n 1. 父渲染器确定自己的宽度。\n 2. 父渲染器依次处理子渲染器，并且：\n    1. 放置子渲染器（设置 x,y 坐标）。\n    2. 如果有必要，调用子渲染器的布局（如果子渲染器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子渲染器的高度。\n 3. 父渲染器根据子渲染器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父渲染器的父渲染器使用。\n 4. 将其 dirty 位设置为 false。\n\nFirefox 使用“state”对象 (nsHTMLReflowState) 作为布局的参数（称为“reflow”），这其中包括了父渲染器的宽度。 Firefox 布局的输出为“metrics”对象 (nsHTMLReflowMetrics)，其包含计算得出的渲染器高度。\n\n# 宽度计算\n\n渲染器宽度是根据容器块的宽度、渲染器样式中的“width”属性以及边距和边框计算得出的。 例如以下 div 的宽度：\n\n<div style="width:30%"/>\n\n\n将由 WebKit 计算如下（BenderBox 类，calcWidth 方法）：\n\n * 容器的宽度取容器的 availableWidth 和 0 中的较大值。availableWidth 在本例中相当于 contentWidth，计算公式如下：\n   \n   clientWidth() - paddingLeft() - paddingRight()\n   \n   \n   clientWidth 和 clientHeight 表示一个对象的内部（除去边框和滚动条）。\n\n * 元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。\n\n * 然后加上水平方向的边框和补白。\n\n现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。 如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。\n\n这些值会缓存起来，以用于需要布局而宽度不变的情况。\n\n# 换行\n\n如果渲染器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的渲染器，并对其调用布局。\n\n\n# 绘制\n\n在绘制阶段，系统会遍历渲染树，并调用渲染器的“paint”方法，将渲染器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。\n\n# 全局绘制和增量绘制\n\n和布局一样，绘制也分为全局（绘制整个渲染树）和增量两种。在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块“dirty 区域”，并生成“paint”事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给渲染根节点。然后遍历渲染树，直到找到相关的渲染器，该渲染器会重新绘制自己（通常也包括其子代）。\n\n# 绘制顺序\n\nCSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块渲染器的堆栈顺序如下：\n\n 1. 背景颜色\n 2. 背景图片\n 3. 边框\n 4. 子代\n 5. 轮廓\n\n# Firefox 显示列表\n\nFirefox 遍历整个渲染树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是渲染器的背景，然后是边框等等）包含了与矩形相关的渲染器。这样等到重新绘制的时候，只需遍历一次渲染树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。\n\nFirefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。\n\n# WebKit 矩形存储\n\n在重新绘制之前，WebKit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。\n\n\n# 动态变化\n\n在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。\n\n\n# 渲染引擎的线程\n\n渲染引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 Firefox 和 Safari 中，该线程就是浏览器的主线程。而在 Chrome 浏览器中，该线程是标签进程的主线程。 网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 Firefox 3 为例是 6 个）。\n\n# 事件循环\n\n浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 Firefox 中关于主事件循环的代码：\n\nwhile (!mExiting)\n    NS_ProcessNextEvent(thread);\n\n\n\n# CSS2 可视化模型\n\n# 画布\n\n根据 CSS2 规范，“画布”这一术语是指“用来渲染格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。\n\n根据 www.w3.org/TR/CSS2/zindex.html，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。\n\n# CSS 框模型\n\nCSS 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。 每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。\n\n\n\n> 图：CSS2 框模型\n\n每一个节点都会生成 0..n 个这样的框。 所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：\n\nblock  - generates a block box.\ninline - generates one or more inline boxes.\nnone - no box is generated.\n\n\n默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。 您可以在这里找到默认样式表示例：www.w3.org/TR/CSS2/sample.html\n\n# 定位方案\n\n有三种定位方案：\n\n 1. 普通：根据对象在文档中的位置进行定位，也就是说对象在渲染树中的位置和它在 DOM 树中的位置相似，并根据其框类型和尺寸进行布局。\n 2. 浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。\n 3. 绝对：对象在渲染树中的位置和它在 DOM 树中的位置不同。\n\n定位方案是由“position”属性和“float”属性设置的。\n\n * 如果值是 static 和 relative，就是普通流\n * 如果值是 absolute 和 fixed，就是绝对定位\n\nstatic 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。\n\n框的布局方式是由以下因素决定的：\n\n * 框类型\n * 框尺寸\n * 定位方案\n * 外部信息，例如图片大小和屏幕大小\n\n# 框类型\n\nblock 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。\n\n\n\n> 图：block 框\n\ninline 框：没有自己的 block，但是位于容器 block 内。\n\n\n\n> 图：inline 框\n\nblock 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。\n\n\n\n> 图：block 和 inline 格式\n\ninline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。\n\n\n\n> 图：行\n\n\n# 定位\n\n# 相对\n\n相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。\n\n\n\n> 图：相对定位\n\n# 浮动\n\n浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 HTML 代码：\n\n<p>\n  <img style="float:right" src="images/image.gif" width="100" height="100">\n  Lorem ipsum dolor sit amet, consectetuer...\n</p>\n\n\n显示效果如下：\n\n\n\n图：浮动\n\n# 绝对定位和固定定位\n\n这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。\n\n\n\n> 图：固定定位\n\n请注意，即使在文档滚动时，固定框也不会移动。\n\n\n# 分层展示\n\n这是由 z-index CSS 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。\n\n这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。 堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。\n\n示例：\n\n<style type="text/css">\n      div {\n        position: absolute;\n        left: 2in;\n        top: 2in;\n      }\n</style>\n\n<p>\n    <div\n         style="z-index: 3;background-color:red; width: 1in; height: 1in; ">\n    </div>\n    <div\n         style="z-index: 1;background-color:green;width: 2in; height: 2in;">\n    </div>\n </p>\n\n\n结果如下：\n\n\n\n> 图：固定定位\n\n虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。',normalizedContent:'# 浏览器工作流\n\n\n# 概要\n\n\n# 我们要讨论的浏览器\n\n目前使用的主流浏览器有五个：internet explorer、firefox、safari、chrome 浏览器和 opera。本文中以开放源代码浏览器为例，即 firefox、chrome 浏览器和 safari（部分开源）。根据 statcounter 浏览器统计数据，目前（2011 年 8 月）firefox、safari 和 chrome 浏览器的总市场占有率将近 60%。由此可见，如今开放源代码浏览器在浏览器市场中占据了非常坚实的部分。\n\n\n# 浏览器的主要功能\n\n浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 html 文档，也可以是 pdf、图片或其他的类型。资源的位置由用户使用 uri（统一资源标示符）指定。\n\n浏览器解释并显示 html 文件的方式是在 html 和 css 规范中指定的。这些规范由网络标准化组织 w3c（万维网联盟）进行维护。 多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。\n\n浏览器的用户界面有很多彼此相同的元素，其中包括：\n\n * 用来输入 uri 的地址栏\n * 前进和后退按钮\n * 书签设置选项\n * 用于刷新和停止加载当前文档的刷新和停止按钮\n * 用于返回主页的主页按钮\n\n奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。html5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 firefox 的下载管理器。\n\n\n# 浏览器的高层结构\n\n浏览器的主要组件为：\n\n 1. 用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n 2. 浏览器引擎 - 在用户界面和渲染引擎之间传送指令。\n 3. 渲染引擎 - 负责显示请求的内容。如果请求的内容是 html，它就负责解析 html 和 css 内容，并将解析后的内容显示在屏幕上。\n 4. 网络 - 用于网络调用，比如 http 请求。其接口与平台无关，并为所有平台提供底层实现。\n 5. 用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n 6. javascript 解释器。用于解析和执行 javascript 代码。\n 7. 数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 cookie。新的 html 规范 (html5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。\n\n\n\n> 图：浏览器的主要组件。\n\n值得注意的是，和大多数浏览器不同，chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程。\n\n\n# 渲染引擎\n\n渲染引擎的作用嘛...当然就是“渲染”了，也就是在浏览器的屏幕上显示请求的内容。\n\n默认情况下，渲染引擎可显示 html 和 xml 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 pdf 查看器插件就能显示 pdf 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 css 格式化的 html 内容和图片。\n\n\n# 渲染引擎\n\n本文所讨论的浏览器（firefox、chrome 浏览器和 safari）是基于两种渲染引擎构建的。firefox 使用的是 gecko，这是 mozilla 公司“自制”的渲染引擎。而 safari 和 chrome 浏览器使用的都是 webkit。\n\nwebkit 是一种开放源代码渲染引擎，起初用于 linux 平台，随后由 apple 公司进行修改，从而支持苹果机和 windows。有关详情，请参阅 webkit.org。\n\n\n# 主流程\n\n渲染引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。\n\n然后进行如下所示的基本流程：\n\n\n\n> 图：渲染引擎的基本流程。\n\n渲染引擎将开始解析 html 文档，并将各标记逐个转化成“内容树”上的 dom 节点。同时也会解析外部 css 文件以及样式元素中的样式数据。html 中这些带有视觉指令的样式信息将用于创建另一个树结构：渲染树。\n\n渲染树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。\n\n渲染树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 渲染引擎会遍历渲染树，由用户界面后端层将每个节点绘制出来。\n\n需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，渲染引擎会力求尽快将内容显示在屏幕上。它不必等到整个 html 文档解析完毕之后，就会开始构建渲染树和设置布局。在不断接收和处理来自网络的其余内容的同时，渲染引擎会将部分内容解析并显示出来。\n\n# 主流程示例\n\n\n\n> 图 3：webkit 主流程\n\n\n\n> 图 4：mozilla 的 gecko 渲染引擎主流程\n\n从图 3 和图 4 可以看出，虽然 webkit 和 gecko 使用的术语略有不同，但整体流程是基本相同的。\n\ngecko 将视觉格式化元素组成的树称为“框架树”(frame tree)。每个元素都是一个框架。webkit 使用的术语是“渲染树”(render tree)，它由“渲染对象”组成。对于元素的放置，webkit 使用的术语是“布局”(layout)，而 gecko 称之为“重排”(reflow)。对于连接 dom 节点和可视化信息从而创建渲染树的过程，webkit 使用的术语是“附加”。有一个细微的非语义差别，就是 gecko 在 html 与 dom 树之间还有一个称为“内容槽”的层，用于生成 dom 元素。我们会逐一论述流程中的每一部分：\n\n\n# 解析 - 综述\n\n解析是渲染引擎中非常重要的一个环节，因此我们要更深入地讲解。首先，来介绍一下解析。\n\n解析文档是指将文档转化成为有意义的结构，也就是可让代码理解和使用的结构。解析得到的结果通常是代表了文档结构的节点树，它称作解析树或者语法树。\n\n示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的树：\n\n\n\n> 图：数学表达式树节点\n\n# 语法\n\n解析是以文档所遵循的语法规则（编写文档所用的语言或格式）为基础的。所有可以解析的格式都必须对应确定的语法（由词汇和语法规则构成）。这称为与上下文无关的语法。人类语言并不属于这样的语言，因此无法用常规的解析技术进行解析。\n\n# 解析器和词法分析器的组合\n\n解析的过程可以分成两个子过程：词法分析和语法分析。\n\n词法分析是将输入内容分割成大量标记的过程。标记是语言中的词汇，即构成内容的单位。在人类语言中，它相当于语言字典中的单词。\n\n语法分析是应用语言的语法规则的过程。\n\n解析器通常将解析工作分给以下两个组件来处理：词法分析器（有时也称为标记生成器），负责将输入内容分解成一个个有效标记；而解析器负责根据语言的语法规则分析文档的结构，从而构建解析树。词法分析器知道如何将无关的字符（比如空格和换行符）分离出来。\n\n\n\n> 图：从源文档到解析树\n\n解析是一个迭代的过程。通常，解析器会向词法分析器请求一个新标记，并尝试将其与某条语法规则进行匹配。如果发现了匹配规则，解析器会将一个对应于该标记的节点添加到解析树中，然后继续请求下一个标记。\n\n如果没有规则可以匹配，解析器就会将标记存储到内部，并继续请求标记，直至找到可与所有内部存储的标记匹配的规则。如果找不到任何匹配规则，解析器就会引发一个异常。这意味着文档无效，包含语法错误。\n\n# 翻译\n\n很多时候，解析树还不是最终产品。解析通常是在翻译过程中使用的，而翻译是指将输入文档转换成另一种格式。编译就是这样一个例子。编译器可将源代码编译成机器代码，具体过程是首先将源代码解析成解析树，然后将解析树翻译成机器代码文档。\n\n\n\n> 图：编译流程\n\n# 解析示例\n\n在图 5 中，我们通过一个数学表达式建立了解析树。现在，让我们试着定义一个简单的数学语言，用来演示解析的过程。\n\n词汇：我们用的语言可包含整数、加号和减号。\n\n语法：\n\n 1. 构成语言的语法单位是表达式、项和运算符。\n 2. 我们用的语言可以包含任意数量的表达式。\n 3. 表达式的定义是：一个“项”接一个“运算符”，然后再接一个“项”。\n 4. 运算符是加号或减号。\n 5. 项是一个整数或一个表达式。\n\n让我们分析一下 2 + 3 - 1。 匹配语法规则的第一个子串是 2，而根据第 5 条语法规则，这是一个项。匹配语法规则的第二个子串是 2 + 3，而根据第 3 条规则（一个项接一个运算符，然后再接一个项），这是一个表达式。下一个匹配项已经到了输入的结束。2 + 3 - 1 是一个表达式，因为我们已经知道 2 + 3 是一个项，这样就符合“一个项接一个运算符，然后再接一个项”的规则。2 + + 不与任何规则匹配，因此是无效的输入。\n\n# 词汇和语法的正式定义\n\n词汇通常用正则表达式表示。\n\n例如，我们的示例语言可以定义如下：\n\ninteger :0|[1-9][0-9]*\nplus : +\nminus: -\n\n\n正如您所看到的，这里用正则表达式给出了整数的定义。\n\n语法通常使用一种称为 bnf 的格式来定义。我们的示例语言可以定义如下：\n\nexpression :=  term  operation  term\noperation :=  plus | minus\nterm := integer | expression\n\n\n之前我们说过，如果语言的语法是与上下文无关的语法，就可以由常规解析器进行解析。与上下文无关的语法的直观定义就是可以完全用 bnf 格式表达的语法。有关正式定义，请参阅关于与上下文无关的语法的维基百科文章。\n\n# 解析器类型\n\n有两种基本类型的解析器：自上而下解析器和自下而上解析器。直观地来说，自上而下的解析器从语法的高层结构出发，尝试从中找到匹配的结构。而自下而上的解析器从低层规则出发，将输入内容逐步转化为语法规则，直至满足高层规则。\n\n让我们来看看这两种解析器会如何解析我们的示例：\n\n自上而下的解析器会从高层的规则开始：首先将 2 + 3 标识为一个表达式，然后将 2 + 3 - 1 标识为一个表达式（标识表达式的过程涉及到匹配其他规则，但是起点是最高级别的规则）。\n\n自下而上的解析器将扫描输入内容，找到匹配的规则后，将匹配的输入内容替换成规则。如此继续替换，直到输入内容的结尾。部分匹配的表达式保存在解析器的堆栈中。\n\n堆栈       输入\n         2 + 3 - 1\n项        + 3 - 1\n项运算      3 - 1\n表达式      - 1\n表达式运算符   1\n表达式      \n\n这种自下而上的解析器称为移位归约解析器，因为输入在向右移位（设想有一个指针从输入内容的开头移动到结尾），并且逐渐归约到语法规则上。\n\n# 自动生成解析器\n\n有一些工具可以帮助您生成解析器，它们称为解析器生成器。您只要向其提供您所用语言的语法（词汇和语法规则），它就会生成相应的解析器。创建解析器需要对解析有深刻理解，而人工创建并优化解析器并不是一件容易的事情，所以解析器生成器是非常实用的。\n\nwebkit 使用了两种非常有名的解析器生成器：用于创建词法分析器的 flex 以及用于创建解析器的 bison（您也可能遇到 lex 和 yacc 这样的别名）。flex 的输入是包含标记的正则表达式定义的文件。bison 的输入是采用 bnf 格式的语言语法规则。\n\n\n# html 解析器\n\nhtml 解析器的任务是将 html 标记解析成解析树。\n\n# html 语法定义\n\nhtml 的词汇和语法在 w3c 组织创建的规范中进行了定义。当前的版本是 html4，html5 正在处理过程中。\n\n# 非与上下文无关的语法\n\n正如我们在解析过程的简介中已经了解到的，语法可以用 bnf 等格式进行正式定义。\n\n很遗憾，所有的常规解析器都不适用于 html（我并不是开玩笑，它们可以用于解析 css 和 javascript）。html 并不能很容易地用解析器所需的与上下文无关的语法来定义。\n\n有一种可以定义 html 的正规格式：dtd（document type definition，文档类型定义），但它不是与上下文无关的语法。\n\n这初看起来很奇怪：html 和 xml 非常相似。有很多 xml 解析器可以使用。html 存在一个 xml 变体 (xhtml)，那么有什么大的区别呢？\n\n区别在于 html 的处理更为“宽容”，它允许您省略某些隐式添加的标记，有时还能省略一些起始或者结束标记等等。和 xml 严格的语法不同，html 整体来看是一种“软性”的语法。\n\n显然，这种看上去细微的差别实际上却带来了巨大的影响。一方面，这是 html 如此流行的原因：它能包容您的错误，简化网络开发。另一方面，这使得它很难编写正式的语法。概括地说，html 无法很容易地通过常规解析器解析（因为它的语法不是与上下文无关的语法），也无法通过 xml 解析器来解析。\n\n# html dtd\n\nhtml 的定义采用了 dtd 格式。此格式可用于定义 sgml 族的语言。它包括所有允许使用的元素及其属性和层次结构的定义。如上文所述，html dtd 无法构成与上下文无关的语法。\n\ndtd 存在一些变体。严格模式完全遵守 html 规范，而其他模式可支持以前的浏览器所使用的标记。这样做的目的是确保向下兼容一些早期版本的内容。最新的严格模式 dtd 可以在这里找到：www.w3.org/tr/html4/strict.dtd\n\n# dom\n\n解析器的输出“解析树”是由 dom 元素和属性节点构成的树结构。dom 是文档对象模型 (document object model) 的缩写。它是 html 文档的对象表示，同时也是外部内容（例如 javascript）与 html 元素之间的接口。 解析树的根节点是“document”对象。\n\ndom 与标记之间几乎是一一对应的关系。比如下面这段标记：\n\n<html>\n  <body>\n    <p>\n      hello world\n    </p>\n    <div> <img src="example.png"/></div>\n  </body>\n</html>\n\n\n可翻译成如下的 dom 树：\n\n\n\n> 图：示例标记的 dom 树\n\n和 html 一样，dom 也是由 w3c 组织指定的。请参见 www.w3.org/dom/domtr。这是关于文档操作的通用规范。其中一个特定模块描述针对 html 的元素。html 的定义可以在这里找到：www.w3.org/tr/2003/rec-dom-level-2-html-20030109/idl-definitions.html。\n\n我所说的树包含 dom 节点，指的是树是由实现了某个 dom 接口的元素构成的。浏览器在具体的实现中会有一些供内部使用的其他属性。\n\n# 解析算法\n\n我们在之前章节已经说过，html 无法用常规的自上而下或自下而上的解析器进行解析。\n\n原因在于：\n\n 1. 语言的宽容本质。\n 2. 浏览器历来对一些常见的无效 html 用法采取包容态度。\n 3. 解析过程需要不断地反复。源内容在解析过程中通常不会改变，但是在 html 中，脚本标记如果包含 document.write，就会添加额外的标记，这样解析过程实际上就更改了输入内容。\n\n由于不能使用常规的解析技术，浏览器就创建了自定义的解析器来解析 html。\n\nhtml5 规范详细地描述了解析算法。此算法由两个阶段组成：标记化和树构建。\n\n标记化是词法分析过程，将输入内容解析成多个标记。html 标记包括起始标记、结束标记、属性名称和属性值。\n\n标记生成器识别标记，传递给树构造器，然后接受下一个字符以识别下一个标记；如此反复直到输入的结束。\n\n\n\n> 图：html 解析流程（摘自 html5 规范)\n\n# 标记化算法\n\n该算法的输出结果是 html 标记。该算法使用状态机来表示。每一个状态接收来自输入信息流的一个或多个字符，并根据这些字符更新下一个状态。当前的标记化状态和树结构状态会影响进入下一状态的决定。这意味着，即使接收的字符相同，对于下一个正确的状态也会产生不同的结果，具体取决于当前的状态。该算法相当复杂，无法在此详述，所以我们通过一个简单的示例来帮助大家理解其原理。\n\n基本示例 - 将下面的 html 代码标记化：\n\n<html>\n  <body>\n    hello world\n  </body>\n</html>\n\n\n初始状态是数据状态。遇到字符 < 时，状态更改为标记打开状态。接收一个 a-z 字符会创建“起始标记”，状态更改为标记名称状态。这个状态会一直保持到接收 > 字符。在此期间接收的每个字符都会附加到新的标记名称上。在本例中，我们创建的标记是 html 标记。\n\n遇到 > 标记时，会发送当前的标记，状态改回数据状态。<body> 标记也会进行同样的处理。目前 html 和 body 标记均已发出。现在我们回到数据状态。接收到 hello world 中的 h 字符时，将创建并发送字符标记，直到接收 </body> 中的 <。我们将为 hello world 中的每个字符都发送一个字符标记。\n\n现在我们回到标记打开状态。接收下一个输入字符 / 时，会创建 end tag token 并改为标记名称状态。我们会再次保持这个状态，直到接收 >。然后将发送新的标记，并回到数据状态。</html> 输入也会进行同样的处理。\n\n\n\n> 图：对示例输入进行标记化\n\n# 树构建算法\n\n在创建解析器的同时，也会创建 document 对象。在树构建阶段，以 document 为根节点的 dom 树也会不断进行修改，向其中添加各种元素。标记生成器发送的每个节点都会由树构建器进行处理。规范中定义了每个标记所对应的 dom 元素，这些元素会在接收到相应的标记时创建。这些元素不仅会添加到 dom 树中，还会添加到开放元素的堆栈中。此堆栈用于纠正嵌套错误和处理未关闭的标记。其算法也可以用状态机来描述。这些状态称为“插入模式”。\n\n让我们来看看示例输入的树构建过程：\n\n<html>\n  <body>\n    hello world\n  </body>\n</html>\n\n\n树构建阶段的输入是一个来自标记化阶段的标记序列。第一个模式是initial mode。接收 html 标记后转为before html模式，并在这个模式下重新处理此标记。这样会创建一个 htmlhtmlelement 元素，并将其附加到 document 根对象上。\n\n然后状态将改为before head。此时我们接收“body”标记。即使我们的示例中没有“head”标记，系统也会隐式创建一个 htmlheadelement，并将其添加到树中。\n\n现在我们进入了in head模式，然后转入after head模式。系统对 body 标记进行重新处理，创建并插入 htmlbodyelement，同时模式转变为in body。\n\n现在，接收由“hello world”字符串生成的一系列字符标记。接收第一个字符时会创建并插入“text”节点，而其他字符也将附加到该节点。\n\n接收 body 结束标记会触发after body模式。现在我们将接收 html 结束标记，然后进入after after body模式。接收到文件结束标记后，解析过程就此结束。\n\n\n\n> 图：示例 html 的树构建\n\n# 解析结束后的操作\n\n在此阶段，浏览器会将文档标注为交互状态，并开始解析那些处于“deferred”模式的脚本，也就是那些应在文档解析完成后才执行的脚本。然后，文档状态将设置为“完成”，一个“加载”事件将随之触发。\n\n您可以在 html5 规范中查看标记化和树构建的完整算法\n\n# 浏览器的容错机制\n\n您在浏览 html 网页时从来不会看到“语法无效”的错误。这是因为浏览器会纠正任何无效内容，然后继续工作。\n\n以下面的 html 代码为例：\n\n<html>\n  <mytag>\n  </mytag>\n  <div>\n  <p>\n  </div>\n    really lousy html\n  </p>\n</html>\n\n\n在这里，我已经违反了很多语法规则（“mytag”不是标准的标记，“p”和“div”元素之间的嵌套有误等等），但是浏览器仍然会正确地显示这些内容，并且毫无怨言。因为有大量的解析器代码会纠正 html 网页作者的错误。\n\n不同浏览器的错误处理机制相当一致，但令人称奇的是，这种机制并不是 html 当前规范的一部分。和书签管理以及前进/后退按钮一样，它也是浏览器在多年发展中的产物。很多网站都普遍存在着一些已知的无效 html 结构，每一种浏览器都会尝试通过和其他浏览器一样的方式来修复这些无效结构。\n\nhtml5 规范定义了一部分这样的要求。webkit 在 html 解析器类的开头注释中对此做了很好的概括。\n\n> 解析器对标记化输入内容进行解析，以构建文档树。如果文档的格式正确，就直接进行解析。\n> \n> 遗憾的是，我们不得不处理很多格式错误的 html 文档，所以解析器必须具备一定的容错性。\n> \n> 我们至少要能够处理以下错误情况：\n> \n>  1. 明显不能在某些外部标记中添加的元素。在此情况下，我们应该关闭所有标记，直到出现禁止添加的元素，然后再加入该元素。\n>  2. 我们不能直接添加的元素。这很可能是网页作者忘记添加了其中的一些标记（或者其中的标记是可选的）。这些标签可能包括：html head body tbody tr td li（还有遗漏的吗？）。\n>  3. 向 inline 元素内添加 block 元素。关闭所有 inline 元素，直到出现下一个较高级的 block 元素。\n>  4. 如果这样仍然无效，可关闭所有元素，直到可以添加元素为止，或者忽略该标记。\n\n让我们看一些 webkit 容错的示例：\n\n# 使用了 </br> 而不是 <br>\n\n有些网站使用了 </br> 而不是 <br>。为了与 ie 和 firefox 兼容，webkit 将其与 <br> 做同样的处理。 代码如下：\n\nif (t->isclosetag(brtag) && m_document->incompatmode()) {\n     reporterror(malformedbrerror);\n     t->begintag = true;\n}\n\n\n请注意，错误处理是在内部进行的，用户并不会看到这个过程。\n\n# 离散表格\n\n离散表格是指位于其他表格内容中，但又不在任何一个单元格内的表格。 比如以下的示例：\n\n<table>\n    <table>\n        <tr><td>inner table</td></tr>\n    </table>\n    <tr><td>outer table</td></tr>\n</table>\n\n\nwebkit 会将其层次结构更改为两个同级表格：\n\n<table>\n    <tr><td>outer table</td></tr>\n</table>\n<table>\n    <tr><td>inner table</td></tr>\n</table>\n\n\n代码如下：\n\nif (m_instraytablecontent && localname == tabletag)\n        popblock(tabletag);\n\n\nwebkit 使用一个堆栈来保存当前的元素内容，它会从外部表格的堆栈中弹出内部表格。现在，这两个表格就变成了同级关系。\n\n# 嵌套的表单元素\n\n如果用户在一个表单元素中又放入了另一个表单，那么第二个表单将被忽略。 代码如下：\n\nif (!m_currentformelement) {\n        m_currentformelement = new htmlformelement(formtag,    m_document);\n}\n\n\n# 过于复杂的标记层次结构\n\n代码的注释已经说得很清楚了。\n\n> 示例网站 www.liceo.edu.mx 嵌套了约 1500 个标记，全都来自一堆 <b> 标记。我们只允许最多 20 层同类型标记的嵌套，如果再嵌套更多，就会全部忽略。\n\nbool htmlparser::allownestedredundanttag(const atomicstring& tagname)\n{\n\nunsigned i = 0;\nfor (htmlstackelem* curr = m_blockstack;\n         i < cmaxredundanttagdepth && curr && curr->tagname == tagname;\n     curr = curr->next, i++) { }\nreturn i != cmaxredundanttagdepth;\n}\n\n\n# 放错位置的 html 或者 body 结束标记\n\n同样，代码的注释已经说得很清楚了。\n\n> 支持格式非常糟糕的 html 代码。我们从不关闭 body 标记，因为一些愚蠢的网页会在实际文档结束之前就关闭。我们通过调用 end() 来执行关闭操作。\n\nif (t->tagname == htmltag || t->tagname == bodytag )\n        return;\n\n\n所以网页作者需要注意，除非您想作为反面教材出现在 webkit 容错代码段的示例中，否则还请编写格式正确的 html 代码。\n\n\n# css 解析\n\n还记得简介中解析的概念吗？和 html 不同，css 是上下文无关的语法，可以使用简介中描述的各种解析器进行解析。事实上，css 规范定义了 css 的词法和语法。\n\n让我们来看一些示例： 词法语法（词汇）是针对各个标记用正则表达式定义的：\n\ncomment   \\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/\nnum   [0-9]+|[0-9]*"."[0-9]+\nnonascii  [\\200-\\377]\nnmstart   [_a-z]|{nonascii}|{escape}\nnmchar    [_a-z0-9-]|{nonascii}|{escape}\nname    {nmchar}+\nident   {nmstart}{nmchar}*\n\n\n“ident”是标识符 (identifier) 的缩写，比如类名。“name”是元素的 id（通过“#”来引用）。\n\n语法是采用 bnf 格式描述的。\n\nruleset\n  : selector [ \',\' s* selector ]*\n    \'{\' s* declaration [ \';\' s* declaration ]* \'}\' s*\n  ;\nselector\n  : simple_selector [ combinator selector | s+ [ combinator? selector ]? ]?\n  ;\nsimple_selector\n  : element_name [ hash | class | attrib | pseudo ]*\n  | [ hash | class | attrib | pseudo ]+\n  ;\nclass\n  : \'.\' ident\n  ;\nelement_name\n  : ident | \'*\'\n  ;\nattrib\n  : \'[\' s* ident s* [ [ \'=\' | includes | dashmatch ] s*\n    [ ident | string ] s* ] \']\'\n  ;\npseudo\n  : \':\' [ ident | function s* [ident s*] \')\' ]\n  ;\n\n\n解释：这是一个规则集的结构：\n\ndiv.error , a.error {\n  color:red;\n  font-weight:bold;\n}\n\n\ndiv.error 和 a.error 是选择器。大括号内的部分包含了由此规则集应用的规则。此结构的正式定义是这样的：\n\nruleset\n  : selector [ \',\' s* selector ]*\n    \'{\' s* declaration [ \';\' s* declaration ]* \'}\' s*\n  ;\n\n\n这表示一个规则集就是一个选择器，或者由逗号和空格（s 表示空格）分隔的多个（数量可选）选择器。规则集包含了大括号，以及其中的一个或多个（数量可选）由分号分隔的声明。“声明”和“选择器”将由下面的 bnf 格式定义。\n\n# webkit css 解析器\n\nwebkit 使用 flex 和 bison 解析器生成器，通过 css 语法文件自动创建解析器。正如我们之前在解析器简介中所说，bison 会创建自下而上的移位归约解析器。firefox 使用的是人工编写的自上而下的解析器。这两种解析器都会将 css 文件解析成 stylesheet 对象，且每个对象都包含 css 规则。css 规则对象则包含选择器和声明对象，以及其他与 css 语法对应的对象。\n\n\n\n> 图：解析 css\n\n\n# 处理脚本和样式表的顺序\n\n# 脚本\n\n网络的模型是同步的。网页作者希望解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。如果脚本是外部的，那么解析过程会停止，直到从网络同步抓取资源完成后再继续。此模型已经使用了多年，也在 html4 和 html5 规范中进行了指定。作者也可以将脚本标注为“defer”，这样它就不会停止文档解析，而是等到解析结束才执行。html5 增加了一个选项，可将脚本标记为异步，以便由其他线程解析和执行。\n\n# 预解析\n\nwebkit 和 firefox 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 dom 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。\n\n# 样式表\n\n另一方面，样式表有着不同的模型。理论上来说，应用样式表不会更改 dom 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 webkit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。\n\n\n# 渲染树构建\n\n在 dom 树构建的同时，浏览器还会构建另一个树结构：渲染树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。\n\nfirefox 将渲染树中的元素称为“框架”。webkit 使用的术语是渲染器或渲染对象。 渲染器知道如何布局并将自身及其子元素绘制出来。 webkits renderobject 类是所有渲染器的基类，其定义如下：\n\nclass renderobject{\n  virtual void layout();\n  virtual void paint(paintinfo);\n  virtual void rect repaintrect();\n  node* node;  //the dom node\n  renderstyle* style;  // the computed style\n  renderlayer* containglayer; //the containing z-index layer\n}\n\n\n每一个渲染器都代表了一个矩形的区域，通常对应于相关节点的 css 框，这一点在 css2 规范中有所描述。它包含诸如宽度、高度和位置等几何信息。 框的类型会受到与节点相关的“display”样式属性的影响（请参阅样式计算章节）。下面这段 webkit 代码描述了根据 display 属性的不同，针对同一个 dom 节点应创建什么类型的渲染器。\n\nrenderobject* renderobject::createobject(node* node, renderstyle* style)\n{\n    document* doc = node->document();\n    renderarena* arena = doc->renderarena();\n    ...\n    renderobject* o = 0;\n\n    switch (style->display()) {\n        case none:\n            break;\n        case inline:\n            o = new (arena) renderinline(node);\n            break;\n        case block:\n            o = new (arena) renderblock(node);\n            break;\n        case inline_block:\n            o = new (arena) renderblock(node);\n            break;\n        case list_item:\n            o = new (arena) renderlistitem(node);\n            break;\n       ...\n    }\n\n    return o;\n}\n\n\n元素类型也是考虑因素之一，例如表单控件和表格都对应特殊的框架。 在 webkit 中，如果一个元素需要创建特殊的渲染器，就会替换 createrenderer 方法。渲染器所指向的样式对象中包含了一些和几何无关的信息。\n\n# 渲染树和 dom 树的关系\n\n渲染器是和 dom 元素相对应的，但并非一一对应。非可视化的 dom 元素不会插入渲染树中，例如“head”元素。如果元素的 display 属性值为“none”，那么也不会显示在渲染树中（但是 visibility 属性值为“hidden”的元素仍会显示）。\n\n有一些 dom 元素对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。例如，“select”元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的渲染器而添加。 另一个关于多渲染器的例子是格式无效的 html。根据 css 规范，inline 元素只能包含 block 元素或 inline 元素中的一种。如果出现了混合内容，则应创建匿名的 block 渲染器，以包裹 inline 元素。\n\n有一些渲染对象对应于 dom 节点，但在树中所在的位置与 dom 节点不同。浮动定位和绝对定位的元素就是这样，它们处于正常的流程之外，放置在树中的其他地方，并映射到真正的框架，而放在原位的是占位框架。\n\n\n\n> 图：渲染树及其对应的 dom 树。初始容器 block 为“viewport”，而在 webkit 中则为“renderview”对象。\n\n# 构建渲染树的流程\n\n在 firefox 中，系统会针对 dom 更新注册展示层，作为侦听器。展示层将框架创建工作委托给 frameconstructor，由该构造器解析样式（请参阅样式计算）并创建框架。\n\n在 webkit 中，解析样式和创建渲染器的过程称为“附加”。每个 dom 节点都有一个“attach”方法。附加是同步进行的，将节点插入 dom 树需要调用新的节点“attach”方法。\n\n处理 html 和 body 标记就会构建渲染树根节点。这个根节点渲染对象对应于 css 规范中所说的容器 block，这是最上层的 block，包含了其他所有 block。它的尺寸就是视口，即浏览器窗口显示区域的尺寸。firefox 称之为 viewportframe，而 webkit 称之为 renderview。这就是文档所指向的渲染对象。渲染树的其余部分以 dom 树节点插入的形式来构建。\n\n请参阅关于处理模型的 css2 规范。\n\n# 样式计算\n\n构建渲染树时，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。\n\n样式包括来自各种来源的样式表、inline 样式元素和 html 中的可视化属性（例如“bgcolor”属性）。其中后者将经过转化以匹配 css 样式属性。\n\n样式表的来源包括浏览器的默认样式表、由网页作者提供的样式表以及由浏览器用户提供的用户样式表（浏览器允许您定义自己喜欢的样式。以 firefox 为例，用户可以将自己喜欢的样式表放在“firefox profile”文件夹下）。\n\n样式计算存在以下难点：\n\n 1. 样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。\n\n 2. 如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。\n    \n    例如下面这个组合选择器：\n    \n    div div div div{\n      ...\n    }\n    \n    \n    这意味着规则适用于作为 3 个 div 元素的子代的<div>。如果您要检查规则是否适用于某个指定的<div>元素，应选择树上的一条向上路径进行检查。您可能需要向上遍历节点树，结果发现只有两个 div，而且规则并不适用。然后，您必须尝试树中的其他路径。\n\n 3. 应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）。\n\n让我们来看看浏览器是如何处理这些问题的：\n\n# 共享样式数据\n\nwebkit 节点会引用样式对象 (renderstyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：\n\n 1.  这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）\n 2.  任何元素都没有 id\n 3.  标记名称应匹配\n 4.  类属性应匹配\n 5.  映射属性的集合必须是完全相同的\n 6.  链接状态必须匹配\n 7.  焦点状态必须匹配\n 8.  任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配\n 9.  元素中不能有任何 inline 样式属性\n 10. 不能使用任何同级选择器。webcore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。\n\n# firefox 规则树\n\n为了简化样式计算，firefox 还采用了另外两种树：规则树和样式上下文树。webkit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 dom 节点指向此类对象的相关样式。\n\n\n\n> 图：firefox 样式上下文树\n\n样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。例如，如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。\n\n所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。\n\n这个想法相当于将规则树路径视为词典中的单词。如果我们已经计算出如下的规则树：\n\n\n\n假设我们需要为内容树中的另一个元素匹配规则，并且找到匹配路径是 b - e - i（按照此顺序）。由于我们在树中已经计算出了路径 a - b - e - i - l，因此就已经有了此路径，这就减少了现在所需的工作量。\n\n让我们看看规则树如何帮助我们减少工作。\n\n# 结构划分\n\n样式上下文可分割成多个结构。这些结构体包含了特定类别（如 border 或 color）的样式信息。结构中的属性都是继承的或非继承的。继承属性如果未由元素定义，则继承自其父代。非继承属性（也称为“重置”属性）如果未进行定义，则使用默认值。\n\n规则树通过缓存整个结构（包含计算出的端值）为我们提供帮助。这一想法假定底层节点没有提供结构的定义，则可使用上层节点中的缓存结构。\n\n# 使用规则树计算样式上下文\n\n在计算某个特定元素的样式上下文时，我们首先计算规则树中的对应路径，或者使用现有的路径。然后我们沿此路径应用规则，在新的样式上下文中填充结构。我们从路径中拥有最高优先级的底层节点（通常也是最特殊的选择器）开始，并向上遍历规则树，直到结构填充完毕。如果该规则节点对于此结构没有任何规范，那么我们可以实现更好的优化：寻找路径更上层的节点，找到后指定完整的规范并指向相关节点即可。这是最好的优化方法，因为整个结构都能共享。这可以减少端值的计算量并节约内存。 如果我们找到了部分定义，就会向上遍历规则树，直到结构填充完毕。\n\n如果我们找不到结构的任何定义，那么假如该结构是“继承”类型，我们会在上下文树中指向父代的结构，这样也可以共享结构。如果是 reset 类型的结构，则会使用默认值。\n\n如果最特殊的节点确实添加了值，那么我们需要另外进行一些计算，以便将这些值转化成实际值。然后我们将结果缓存在树节点中，供子代使用。\n\n如果某个元素与其同级元素都指向同一个树节点，那么它们就可以共享整个样式上下文。\n\n让我们来看一个例子，假设我们有如下 html 代码：\n\n<html>\n  <body>\n    <div class="err" id="div1">\n      <p>\n        this is a <span class="big"> big error </span>\n        this is also a\n        <span class="big"> very  big  error</span> error\n      </p>\n    </div>\n    <div class="err" id="div2">another error</div>\n  </body>\n</html>\n\n\n还有如下规则：\n\ndiv {margin:5px;color:black}\n.err {color:red}\n.big {margin-top:3px}\ndiv span {margin-bottom:4px}\n#div1 {color:blue}\n#div2 {color:green}\n\n\n为了简便起见，我们只需要填充两个结构：color 结构和 margin 结构。color 结构只包含一个成员（即“color”），而 margin 结构包含四条边。 形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）：\n\n\n\n> 图：规则树\n\n上下文树如下图所示（节点名 : 指向的规则节点）：\n\n\n\n> 图：上下文树\n\n假设我们解析 html 时遇到了第二个 <div> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。 经过规则匹配，我们发现该 <div> 的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 f 节点）。 我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 f 节点。\n\n现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (f) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 b 节点）上找到该结构。\n\n我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 rgb 等）并在此节点上缓存经过计算的结构。\n\n第二个 <span> 元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 g。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。\n\n对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 firefox 将其视为 reset 属性，并缓存到规则树上）。 例如，如果我们在某个段落中添加 font 规则：\n\np {font-family:verdana;font size:10px;font-weight:bold}\n\n\n那么，该段落元素作为上下文树中的 div 的子代，就会共享与其父代相同的 font 结构（前提是该段落没有指定 font 规则）。\n\n在 webkit 中没有规则树，因此会对匹配的声明遍历 4 次。首先应用非重要高优先级的属性（由于作为其他属性的依据而应首先应用的属性，例如 display），接着是高优先级重要规则，然后是普通优先级非重要规则，最后是普通优先级重要规则。这意味着多次出现的属性会根据正确的层叠顺序进行解析。最后出现的最终生效。\n\n因此概括来说，共享样式对象（整个对象或者对象中的部分结构）可以解决问题 1 和问题 3。firefox 规则树还有助于按照正确的顺序应用属性。\n\n# 对规则进行处理以简化匹配\n\n样式规则有一些来源：\n\n * 外部样式表或样式元素中的 css 规则\n   \n   p {color:blue}\n   \n\n * inline 样式属性及类似内容\n   \n   <p style="color:blue" />\n   \n\n * html 可视化属性（映射到相关的样式规则）\n   \n   <p bgcolor="blue" />\n   \n\n后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 html 属性可以使用元素作为键值进行映射。\n\n我们之前在第 2 个问题中提到过，css 规则匹配可能比较棘手。为了解决这一难题，可以对 css 规则进行一些处理，以便访问。\n\n样式表解析完毕后，系统会根据选择器将 css 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 id、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果选择器是 id，规则就会添加到 id 表中；如果选择器是类，规则就会添加到类表中，依此类推。 这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则了。\n\n我们以如下的样式规则为例：\n\np.error {color:red}\n#messagediv {height:50px}\ndiv {margin:5px}\n\n\n第一条规则将插入类表，第二条将插入 id 表，而第三条将插入标记表。 对于下面的 html 代码段：\n\n<p class="error">an error occurred </p>\n<div id="messagediv">this is a message</div>\n\n\n我们首先会为 p 元素寻找匹配的规则。类表中有一个“error”键，在下面可以找到“p.error”的规则。div 元素在 id 表（键为 id）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。 例如，如果 div 的对应规则如下：\n\ntable div {margin:5px}\n\n\n这条规则仍然会从标记表中提取出来，因为键是最右边的选择器，但这条规则并不匹配我们的 div 元素，因为 div 没有 table 祖先。\n\nwebkit 和 firefox 都进行了这一处理。\n\n# 以正确的层叠顺序应用规则\n\n样式对象具有与每个可视化属性一一对应的属性（均为 css 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。\n\n如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。\n\n# 样式表层叠顺序\n\n某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为“层叠”顺序。根据 css2 规范，层叠的顺序为（优先级从低到高）：\n\n 1. 浏览器声明\n 2. 用户普通声明\n 3. 作者普通声明\n 4. 作者重要声明\n 5. 用户重要声明\n\n浏览器声明是重要程度最低的，而用户只有将该声明标记为“重要”才可以替换网页作者的声明。同样顺序的声明会根据特异性进行排序，然后再是其指定顺序。html 可视化属性会转换成匹配的 css 声明。它们被视为低优先级的网页作者规则。\n\n# 特异性\n\n选择器的特异性由 css2 规范定义如下：\n\n * 如果声明来自于“style”属性，而不是带有选择器的规则，则记为 1，否则记为 0 (= a)\n * 记为选择器中 id 属性的个数 (= b)\n * 记为选择器中其他属性和伪类的个数 (= c)\n * 记为选择器中元素名称和伪元素的个数 (= d)\n\n将四个数字按 a-b-c-d 这样连接起来（位于大数进制的数字系统中），构成特异性。\n\n您使用的进制取决于上述类别中的最高计数。 例如，如果 a=14，您可以使用十六进制。如果 a=17，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：html body div div p ...（在选择器中出现了 17 个标记，这样的可能性极低）。\n\n一些示例：\n\n *             {}  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */\n li            {}  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */\n li:first-line {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\n ul li         {}  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */\n ul ol+li      {}  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */\n h1 + *[rel=up]{}  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */\n ul ol li.red  {}  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */\n li.red.level  {}  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */\n #x34y         {}  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */\n style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */\n\n\n# 规则排序\n\n找到匹配的规则之后，应根据级联顺序将其排序。webkit 对于较小的列表会使用冒泡排序，而对较大的列表则使用归并排序。对于以下规则，webkit 通过替换“>”运算符来实现排序：\n\nstatic bool operator >(cssruledata& r1, cssruledata& r2)\n{\n    int spec1 = r1.selector()->specificity();\n    int spec2 = r2.selector()->specificity();\n    return (spec1 == spec2) : r1.position() > r2.position() : spec1 > spec2;\n}\n\n\n# 渐进式处理\n\nwebkit 使用一个标记来表示是否所有的顶级样式表（包括 @imports）均已加载完毕。如果在附加过程中尚未完全加载样式，则使用占位符，并在文档中进行标注，等样式表加载完毕后再重新计算。\n\n\n# 布局\n\n渲染器在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排。\n\nhtml 采用基于流的布局模型，这意味着大多数情况下只要一次遍历就能计算出几何信息。处于流中靠后位置元素通常不会影响靠前位置元素的几何特征，因此布局可以按从左至右、从上至下的顺序遍历文档。但是也有例外情况，比如 html 表格的计算就需要不止一次的遍历。\n\n坐标系是相对于根框架而建立的，使用的是上坐标和左坐标。\n\n布局是一个递归的过程。它从根渲染器（对应于 html 文档的 <html> 元素）开始，然后递归遍历部分或所有的框架层次结构，为每一个需要计算的渲染器计算几何信息。\n\n根渲染器的位置左边是 0,0，其尺寸为视口（也就是浏览器窗口的可见区域）。\n\n所有的渲染器都有一个“layout”或者“reflow”方法，每一个渲染器都会调用其需要进行布局的子代的 layout 方法。\n\n# dirty 位系统\n\n为避免对所有细小更改都进行整体布局，浏览器采用了一种“dirty 位”系统。如果某个渲染器发生了更改，或者将自身及其子代标注为“dirty”，则需要进行布局。\n\n有两种标记：“dirty”和“children are dirty”。“children are dirty”表示尽管渲染器自身没有变化，但它至少有一个子代需要布局。\n\n# 全局布局和增量布局\n\n全局布局是指触发了整个渲染树范围的布局，触发原因可能包括：\n\n 1. 影响所有渲染器的全局样式更改，例如字体大小更改。\n 2. 屏幕大小调整。\n\n布局可以采用增量方式，也就是只对 dirty 渲染器进行布局（这样可能存在需要进行额外布局的弊端）。 当渲染器为 dirty 时，会异步触发增量布局。例如，当来自网络的额外内容添加到 dom 树之后，新的渲染器附加到了渲染树中。\n\n\n\n> 图：增量布局 - 只有 dirty 渲染器及其子代进行布局。\n\n# 异步布局和同步布局\n\n增量布局是异步执行的。firefox 将增量布局的“reflow 命令”加入队列，而调度程序会触发这些命令的批量执行。webkit 也有用于执行增量布局的计时器：对渲染树进行遍历，并对 dirty 渲染器进行布局。 请求样式信息（例如“offsetheight”）的脚本可同步触发增量布局。 全局布局往往是同步触发的。 有时，当初始布局完成之后，如果一些属性（如滚动位置）发生变化，布局就会作为回调而触发。\n\n# 优化\n\n如果布局是由“大小调整”或渲染器的位置（而非大小）改变而触发的，那么可以从缓存中获取渲染器的大小，而无需重新计算。 在某些情况下，只有一个子树进行了修改，因此无需从根节点开始布局。这适用于在本地进行更改而不影响周围元素的情况，例如在文本字段中插入文本（否则每次键盘输入都将触发从根节点开始的布局）。\n\n# 布局处理\n\n布局通常具有以下模式：\n\n 1. 父渲染器确定自己的宽度。\n 2. 父渲染器依次处理子渲染器，并且：\n    1. 放置子渲染器（设置 x,y 坐标）。\n    2. 如果有必要，调用子渲染器的布局（如果子渲染器是 dirty 的，或者这是全局布局，或出于其他某些原因），这会计算子渲染器的高度。\n 3. 父渲染器根据子渲染器的累加高度以及边距和补白的高度来设置自身高度，此值也可供父渲染器的父渲染器使用。\n 4. 将其 dirty 位设置为 false。\n\nfirefox 使用“state”对象 (nshtmlreflowstate) 作为布局的参数（称为“reflow”），这其中包括了父渲染器的宽度。 firefox 布局的输出为“metrics”对象 (nshtmlreflowmetrics)，其包含计算得出的渲染器高度。\n\n# 宽度计算\n\n渲染器宽度是根据容器块的宽度、渲染器样式中的“width”属性以及边距和边框计算得出的。 例如以下 div 的宽度：\n\n<div style="width:30%"/>\n\n\n将由 webkit 计算如下（benderbox 类，calcwidth 方法）：\n\n * 容器的宽度取容器的 availablewidth 和 0 中的较大值。availablewidth 在本例中相当于 contentwidth，计算公式如下：\n   \n   clientwidth() - paddingleft() - paddingright()\n   \n   \n   clientwidth 和 clientheight 表示一个对象的内部（除去边框和滚动条）。\n\n * 元素的宽度是“width”样式属性。它会根据容器宽度的百分比计算得出一个绝对值。\n\n * 然后加上水平方向的边框和补白。\n\n现在计算得出的是“preferred width”。然后需要计算最小宽度和最大宽度。 如果首选宽度大于最大宽度，那么应使用最大宽度。如果首选宽度小于最小宽度（最小的不可破开单位），那么应使用最小宽度。\n\n这些值会缓存起来，以用于需要布局而宽度不变的情况。\n\n# 换行\n\n如果渲染器在布局过程中需要换行，会立即停止布局，并告知其父代需要换行。父代会创建额外的渲染器，并对其调用布局。\n\n\n# 绘制\n\n在绘制阶段，系统会遍历渲染树，并调用渲染器的“paint”方法，将渲染器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。\n\n# 全局绘制和增量绘制\n\n和布局一样，绘制也分为全局（绘制整个渲染树）和增量两种。在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 os 将其视为一块“dirty 区域”，并生成“paint”事件。os 会很巧妙地将多个区域合并成一个。在 chrome 浏览器中，情况要更复杂一些，因为 chrome 浏览器的渲染器不在主进程上。chrome 浏览器会在某种程度上模拟 os 的行为。展示层会侦听这些事件，并将消息委托给渲染根节点。然后遍历渲染树，直到找到相关的渲染器，该渲染器会重新绘制自己（通常也包括其子代）。\n\n# 绘制顺序\n\ncss2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块渲染器的堆栈顺序如下：\n\n 1. 背景颜色\n 2. 背景图片\n 3. 边框\n 4. 子代\n 5. 轮廓\n\n# firefox 显示列表\n\nfirefox 遍历整个渲染树，为绘制的矩形建立一个显示列表。列表中按照正确的绘制顺序（先是渲染器的背景，然后是边框等等）包含了与矩形相关的渲染器。这样等到重新绘制的时候，只需遍历一次渲染树，而不用多次遍历（绘制所有背景，然后绘制所有图片，再绘制所有边框等等）。\n\nfirefox 对此过程进行了优化，也就是不添加隐藏的元素，例如被不透明元素完全遮挡住的元素。\n\n# webkit 矩形存储\n\n在重新绘制之前，webkit 会将原来的矩形另存为一张位图，然后只绘制新旧矩形之间的差异部分。\n\n\n# 动态变化\n\n在发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 dom 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大“html”元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。\n\n\n# 渲染引擎的线程\n\n渲染引擎采用了单线程。几乎所有操作（除了网络操作）都是在单线程中进行的。在 firefox 和 safari 中，该线程就是浏览器的主线程。而在 chrome 浏览器中，该线程是标签进程的主线程。 网络操作可由多个并行线程执行。并行连接数是有限的（通常为 2 至 6 个，以 firefox 3 为例是 6 个）。\n\n# 事件循环\n\n浏览器的主线程是事件循环。它是一个无限循环，永远处于接受处理状态，并等待事件（如布局和绘制事件）发生，并进行处理。这是 firefox 中关于主事件循环的代码：\n\nwhile (!mexiting)\n    ns_processnextevent(thread);\n\n\n\n# css2 可视化模型\n\n# 画布\n\n根据 css2 规范，“画布”这一术语是指“用来渲染格式化结构的空间”，也就是供浏览器绘制内容的区域。画布的空间尺寸大小是无限的，但是浏览器会根据视口的尺寸选择一个初始宽度。\n\n根据 www.w3.org/tr/css2/zindex.html，画布如果包含在其他画布内，就是透明的；否则会由浏览器指定一种颜色。\n\n# css 框模型\n\ncss 框模型描述的是针对文档树中的元素而生成，并根据可视化格式模型进行布局的矩形框。 每个框都有一个内容区域（例如文本、图片等），还有可选的周围补白、边框和边距区域。\n\n\n\n> 图：css2 框模型\n\n每一个节点都会生成 0..n 个这样的框。 所有元素都有一个“display”属性，决定了它们所对应生成的框类型。示例：\n\nblock  - generates a block box.\ninline - generates one or more inline boxes.\nnone - no box is generated.\n\n\n默认值是 inline，但是浏览器样式表设置了其他默认值。例如，“div”元素的 display 属性默认值是 block。 您可以在这里找到默认样式表示例：www.w3.org/tr/css2/sample.html\n\n# 定位方案\n\n有三种定位方案：\n\n 1. 普通：根据对象在文档中的位置进行定位，也就是说对象在渲染树中的位置和它在 dom 树中的位置相似，并根据其框类型和尺寸进行布局。\n 2. 浮动：对象先按照普通流进行布局，然后尽可能地向左或向右移动。\n 3. 绝对：对象在渲染树中的位置和它在 dom 树中的位置不同。\n\n定位方案是由“position”属性和“float”属性设置的。\n\n * 如果值是 static 和 relative，就是普通流\n * 如果值是 absolute 和 fixed，就是绝对定位\n\nstatic 定位无需定义位置，而是使用默认定位。对于其他方案，网页作者需要指定位置：top、bottom、left、right。\n\n框的布局方式是由以下因素决定的：\n\n * 框类型\n * 框尺寸\n * 定位方案\n * 外部信息，例如图片大小和屏幕大小\n\n# 框类型\n\nblock 框：形成一个 block，在浏览器窗口中拥有其自己的矩形区域。\n\n\n\n> 图：block 框\n\ninline 框：没有自己的 block，但是位于容器 block 内。\n\n\n\n> 图：inline 框\n\nblock 采用的是一个接一个的垂直格式，而 inline 采用的是水平格式。\n\n\n\n> 图：block 和 inline 格式\n\ninline 框放置在行中或“行框”中。这些行至少和最高的框一样高，还可以更高，当框根据“底线”对齐时，这意味着元素的底部需要根据其他框中非底部的位置对齐。如果容器的宽度不够，inline 元素就会分为多行放置。在段落中经常发生这种情况。\n\n\n\n> 图：行\n\n\n# 定位\n\n# 相对\n\n相对定位：先按照普通方式定位，然后根据所需偏移量进行移动。\n\n\n\n> 图：相对定位\n\n# 浮动\n\n浮动框会移动到行的左边或右边。有趣的特征在于，其他框会浮动在它的周围。下面这段 html 代码：\n\n<p>\n  <img style="float:right" src="images/image.gif" width="100" height="100">\n  lorem ipsum dolor sit amet, consectetuer...\n</p>\n\n\n显示效果如下：\n\n\n\n图：浮动\n\n# 绝对定位和固定定位\n\n这种布局是准确定义的，与普通流无关。元素不参与普通流。尺寸是相对于容器而言的。在固定定位中，容器就是可视区域。\n\n\n\n> 图：固定定位\n\n请注意，即使在文档滚动时，固定框也不会移动。\n\n\n# 分层展示\n\n这是由 z-index css 属性指定的。它代表了框的第三个维度，也就是沿“z 轴”方向的位置。\n\n这些框分散到多个堆栈（称为堆栈上下文）中。在每一个堆栈中，会首先绘制后面的元素，然后在顶部绘制前面的元素，以便更靠近用户。如果出现重叠，新绘制的元素就会覆盖之前的元素。 堆栈是按照 z-index 属性进行排序的。具有“z-index”属性的框形成了本地堆栈。视口具有外部堆栈。\n\n示例：\n\n<style type="text/css">\n      div {\n        position: absolute;\n        left: 2in;\n        top: 2in;\n      }\n</style>\n\n<p>\n    <div\n         style="z-index: 3;background-color:red; width: 1in; height: 1in; ">\n    </div>\n    <div\n         style="z-index: 1;background-color:green;width: 2in; height: 2in;">\n    </div>\n </p>\n\n\n结果如下：\n\n\n\n> 图：固定定位\n\n虽然红色 div 在标记中的位置比绿色 div 靠前（按理应该在常规流程中优先绘制），但是 z-index 属性的优先级更高，因此它移动到了根框所保持的堆栈中更靠前的位置。',charsets:{cjk:!0}},{title:"API 参考",frontmatter:{},regularPath:"/mp/api-ability/api.html",relativePath:"mp/api-ability/api.md",key:"v-a174ed7c",path:"/mp/api-ability/api.html",headers:[{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:70},{level:3,title:"系统",slug:"系统",normalizedTitle:"系统",charIndex:302},{level:3,title:"更新",slug:"更新",normalizedTitle:"更新",charIndex:450},{level:3,title:"小程序",slug:"小程序",normalizedTitle:"小程序",charIndex:161},{level:3,title:"调试",slug:"调试",normalizedTitle:"调试",charIndex:1715},{level:3,title:"性能",slug:"性能",normalizedTitle:"性能",charIndex:2881},{level:3,title:"加密",slug:"加密",normalizedTitle:"加密",charIndex:3688},{level:2,title:"路由",slug:"路由",normalizedTitle:"路由",charIndex:3923},{level:3,title:"EventChannel",slug:"eventchannel",normalizedTitle:"eventchannel",charIndex:4153},{level:2,title:"跳转",slug:"跳转",normalizedTitle:"跳转",charIndex:3968},{level:2,title:"转发",slug:"转发",normalizedTitle:"转发",charIndex:4472},{level:2,title:"界面",slug:"界面",normalizedTitle:"界面",charIndex:4894},{level:3,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:4901},{level:3,title:"导航栏",slug:"导航栏",normalizedTitle:"导航栏",charIndex:5275},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:5530},{level:3,title:"Tab Bar",slug:"tab-bar",normalizedTitle:"tab bar",charIndex:5662},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:5603},{level:3,title:"下拉刷新",slug:"下拉刷新",normalizedTitle:"下拉刷新",charIndex:6117},{level:3,title:"滚动",slug:"滚动",normalizedTitle:"滚动",charIndex:6228},{level:3,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:5357},{level:3,title:"置顶",slug:"置顶",normalizedTitle:"置顶",charIndex:7735},{level:3,title:"自定义组件",slug:"自定义组件",normalizedTitle:"自定义组件",charIndex:7798},{level:3,title:"菜单",slug:"菜单",normalizedTitle:"菜单",charIndex:4719},{level:3,title:"窗口",slug:"窗口",normalizedTitle:"窗口",charIndex:5651},{level:2,title:"网络",slug:"网络",normalizedTitle:"网络",charIndex:5875},{level:3,title:"发起请求",slug:"发起请求",normalizedTitle:"发起请求",charIndex:8129},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:4619},{level:3,title:"上传",slug:"上传",normalizedTitle:"上传",charIndex:8772},{level:3,title:"WebSocket",slug:"websocket",normalizedTitle:"websocket",charIndex:9128},{level:3,title:"mDNS",slug:"mdns",normalizedTitle:"mdns",charIndex:9769},{level:3,title:"TCP 通信",slug:"tcp-通信",normalizedTitle:"tcp 通信",charIndex:10333},{level:3,title:"UDP 通信",slug:"udp-通信",normalizedTitle:"udp 通信",charIndex:10903},{level:2,title:"支付",slug:"支付",normalizedTitle:"支付",charIndex:11712},{level:2,title:"数据缓存",slug:"数据缓存",normalizedTitle:"数据缓存",charIndex:11826},{level:3,title:"周期性更新",slug:"周期性更新",normalizedTitle:"周期性更新",charIndex:12396},{level:2,title:"数据分析",slug:"数据分析",normalizedTitle:"数据分析",charIndex:12662},{level:2,title:"画布",slug:"画布",normalizedTitle:"画布",charIndex:12833},{level:3,title:"Canvas",slug:"canvas",normalizedTitle:"canvas",charIndex:12887},{level:3,title:"CanvasContext",slug:"canvascontext",normalizedTitle:"canvascontext",charIndex:12920},{level:3,title:"CanvasGradient",slug:"canvasgradient",normalizedTitle:"canvasgradient",charIndex:15759},{level:3,title:"OffscreenCanvas",slug:"offscreencanvas",normalizedTitle:"offscreencanvas",charIndex:12878},{level:2,title:"媒体",slug:"媒体",normalizedTitle:"媒体",charIndex:16290},{level:3,title:"地图",slug:"地图",normalizedTitle:"地图",charIndex:16297},{level:3,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:4600},{level:3,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:4648},{level:3,title:"音频",slug:"音频",normalizedTitle:"音频",charIndex:1190},{level:3,title:"背景音频",slug:"背景音频",normalizedTitle:"背景音频",charIndex:22773},{level:3,title:"实时音视频",slug:"实时音视频",normalizedTitle:"实时音视频",charIndex:24126},{level:3,title:"录音",slug:"录音",normalizedTitle:"录音",charIndex:25579},{level:3,title:"相机",slug:"相机",normalizedTitle:"相机",charIndex:17896},{level:3,title:"富文本",slug:"富文本",normalizedTitle:"富文本",charIndex:26824},{level:3,title:"音视频合成",slug:"音视频合成",normalizedTitle:"音视频合成",charIndex:27478},{level:3,title:"实时语音",slug:"实时语音",normalizedTitle:"实时语音",charIndex:27951},{level:3,title:"画面录制器",slug:"画面录制器",normalizedTitle:"画面录制器",charIndex:28631},{level:3,title:"视频解码器",slug:"视频解码器",normalizedTitle:"视频解码器",charIndex:19317},{level:2,title:"位置",slug:"位置",normalizedTitle:"位置",charIndex:6281},{level:2,title:"文件",slug:"文件",normalizedTitle:"文件",charIndex:4680},{level:3,title:"FileSystemManager",slug:"filesystemmanager",normalizedTitle:"filesystemmanager",charIndex:30397},{level:3,title:"Stats",slug:"stats",normalizedTitle:"stats",charIndex:32284},{level:2,title:"开放接口",slug:"开放接口",normalizedTitle:"开放接口",charIndex:33003},{level:3,title:"登录",slug:"登录",normalizedTitle:"登录",charIndex:12471},{level:3,title:"帐号信息",slug:"帐号信息",normalizedTitle:"帐号信息",charIndex:33106},{level:3,title:"用户信息",slug:"用户信息",normalizedTitle:"用户信息",charIndex:33178},{level:3,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:29659},{level:3,title:"设置",slug:"设置",normalizedTitle:"设置",charIndex:1778},{level:3,title:"收货地址",slug:"收货地址",normalizedTitle:"收货地址",charIndex:33621},{level:3,title:"卡券",slug:"卡券",normalizedTitle:"卡券",charIndex:33683},{level:3,title:"发票",slug:"发票",normalizedTitle:"发票",charIndex:33756},{level:3,title:"生物认证",slug:"生物认证",normalizedTitle:"生物认证",charIndex:33861},{level:3,title:"微信运动",slug:"微信运动",normalizedTitle:"微信运动",charIndex:34088},{level:3,title:"订阅消息",slug:"订阅消息",normalizedTitle:"订阅消息",charIndex:33610},{level:3,title:"微信红包",slug:"微信红包",normalizedTitle:"微信红包",charIndex:34285},{level:3,title:"收藏",slug:"收藏",normalizedTitle:"收藏",charIndex:4616},{level:3,title:"车牌",slug:"车牌",normalizedTitle:"车牌",charIndex:34450},{level:3,title:"视频号",slug:"视频号",normalizedTitle:"视频号",charIndex:34517},{level:3,title:"微信群",slug:"微信群",normalizedTitle:"微信群",charIndex:34763},{level:3,title:"微信客服",slug:"微信客服",normalizedTitle:"微信客服",charIndex:34841},{level:2,title:"设备",slug:"设备",normalizedTitle:"设备",charIndex:34065},{level:3,title:"蓝牙-通用",slug:"蓝牙-通用",normalizedTitle:"蓝牙-通用",charIndex:34928},{level:3,title:"蓝牙-低功耗中心设备",slug:"蓝牙-低功耗中心设备",normalizedTitle:"蓝牙-低功耗中心设备",charIndex:35580},{level:3,title:"蓝牙-低功耗外围设备",slug:"蓝牙-低功耗外围设备",normalizedTitle:"蓝牙-低功耗外围设备",charIndex:36499},{level:3,title:"蓝牙-信标(Beacon)",slug:"蓝牙-信标-beacon",normalizedTitle:"蓝牙-信标(beacon)",charIndex:37822},{level:3,title:"NFC",slug:"nfc",normalizedTitle:"nfc",charIndex:38258},{level:3,title:"Wi-Fi",slug:"wi-fi",normalizedTitle:"wi-fi",charIndex:41782},{level:3,title:"日历",slug:"日历",normalizedTitle:"日历",charIndex:42232},{level:3,title:"联系人",slug:"联系人",normalizedTitle:"联系人",charIndex:42351},{level:3,title:"无障碍",slug:"无障碍",normalizedTitle:"无障碍",charIndex:42489},{level:3,title:"电量",slug:"电量",normalizedTitle:"电量",charIndex:42577},{level:3,title:"剪贴板",slug:"剪贴板",normalizedTitle:"剪贴板",charIndex:42693},{level:3,title:"网络",slug:"网络-2",normalizedTitle:"网络",charIndex:5875},{level:3,title:"加密",slug:"加密-2",normalizedTitle:"加密",charIndex:3688},{level:3,title:"屏幕",slug:"屏幕",normalizedTitle:"屏幕",charIndex:16603},{level:3,title:"键盘",slug:"键盘",normalizedTitle:"键盘",charIndex:26944},{level:3,title:"电话",slug:"电话",normalizedTitle:"电话",charIndex:43502},{level:3,title:"加速计",slug:"加速计",normalizedTitle:"加速计",charIndex:43558},{level:3,title:"罗盘",slug:"罗盘",normalizedTitle:"罗盘",charIndex:43770},{level:3,title:"设备方向",slug:"设备方向",normalizedTitle:"设备方向",charIndex:43951},{level:3,title:"陀螺仪",slug:"陀螺仪",normalizedTitle:"陀螺仪",charIndex:44190},{level:3,title:"内存",slug:"内存",normalizedTitle:"内存",charIndex:11985},{level:3,title:"扫码",slug:"扫码",normalizedTitle:"扫码",charIndex:44473},{level:3,title:"振动",slug:"振动",normalizedTitle:"振动",charIndex:44528},{level:2,title:"AI",slug:"ai",normalizedTitle:"ai",charIndex:44636},{level:3,title:"人脸识别",slug:"人脸识别",normalizedTitle:"人脸识别",charIndex:44643},{level:2,title:"Worker",slug:"worker",normalizedTitle:"worker",charIndex:44807},{level:3,title:"Worker",slug:"worker-2",normalizedTitle:"worker",charIndex:44807},{level:2,title:"WXML",slug:"wxml",normalizedTitle:"wxml",charIndex:45180},{level:3,title:"IntersectionObserver",slug:"intersectionobserver",normalizedTitle:"intersectionobserver",charIndex:45288},{level:3,title:"MediaQueryObserver",slug:"mediaqueryobserver",normalizedTitle:"mediaqueryobserver",charIndex:45653},{level:3,title:"NodesRef",slug:"nodesref",normalizedTitle:"nodesref",charIndex:45807},{level:3,title:"SelectorQuery",slug:"selectorquery",normalizedTitle:"selectorquery",charIndex:45232},{level:2,title:"第三方平台",slug:"第三方平台",normalizedTitle:"第三方平台",charIndex:46393},{level:2,title:"广告",slug:"广告",normalizedTitle:"广告",charIndex:46513},{level:3,title:"InterstitialAd",slug:"interstitialad",normalizedTitle:"interstitialad",charIndex:46596},{level:3,title:"RewardedVideoAd",slug:"rewardedvideoad",normalizedTitle:"rewardedvideoad",charIndex:46558}],headersStr:"基础 系统 更新 小程序 调试 性能 加密 路由 EventChannel 跳转 转发 界面 交互 导航栏 背景 Tab Bar 字体 下拉刷新 滚动 动画 置顶 自定义组件 菜单 窗口 网络 发起请求 下载 上传 WebSocket mDNS TCP 通信 UDP 通信 支付 数据缓存 周期性更新 数据分析 画布 Canvas CanvasContext CanvasGradient OffscreenCanvas 媒体 地图 图片 视频 音频 背景音频 实时音视频 录音 相机 富文本 音视频合成 实时语音 画面录制器 视频解码器 位置 文件 FileSystemManager Stats 开放接口 登录 帐号信息 用户信息 授权 设置 收货地址 卡券 发票 生物认证 微信运动 订阅消息 微信红包 收藏 车牌 视频号 微信群 微信客服 设备 蓝牙-通用 蓝牙-低功耗中心设备 蓝牙-低功耗外围设备 蓝牙-信标(Beacon) NFC Wi-Fi 日历 联系人 无障碍 电量 剪贴板 网络 加密 屏幕 键盘 电话 加速计 罗盘 设备方向 陀螺仪 内存 扫码 振动 AI 人脸识别 Worker Worker WXML IntersectionObserver MediaQueryObserver NodesRef SelectorQuery 第三方平台 广告 InterstitialAd RewardedVideoAd",content:"# API 参考\n\n> 在这里查看官方的最新文档\n\n> 以下标注 云调用 的接口可以使用微信云开发通过云函数免服务器直接发起云调用\n\n\n# 基础\n\n名称                       功能说明\nwx.env                   环境变量\nwx.canIUse               判断小程序的API，回调，参数，组件等是否在当前版本可用\nwx.base64ToArrayBuffer   将 Base64 字符串转成 ArrayBuffer 对象\nwx.arrayBufferToBase64   将 ArrayBuffer 对象转成 Base64 字符串\n\n\n# 系统\n\n名称                      功能说明\nwx.getSystemInfoSync    wx.getSystemInfo 的同步版本\nwx.getSystemInfoAsync   异步获取系统信息\nwx.getSystemInfo        获取系统信息\n\n\n# 更新\n\n名称                    功能说明\nwx.updateWeChatApp    更新客户端版本\nwx.getUpdateManager   获取全局唯一的版本更新管理器，用于管理小程序更新\n\n# UpdateManager\n\n名称                               功能说明\nUpdateManager.applyUpdate        强制小程序重启并使用新版本\nUpdateManager.onCheckForUpdate   监听向微信后台请求检查更新结果事件\nUpdateManager.onUpdateFailed     监听小程序更新失败事件\nUpdateManager.onUpdateReady      监听小程序有版本更新事件\n\n\n# 小程序\n\n# 生命周期\n\n名称                        功能说明\nwx.getLaunchOptionsSync   获取小程序启动时的参数\nwx.getEnterOptionsSync    获取本次小程序启动时的参数\n\n# 应用级事件\n\n名称                             功能说明\nwx.onUnhandledRejection        监听未处理的 Promise 拒绝事件\nwx.onThemeChange               监听系统主题改变事件\nwx.onPageNotFound              监听小程序要打开的页面不存在事件\nwx.onError                     监听小程序错误事件\nwx.onAudioInterruptionEnd      监听音频中断结束事件\nwx.onAudioInterruptionBegin    监听音频因为受到系统占用而被中断开始事件\nwx.onAppShow                   监听小程序切前台事件\nwx.onAppHide                   监听小程序切后台事件\nwx.offUnhandledRejection       取消监听未处理的 Promise 拒绝事件\nwx.offThemeChange              取消监听系统主题改变事件\nwx.offPageNotFound             取消监听小程序要打开的页面不存在事件\nwx.offError                    取消监听小程序错误事件\nwx.offAudioInterruptionEnd     取消监听音频中断结束事件\nwx.offAudioInterruptionBegin   取消监听音频因为受到系统占用而被中断开始事件\nwx.offAppShow                  取消监听小程序切前台事件\nwx.offAppHide                  取消监听小程序切后台事件\n\n\n# 调试\n\n名称                         功能说明\nwx.setEnableDebug          设置是否打开调试开关\nwx.getRealtimeLogManager   获取实时日志管理器对象\nwx.getLogManager           获取日志管理器对象\n\n# LogManager\n\n名称                 功能说明\nLogManager.debug   写 debug 日志\nLogManager.info    写 info 日志\nLogManager.log     写 log 日志\nLogManager.warn    写 warn 日志\n\n# RealtimeLogManager\n\n名称                                   功能说明\nRealtimeLogManager.addFilterMsg      添加过滤关键字，暂不支持在插件使用\nRealtimeLogManager.error             写 error 日志，暂不支持在插件使用\nRealtimeLogManager.getCurrentState   实时日志会将一定时间间隔内缓存的日志聚合上报，如果该时间内缓存的内容超出限制，则会被丢弃\nRealtimeLogManager.in                设置实时日志page参数所在的页面，暂不支持在插件使用\nRealtimeLogManager.info              写 info 日志，暂不支持在插件使用\nRealtimeLogManager.setFilterMsg      设置过滤关键字，暂不支持在插件使用\nRealtimeLogManager.tag               获取给定标签的日志管理器实例，目前只支持在插件使用\nRealtimeLogManager.warn              写 warn 日志，暂不支持在插件使用\n\n# RealtimeTagLogManager\n\n名称                                   功能说明\nRealtimeTagLogManager.addFilterMsg   添加过滤关键字\nRealtimeTagLogManager.error          写 error 日志\nRealtimeTagLogManager.info           写 info 日志\nRealtimeTagLogManager.setFilterMsg   设置过滤关键字\nRealtimeTagLogManager.warn           写 warn 日志\n\n\n# 性能\n\n名称                     功能说明\nwx.reportPerformance   小程序测速上报\nwx.getPerformance      获取当前小程序性能相关的信息\n\n# EntryList\n\n名称                           功能说明\nEntryList.getEntries         该方法返回当前列表中的所有性能数据\nEntryList.getEntriesByName   获取当前列表中所有名称为 [name] 且类型为 [entryType] 的性能数据\nEntryList.getEntriesByType   获取当前列表中所有类型为 [entryType] 的性能数据\n\n# Performance\n\n名称                             功能说明\nPerformance.createObserver     创建全局性能事件监听器\nPerformance.getEntries         该方法返回当前缓冲区中的所有性能数据\nPerformance.getEntriesByName   获取当前缓冲区中所有名称为 [name] 且类型为 [entryType] 的性能数据\nPerformance.getEntriesByType   获取当前缓冲区中所有类型为 [entryType] 的性能数据\nPerformance.setBufferSize      设置缓冲区大小， 默认缓冲 30 条性能数据\n\n# PerformanceObserver\n\n名称                               功能说明\nPerformanceObserver.disconnect   停止监听\nPerformanceObserver.observe      开始监听\n\n\n# 加密\n\n名称                        功能说明\nwx.getUserCryptoManager   获取用户加密模块\n\n# UserCryptoManager\n\n名称                                   功能说明\nUserCryptoManager.getLatestUserKey   获取最新的用户加密密钥\nUserCryptoManager.getRandomValues    获取密码学安全随机数\n\n\n# 路由\n\n名称                功能说明\nwx.switchTab      跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面\nwx.reLaunch       关闭所有页面，打开到应用内的某个页面\nwx.redirectTo     关闭当前页面，跳转到应用内的某个页面\nwx.navigateTo     保留当前页面，跳转到应用内的某个页面\nwx.navigateBack   关闭当前页面，返回上一页面或多级页面\n\n\n# EventChannel\n\n名称                  功能说明\nEventChannel.emit   触发一个事件\nEventChannel.off    取消监听一个事件\nEventChannel.on     持续监听一个事件\nEventChannel.once   监听一个事件一次，触发后失效\n\n\n# 跳转\n\n名称                           功能说明\nwx.navigateToMiniProgram     打开另一个小程序\nwx.navigateBackMiniProgram   返回到上一个小程序\nwx.exitMiniProgram           退出当前小程序\n\n\n# 转发\n\n名称                      功能说明\nwx.updateShareMenu      更新转发属性\nwx.showShareMenu        显示当前页面的转发按钮\nwx.showShareImageMenu   打开分享图片弹窗，可以将图片发送给朋友、收藏或下载\nwx.shareVideoMessage    转发视频到聊天\nwx.shareFileMessage     转发文件到聊天\nwx.onCopyUrl            监听用户点击右上角菜单的「复制链接」按钮时触发的事件\nwx.offCopyUrl           取消监听用户点击右上角菜单的「复制链接」按钮时触发的事件\nwx.hideShareMenu        隐藏当前页面的转发按钮\nwx.getShareInfo         获取转发详细信息\nwx.authPrivateMessage   验证私密消息\n\n\n# 界面\n\n\n# 交互\n\n名称                            功能说明\nwx.showToast                  显示消息提示框\nwx.showModal                  显示模态对话框\nwx.showLoading                显示 loading 提示框\nwx.showActionSheet            显示操作菜单\nwx.hideToast                  隐藏消息提示框\nwx.hideLoading                隐藏 loading 提示框\nwx.enableAlertBeforeUnload    开启小程序页面返回询问对话框\nwx.disableAlertBeforeUnload   关闭小程序页面返回询问对话框\n\n\n# 导航栏\n\n名称                            功能说明\nwx.showNavigationBarLoading   在当前页面显示导航条加载动画\nwx.setNavigationBarTitle      动态设置当前页面的标题\nwx.setNavigationBarColor      设置页面导航条颜色\nwx.hideNavigationBarLoading   在当前页面隐藏导航条加载动画\nwx.hideHomeButton             隐藏返回首页按钮\n\n\n# 背景\n\n名称                          功能说明\nwx.setBackgroundTextStyle   动态设置下拉背景字体、loading 图的样式\nwx.setBackgroundColor       动态设置窗口的背景色\n\n\n# Tab Bar\n\n名称                     功能说明\nwx.showTabBarRedDot    显示 tabBar 某一项的右上角的红点\nwx.showTabBar          显示 tabBar\nwx.setTabBarStyle      动态设置 tabBar 的整体样式\nwx.setTabBarItem       动态设置 tabBar 某一项的内容，2.7.0 起图片支持临时文件和网络文件\nwx.setTabBarBadge      为 tabBar 某一项的右上角添加文本\nwx.removeTabBarBadge   移除 tabBar 某一项右上角的文本\nwx.hideTabBarRedDot    隐藏 tabBar 某一项的右上角的红点\nwx.hideTabBar          隐藏 tabBar\n\n\n# 字体\n\n名称                功能说明\nwx.loadFontFace   动态加载网络字体，文件地址需为下载类型\n\n\n# 下拉刷新\n\n名称                        功能说明\nwx.stopPullDownRefresh    停止当前页面下拉刷新\nwx.startPullDownRefresh   开始下拉刷新\n\n\n# 滚动\n\n名称                功能说明\nwx.pageScrollTo   将页面滚动到目标位置，支持选择器和滚动距离两种方式定位\n\n# ScrollViewContext\n\n名称                                 功能说明\nScrollViewContext.scrollIntoView   滚动至指定位置\nScrollViewContext.scrollTo         滚动至指定位置\n\n\n# 动画\n\n名称                   功能说明\nwx.createAnimation   创建一个动画实例 animation\n\n# Animation\n\n名称                          功能说明\nAnimation.backgroundColor   设置背景色\nAnimation.bottom            设置 bottom 值\nAnimation.export            导出动画队列\nAnimation.height            设置高度\nAnimation.left              设置 left 值\nAnimation.matrix            同 transform-function matrix\nAnimation.matrix3d          同 transform-function matrix3d\nAnimation.opacity           设置透明度\nAnimation.right             设置 right 值\nAnimation.rotate            从原点顺时针旋转一个角度\nAnimation.rotate3d          从 固定 轴顺时针旋转一个角度\nAnimation.rotateX           从 X 轴顺时针旋转一个角度\nAnimation.rotateY           从 Y 轴顺时针旋转一个角度\nAnimation.rotateZ           从 Z 轴顺时针旋转一个角度\nAnimation.scale             缩放\nAnimation.scale3d           缩放\nAnimation.scaleX            缩放 X 轴\nAnimation.scaleY            缩放 Y 轴\nAnimation.scaleZ            缩放 Z 轴\nAnimation.skew              对 X、Y 轴坐标进行倾斜\nAnimation.skewX             对 X 轴坐标进行倾斜\nAnimation.skewY             对 Y 轴坐标进行倾斜\nAnimation.step              表示一组动画完成\nAnimation.top               设置 top 值\nAnimation.translate         平移变换\nAnimation.translate3d       对 xyz 坐标进行平移变换\nAnimation.translateX        对 X 轴平移\nAnimation.translateY        对 Y 轴平移\nAnimation.translateZ        对 Z 轴平移\nAnimation.width             设置宽度\n\n\n# 置顶\n\n名称                 功能说明\nwx.setTopBarText   动态设置置顶栏文字内容\n\n\n# 自定义组件\n\n名称            功能说明\nwx.nextTick   延迟一部分操作到下一个时间片再执行\n\n\n# 菜单\n\n名称                                   功能说明\nwx.getMenuButtonBoundingClientRect   获取菜单按钮（右上角胶囊按钮）的布局位置信息\n\n\n# 窗口\n\n名称                   功能说明\nwx.setWindowSize     设置窗口大小，该接口仅适用于 PC 平台，使用细则请参见指南\nwx.onWindowResize    监听窗口尺寸变化事件\nwx.offWindowResize   取消监听窗口尺寸变化事件\n\n\n# 网络\n\n\n# 发起请求\n\n名称           功能说明\nwx.request   发起 HTTPS 网络请求\n\n# RequestTask\n\n名称                               功能说明\nRequestTask.abort                中断请求任务\nRequestTask.offHeadersReceived   取消监听 HTTP Response Header 事件\nRequestTask.onHeadersReceived    监听 HTTP Response Header 事件\n\n\n# 下载\n\n名称                功能说明\nwx.downloadFile   下载文件资源到本地\n\n# DownloadTask\n\n名称                                功能说明\nDownloadTask.abort                中断下载任务\nDownloadTask.offHeadersReceived   取消监听 HTTP Response Header 事件\nDownloadTask.offProgressUpdate    取消监听下载进度变化事件\nDownloadTask.onHeadersReceived    监听 HTTP Response Header 事件\nDownloadTask.onProgressUpdate     监听下载进度变化事件\n\n\n# 上传\n\n名称              功能说明\nwx.uploadFile   将本地资源上传到服务器\n\n# UploadTask\n\n名称                              功能说明\nUploadTask.abort                中断上传任务\nUploadTask.offHeadersReceived   取消监听 HTTP Response Header 事件\nUploadTask.offProgressUpdate    取消监听上传进度变化事件\nUploadTask.onHeadersReceived    监听 HTTP Response Header 事件\nUploadTask.onProgressUpdate     监听上传进度变化事件\n\n\n# WebSocket\n\n名称                     功能说明\nwx.sendSocketMessage   通过 WebSocket 连接发送数据\nwx.onSocketOpen        监听 WebSocket 连接打开事件\nwx.onSocketMessage     监听 WebSocket 接受到服务器的消息事件\nwx.onSocketError       监听 WebSocket 错误事件\nwx.onSocketClose       监听 WebSocket 连接关闭事件\nwx.connectSocket       创建一个 WebSocket 连接\nwx.closeSocket         关闭 WebSocket 连接\n\n# SocketTask\n\n名称                     功能说明\nSocketTask.close       关闭 WebSocket 连接\nSocketTask.onClose     监听 WebSocket 连接关闭事件\nSocketTask.onError     监听 WebSocket 错误事件\nSocketTask.onMessage   监听 WebSocket 接受到服务器的消息事件\nSocketTask.onOpen      监听 WebSocket 连接打开事件\nSocketTask.send        通过 WebSocket 连接发送数据\n\n\n# mDNS\n\n名称                                功能说明\nwx.stopLocalServiceDiscovery      停止搜索 mDNS 服务\nwx.startLocalServiceDiscovery     开始搜索局域网下的 mDNS 服务\nwx.onLocalServiceResolveFail      监听 mDNS 服务解析失败的事件\nwx.onLocalServiceLost             监听 mDNS 服务离开的事件\nwx.onLocalServiceFound            监听 mDNS 服务发现的事件\nwx.onLocalServiceDiscoveryStop    监听 mDNS 服务停止搜索的事件\nwx.offLocalServiceResolveFail     取消监听 mDNS 服务解析失败的事件\nwx.offLocalServiceLost            取消监听 mDNS 服务离开的事件\nwx.offLocalServiceFound           取消监听 mDNS 服务发现的事件\nwx.offLocalServiceDiscoveryStop   取消监听 mDNS 服务停止搜索的事件\n\n\n# TCP 通信\n\n名称                   功能说明\nwx.createTCPSocket   创建一个 TCP Socket 实例\n\n# TCPSocket\n\n名称                     功能说明\nTCPSocket.close        关闭连接\nTCPSocket.connect      在给定的套接字上启动连接\nTCPSocket.offClose     取消监听一旦 socket 完全关闭就发出该事件\nTCPSocket.offConnect   取消监听当一个 socket 连接成功建立的时候触发该事件\nTCPSocket.offError     取消监听当错误发生时触发\nTCPSocket.offMessage   取消监听当接收到数据的时触发该事件\nTCPSocket.onClose      监听一旦 socket 完全关闭就发出该事件\nTCPSocket.onConnect    监听当一个 socket 连接成功建立的时候触发该事件\nTCPSocket.onError      监听当错误发生时触发\nTCPSocket.onMessage    监听当接收到数据的时触发该事件\nTCPSocket.write        在 socket 上发送数据\n\n\n# UDP 通信\n\n名称                   功能说明\nwx.createUDPSocket   创建一个 UDP Socket 实例\n\n# UDPSocket\n\n名称                       功能说明\nUDPSocket.bind           绑定一个系统随机分配的可用端口，或绑定一个指定的端口号\nUDPSocket.close          关闭 UDP Socket 实例，相当于销毁\nUDPSocket.connect        预先连接到指定的 IP 和 port，需要配合 write 方法一起使用\nUDPSocket.offClose       取消监听关闭事件\nUDPSocket.offError       取消监听错误事件\nUDPSocket.offListening   取消监听开始监听数据包消息的事件\nUDPSocket.offMessage     取消监听收到消息的事件\nUDPSocket.onClose        监听关闭事件\nUDPSocket.onError        监听错误事件\nUDPSocket.onListening    监听开始监听数据包消息的事件\nUDPSocket.onMessage      监听收到消息的事件\nUDPSocket.send           向指定的 IP 和 port 发送消息\nUDPSocket.setTTL         设置 IP_TTL 套接字选项，用于设置一个 IP 数据包传输时允许的最大跳步数\nUDPSocket.write          用法与 send 方法相同，如果没有预先调用 connect 则与 send 无差异（注意即使调用了 connect\n                         也需要在本接口填入地址和端口参数）\n\n\n# 支付\n\n名称                       功能说明\nwx.requestPayment        发起微信支付\nwx.requestOrderPayment   创建自定义版交易组件订单，并发起支付\n\n\n# 数据缓存\n\n名称                      功能说明\nwx.setStorageSync       wx.setStorage 的同步版本\nwx.setStorage           将数据存储在本地缓存中指定的 key 中\nwx.revokeBufferURL      根据 URL 销毁存在内存中的数据\nwx.removeStorageSync    wx.removeStorage 的同步版本\nwx.removeStorage        从本地缓存中移除指定 key\nwx.getStorageSync       wx.getStorage 的同步版本\nwx.getStorageInfoSync   wx.getStorageInfo 的同步版本\nwx.getStorageInfo       异步获取当前storage的相关信息\nwx.getStorage           从本地缓存中异步获取指定 key 的内容\nwx.createBufferURL      根据传入的 buffer 创建一个唯一的 URL 存在内存中\nwx.clearStorageSync     wx.clearStorage 的同步版本\nwx.clearStorage         清理本地数据缓存\n\n\n# 周期性更新\n\n名称                           功能说明\nwx.setBackgroundFetchToken   设置自定义登录态，在周期性拉取数据时带上，便于第三方服务器验证请求合法性\nwx.onBackgroundFetchData     监听收到 backgroundFetch 数据时的回调\nwx.getBackgroundFetchToken   获取设置过的自定义登录态\nwx.getBackgroundFetchData    拉取 backgroundFetch 客户端缓存数据\n\n\n# 数据分析\n\n名称                   功能说明\nwx.reportMonitor     自定义业务数据监控上报接口\nwx.reportEvent       事件上报\nwx.reportAnalytics   自定义分析数据上报接口\nwx.getExptInfoSync   给定实验参数数组，获取对应的实验参数值\n\n\n# 画布\n\n名称                         功能说明\nwx.createOffscreenCanvas   创建离屏 canvas 实例\nwx.createCanvasContext     创建 canvas 的绘图上下文 CanvasContext 对象\nwx.canvasToTempFilePath    把当前画布指定区域的内容导出生成指定大小的图片\nwx.canvasPutImageData      将像素数据绘制到画布\nwx.canvasGetImageData      获取 canvas 区域隐含的像素数据\n\n\n# Canvas\n\n名称                             功能说明\nCanvas.cancelAnimationFrame    取消由 requestAnimationFrame 添加到计划中的动画帧请求\nCanvas.createImage             创建一个图片对象\nCanvas.createImageData         创建一个 ImageData 对象\nCanvas.createPath2D            创建 Path2D 对象\nCanvas.getContext              该方法返回 Canvas 的绘图上下文\nCanvas.requestAnimationFrame   在下次进行重绘时执行\nCanvas.toDataURL               返回一个包含图片展示的 data URI\n\n\n# CanvasContext\n\n名称                                     功能说明\nCanvasContext.arc                      创建一条弧线\nCanvasContext.arcTo                    根据控制点和半径绘制圆弧路径\nCanvasContext.beginPath                开始创建一个路径\nCanvasContext.bezierCurveTo            创建三次方贝塞尔曲线路径\nCanvasContext.clearRect                清除画布上在该矩形区域内的内容\nCanvasContext.clip                     从原始画布中剪切任意形状和尺寸\nCanvasContext.closePath                关闭一个路径\nCanvasContext.createCircularGradient   创建一个圆形的渐变颜色\nCanvasContext.createLinearGradient     创建一个线性的渐变颜色\nCanvasContext.createPattern            对指定的图像创建模式的方法，可在指定的方向上重复元图像\nCanvasContext.draw                     将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中\nCanvasContext.drawImage                绘制图像到画布\nCanvasContext.fill                     对当前路径中的内容进行填充\nCanvasContext.fillRect                 填充一个矩形\nCanvasContext.fillText                 在画布上绘制被填充的文本\nCanvasContext.lineTo                   增加一个新点，然后创建一条从上次指定点到目标点的线\nCanvasContext.measureText              测量文本尺寸信息\nCanvasContext.moveTo                   把路径移动到画布中的指定点，不创建线条\nCanvasContext.quadraticCurveTo         创建二次贝塞尔曲线路径\nCanvasContext.rect                     创建一个矩形路径\nCanvasContext.restore                  恢复之前保存的绘图上下文\nCanvasContext.rotate                   以原点为中心顺时针旋转当前坐标轴\nCanvasContext.save                     保存绘图上下文\nCanvasContext.scale                    在调用后，之后创建的路径其横纵坐标会被缩放\nCanvasContext.setFillStyle             设置填充色\nCanvasContext.setFontSize              设置字体的字号\nCanvasContext.setGlobalAlpha           设置全局画笔透明度\nCanvasContext.setLineCap               设置线条的端点样式\nCanvasContext.setLineDash              设置虚线样式\nCanvasContext.setLineJoin              设置线条的交点样式\nCanvasContext.setLineWidth             设置线条的宽度\nCanvasContext.setMiterLimit            设置最大斜接长度\nCanvasContext.setShadow                设定阴影样式\nCanvasContext.setStrokeStyle           设置描边颜色\nCanvasContext.setTextAlign             设置文字的对齐\nCanvasContext.setTextBaseline          设置文字的竖直对齐\nCanvasContext.setTransform             使用矩阵重新设置（覆盖）当前变换的方法\nCanvasContext.stroke                   画出当前路径的边框\nCanvasContext.strokeRect               画一个矩形(非填充)\nCanvasContext.strokeText               给定的 (x, y) 位置绘制文本描边的方法\nCanvasContext.transform                使用矩阵多次叠加当前变换的方法\nCanvasContext.translate                对当前坐标系的原点 (0, 0) 进行变换\n\n\n# CanvasGradient\n\n名称                            功能说明\nCanvasGradient.addColorStop   添加颜色的渐变点\nColor                         颜色\nImage                         图片对象\nImageData                     ImageData 对象\n\n\n# OffscreenCanvas\n\n名称                            功能说明\nOffscreenCanvas.createImage   创建一个图片对象\nOffscreenCanvas.getContext    该方法返回 OffscreenCanvas 的绘图上下文\nPath2D                        Canvas 2D API 的接口 Path2D\n                              用来声明路径，此路径稍后会被CanvasRenderingContext2D 对象使用\nRenderingContext              Canvas 绘图上下文\n\n\n# 媒体\n\n\n# 地图\n\n名称                    功能说明\nwx.createMapContext   创建 map 上下文 MapContext 对象\n\n# MapContext\n\n名称                               功能说明\nMapContext.addCustomLayer        添加个性化图层\nMapContext.addGroundOverlay      创建自定义图片图层，图片会随着地图缩放而缩放\nMapContext.addMarkers            添加 marker\nMapContext.fromScreenLocation    获取屏幕上的点对应的经纬度，坐标原点为地图左上角\nMapContext.getCenterLocation     获取当前地图中心的经纬度\nMapContext.getRegion             获取当前地图的视野范围\nMapContext.getRotate             获取当前地图的旋转角\nMapContext.getScale              获取当前地图的缩放级别\nMapContext.getSkew               获取当前地图的倾斜角\nMapContext.includePoints         缩放视野展示所有经纬度\nMapContext.initMarkerCluster     初始化点聚合的配置，未调用时采用默认配置\nMapContext.moveAlong             沿指定路径移动 marker，用于轨迹回放等场景\nMapContext.moveToLocation        将地图中心移置当前定位点，此时需设置地图组件 show-location 为true\nMapContext.on                    监听地图事件\nMapContext.openMapApp            拉起地图APP选择导航\nMapContext.removeCustomLayer     移除个性化图层\nMapContext.removeGroundOverlay   移除自定义图片图层\nMapContext.removeMarkers         移除 marker\nMapContext.setCenterOffset       设置地图中心点偏移，向后向下为增长，屏幕比例范围(0.25~0.75)，默认偏移为[0.5, 0.5]\nMapContext.setLocMarkerIcon      设置定位点图标，支持网络路径、本地路径、代码包路径\nMapContext.toScreenLocation      获取经纬度对应的屏幕坐标，坐标原点为地图左上角\nMapContext.translateMarker       平移marker，带动画\nMapContext.updateGroundOverlay   更新自定义图片图层\n\n\n# 图片\n\n名称                          功能说明\nwx.saveImageToPhotosAlbum   保存图片到系统相册\nwx.previewMedia             预览图片和视频\nwx.previewImage             在新页面中全屏预览图片\nwx.getImageInfo             获取图片信息\nwx.compressImage            压缩图片接口，可选压缩质量\nwx.chooseMessageFile        从客户端会话选择文件\nwx.chooseImage              从本地相册选择图片或使用相机拍照\n\n\n# 视频\n\n名称                          功能说明\nwx.saveVideoToPhotosAlbum   保存视频到系统相册\nwx.openVideoEditor          打开视频编辑器\nwx.getVideoInfo             获取视频详细信息\nwx.createVideoContext       创建 video 上下文 VideoContext 对象\nwx.compressVideo            压缩视频接口\nwx.chooseVideo              拍摄视频或从手机相册中选视频\nwx.chooseMedia              拍摄或从手机相册中选择图片或视频\n\n# VideoContext\n\n名称                                       功能说明\nVideoContext.exitBackgroundPlayback      退出后台音频播放模式\nVideoContext.exitFullScreen              退出全屏\nVideoContext.exitPictureInPicture        退出小窗，该方法可在任意页面调用\nVideoContext.hideStatusBar               隐藏状态栏，仅在iOS全屏下有效\nVideoContext.pause                       暂停视频\nVideoContext.play                        播放视频\nVideoContext.playbackRate                设置倍速播放\nVideoContext.requestBackgroundPlayback   进入后台音频播放模式\nVideoContext.requestFullScreen           进入全屏\nVideoContext.seek                        跳转到指定位置\nVideoContext.sendDanmu                   发送弹幕\nVideoContext.showStatusBar               显示状态栏，仅在iOS全屏下有效\nVideoContext.stop                        停止视频\n\n\n# 音频\n\n名称                            功能说明\nwx.stopVoice                  结束播放语音\nwx.setInnerAudioOption        设置 InnerAudioContext 的播放选项\nwx.playVoice                  开始播放语音\nwx.pauseVoice                 暂停正在播放的语音\nwx.getAvailableAudioSources   获取当前支持的音频输入源\nwx.createWebAudioContext      创建 WebAudio 上下文\nwx.createMediaAudioPlayer     创建媒体音频播放器对象 MediaAudioPlayer 对象，可用于播放视频解码器 VideoDecoder\n                              输出的音频\nwx.createInnerAudioContext    创建内部 audio 上下文 InnerAudioContext 对象\nwx.createAudioContext         创建 audio 上下文 AudioContext 对象\n\n# AudioBuffer\n\n名称                            功能说明\nAudioBuffer.copyFromChannel   从AudioBuffer的指定频道复制到数组终端\nAudioBuffer.copyToChannel     从指定数组复制样本到audioBuffer的特定通道\nAudioBuffer.getChannelData    返回一个 Float32Array，包含了带有频道的PCM数据，由频道参数定义（有0代表第一个频道）\n\n# AudioContext\n\n名称                    功能说明\nAudioContext.pause    暂停音频\nAudioContext.play     播放音频\nAudioContext.seek     跳转到指定位置\nAudioContext.setSrc   设置音频地址\n\n# InnerAudioContext\n\n名称                                功能说明\nInnerAudioContext.destroy         销毁当前实例\nInnerAudioContext.offCanplay      取消监听音频进入可以播放状态的事件\nInnerAudioContext.offEnded        取消监听音频自然播放至结束的事件\nInnerAudioContext.offError        取消监听音频播放错误事件\nInnerAudioContext.offPause        取消监听音频暂停事件\nInnerAudioContext.offPlay         取消监听音频播放事件\nInnerAudioContext.offSeeked       取消监听音频完成跳转操作的事件\nInnerAudioContext.offSeeking      取消监听音频进行跳转操作的事件\nInnerAudioContext.offStop         取消监听音频停止事件\nInnerAudioContext.offTimeUpdate   取消监听音频播放进度更新事件\nInnerAudioContext.offWaiting      取消监听音频加载中事件\nInnerAudioContext.onCanplay       监听音频进入可以播放状态的事件\nInnerAudioContext.onEnded         监听音频自然播放至结束的事件\nInnerAudioContext.onError         监听音频播放错误事件\nInnerAudioContext.onPause         监听音频暂停事件\nInnerAudioContext.onPlay          监听音频播放事件\nInnerAudioContext.onSeeked        监听音频完成跳转操作的事件\nInnerAudioContext.onSeeking       监听音频进行跳转操作的事件\nInnerAudioContext.onStop          监听音频停止事件\nInnerAudioContext.onTimeUpdate    监听音频播放进度更新事件\nInnerAudioContext.onWaiting       监听音频加载中事件\nInnerAudioContext.pause           暂停\nInnerAudioContext.play            播放\nInnerAudioContext.seek            跳转到指定位置\nInnerAudioContext.stop            停止\n\n# MediaAudioPlayer\n\n名称                                   功能说明\nMediaAudioPlayer.addAudioSource      添加音频源\nMediaAudioPlayer.destroy             销毁播放器\nMediaAudioPlayer.removeAudioSource   移除音频源\nMediaAudioPlayer.start               启动播放器\nMediaAudioPlayer.stop                停止播放器\n\n# WebAudioContext\n\n名称                                         功能说明\nWebAudioContext.close                      关闭WebAudioContext\nWebAudioContext.createBiquadFilter         创建一个BiquadFilterNode\nWebAudioContext.createBuffer               创建一个AudioBuffer，代表着一段驻留在内存中的短音频\nWebAudioContext.createBufferSource         创建一个BufferSourceNode实例，通过AudioBuffer对象来播放音频数据\nWebAudioContext.createChannelMerger        创建一个ChannelMergerNode\nWebAudioContext.createChannelSplitter      创建一个ChannelSplitterNode\nWebAudioContext.createConstantSource       创建一个ConstantSourceNode\nWebAudioContext.createDelay                创建一个DelayNode\nWebAudioContext.createDynamicsCompressor   创建一个DynamicsCompressorNode\nWebAudioContext.createGain                 创建一个GainNode\nWebAudioContext.createIIRFilter            创建一个IIRFilterNode\nWebAudioContext.createOscillator           创建一个OscillatorNode\nWebAudioContext.createPanner               创建一个PannerNode\nWebAudioContext.createPeriodicWave         创建一个PeriodicWaveNode\nWebAudioContext.createScriptProcessor      创建一个ScriptProcessorNode\nWebAudioContext.createWaveShaper           创建一个WaveShaperNode\nWebAudioContext.decodeAudioData            异步解码一段资源为AudioBuffer\nWebAudioContext.resume                     同步恢复已经被暂停的WebAudioContext上下文\nWebAudioContext.suspend                    同步暂停WebAudioContext上下文\nWebAudioContextNode                        一类音频处理模块，不同的Node具备不同的功能，如GainNode(音量调整)等\n\n\n# 背景音频\n\n名称                                 功能说明\nwx.stopBackgroundAudio             停止播放音乐\nwx.seekBackgroundAudio             控制音乐播放进度\nwx.playBackgroundAudio             使用后台播放器播放音乐\nwx.pauseBackgroundAudio            暂停播放音乐\nwx.onBackgroundAudioStop           监听音乐停止事件\nwx.onBackgroundAudioPlay           监听音乐播放事件\nwx.onBackgroundAudioPause          监听音乐暂停事件\nwx.getBackgroundAudioPlayerState   获取后台音乐播放状态\nwx.getBackgroundAudioManager       获取全局唯一的背景音频管理器\n\n# BackgroundAudioManager\n\n名称                                    功能说明\nBackgroundAudioManager.onCanplay      监听背景音频进入可播放状态事件\nBackgroundAudioManager.onEnded        监听背景音频自然播放结束事件\nBackgroundAudioManager.onError        监听背景音频播放错误事件\nBackgroundAudioManager.onNext         监听用户在系统音乐播放面板点击下一曲事件（仅iOS）\nBackgroundAudioManager.onPause        监听背景音频暂停事件\nBackgroundAudioManager.onPlay         监听背景音频播放事件\nBackgroundAudioManager.onPrev         监听用户在系统音乐播放面板点击上一曲事件（仅iOS）\nBackgroundAudioManager.onSeeked       监听背景音频完成跳转操作事件\nBackgroundAudioManager.onSeeking      监听背景音频开始跳转操作事件\nBackgroundAudioManager.onStop         监听背景音频停止事件\nBackgroundAudioManager.onTimeUpdate   监听背景音频播放进度更新事件，只有小程序在前台时会回调\nBackgroundAudioManager.onWaiting      监听音频加载中事件\nBackgroundAudioManager.pause          暂停音乐\nBackgroundAudioManager.play           播放音乐\nBackgroundAudioManager.seek           跳转到指定位置\nBackgroundAudioManager.stop           停止音乐\n\n\n# 实时音视频\n\n名称                           功能说明\nwx.createLivePusherContext   创建 live-pusher 上下文 LivePusherContext 对象\nwx.createLivePlayerContext   创建 live-player 上下文 LivePlayerContext 对象\n\n# LivePlayerContext\n\n名称                                          功能说明\nLivePlayerContext.exitFullScreen            退出全屏\nLivePlayerContext.exitPictureInPicture      退出小窗，该方法可在任意页面调用\nLivePlayerContext.mute                      静音\nLivePlayerContext.pause                     暂停\nLivePlayerContext.play                      播放\nLivePlayerContext.requestFullScreen         进入全屏\nLivePlayerContext.requestPictureInPicture   进入小窗\nLivePlayerContext.resume                    恢复\nLivePlayerContext.snapshot                  截图\nLivePlayerContext.stop                      停止\n\n# LivePusherContext\n\n名称                               功能说明\nLivePusherContext.pause          暂停推流\nLivePusherContext.pauseBGM       暂停背景音\nLivePusherContext.playBGM        播放背景音\nLivePusherContext.resume         恢复推流\nLivePusherContext.resumeBGM      恢复背景音\nLivePusherContext.sendMessage    发送SEI消息\nLivePusherContext.setBGMVolume   设置背景音音量\nLivePusherContext.setMICVolume   设置麦克风音量\nLivePusherContext.snapshot       快照\nLivePusherContext.start          开始推流，同时开启摄像头预览\nLivePusherContext.startPreview   开启摄像头预览\nLivePusherContext.stop           停止推流，同时停止摄像头预览\nLivePusherContext.stopBGM        停止背景音\nLivePusherContext.stopPreview    关闭摄像头预览\nLivePusherContext.switchCamera   切换前后摄像头\nLivePusherContext.toggleTorch    切换手电筒\n\n\n# 录音\n\n名称                      功能说明\nwx.stopRecord           停止录音\nwx.startRecord          开始录音\nwx.getRecorderManager   获取全局唯一的录音管理器 RecorderManager\n\n# RecorderManager\n\n名称                                    功能说明\nRecorderManager.onError               监听录音错误事件\nRecorderManager.onFrameRecorded       监听已录制完指定帧大小的文件事件\nRecorderManager.onInterruptionBegin   监听录音因为受到系统占用而被中断开始事件\nRecorderManager.onInterruptionEnd     监听录音中断结束事件\nRecorderManager.onPause               监听录音暂停事件\nRecorderManager.onResume              监听录音继续事件\nRecorderManager.onStart               监听录音开始事件\nRecorderManager.onStop                监听录音结束事件\nRecorderManager.pause                 暂停录音\nRecorderManager.resume                继续录音\nRecorderManager.start                 开始录音\nRecorderManager.stop                  停止录音\n\n\n# 相机\n\n名称                       功能说明\nwx.createCameraContext   创建 camera 上下文 CameraContext 对象\n\n# CameraContext\n\n名称                            功能说明\nCameraContext.onCameraFrame   获取 Camera 实时帧数据\nCameraContext.setZoom         设置缩放级别\nCameraContext.startRecord     开始录像\nCameraContext.stopRecord      结束录像\nCameraContext.takePhoto       拍摄照片\n\n# CameraFrameListener\n\n名称                          功能说明\nCameraFrameListener.start   开始监听帧数据\nCameraFrameListener.stop    停止监听帧数据\n\n\n# 富文本\n\n名称   功能说明\n     \n\n# EditorContext\n\n名称                               功能说明\nEditorContext.blur               编辑器失焦，同时收起键盘\nEditorContext.clear              清空编辑器内容\nEditorContext.format             修改样式\nEditorContext.getContents        获取编辑器内容\nEditorContext.getSelectionText   获取编辑器已选区域内的纯文本内容\nEditorContext.insertDivider      插入分割线\nEditorContext.insertImage        插入图片\nEditorContext.insertText         覆盖当前选区，设置一段文本\nEditorContext.redo               恢复\nEditorContext.removeFormat       清除当前选区的样式\nEditorContext.scrollIntoView     使得编辑器光标处滚动到窗口可视区域内\nEditorContext.setContents        初始化编辑器内容，html和delta同时存在时仅delta生效\nEditorContext.undo               撤销\n\n\n# 音视频合成\n\n名称                        功能说明\nwx.createMediaContainer   创建音视频处理容器，最终可将容器中的轨道合成一个视频\n\n# MediaContainer\n\n名称                                 功能说明\nMediaContainer.addTrack            将音频或视频轨道添加到容器\nMediaContainer.destroy             将容器销毁，释放资源\nMediaContainer.export              将容器内的轨道合并并导出视频文件\nMediaContainer.extractDataSource   将传入的视频源分离轨道\nMediaContainer.removeTrack         将音频或视频轨道从容器中移除\nMediaTrack                         可通过 MediaContainer.extractDataSource 返回\n\n\n# 实时语音\n\n名称                              功能说明\nwx.updateVoIPChatMuteConfig     更新实时语音静音设置\nwx.subscribeVoIPVideoMembers    订阅视频画面成员\nwx.onVoIPVideoMembersChanged    监听实时语音通话成员视频状态变化事件\nwx.onVoIPChatStateChanged       监听房间状态变化事件\nwx.onVoIPChatSpeakersChanged    监听实时语音通话成员通话状态变化事件\nwx.onVoIPChatMembersChanged     监听实时语音通话成员在线状态变化事件\nwx.onVoIPChatInterrupted        监听被动断开实时语音通话事件\nwx.offVoIPVideoMembersChanged   取消监听实时语音通话成员视频状态变化事件\nwx.offVoIPChatStateChanged      取消监听房间状态变化事件\nwx.offVoIPChatMembersChanged    取消监听实时语音通话成员在线状态变化事件\nwx.offVoIPChatInterrupted       取消监听被动断开实时语音通话事件\nwx.joinVoIPChat                 加入 (创建) 实时语音通话，更多信息可见 实时语音指南\nwx.exitVoIPChat                 退出（销毁）实时语音通话\n\n\n# 画面录制器\n\n名称                       功能说明\nwx.createMediaRecorder   创建 WebGL 画面录制器，可逐帧录制在 WebGL 上渲染的画面并导出视频文件\n\n# MediaRecorder\n\n名称                           功能说明\nMediaRecorder.destroy        销毁录制器\nMediaRecorder.off            取消监听录制事件\nMediaRecorder.on             注册监听录制事件的回调函数\nMediaRecorder.pause          暂停录制\nMediaRecorder.requestFrame   请求下一帧录制，在 callback 里完成一帧渲染后开始录制当前帧\nMediaRecorder.resume         恢复录制\nMediaRecorder.start          开始录制\nMediaRecorder.stop           结束录制\n\n\n# 视频解码器\n\n名称                      功能说明\nwx.createVideoDecoder   创建视频解码器，可逐帧获取解码后的数据\n\n# VideoDecoder\n\n名称                          功能说明\nVideoDecoder.getFrameData   获取下一帧的解码数据\nVideoDecoder.off            取消监听录制事件\nVideoDecoder.on             注册监听录制事件的回调函数\nVideoDecoder.remove         移除解码器\nVideoDecoder.seek           跳到某个时间点解码\nVideoDecoder.start          开始解码\nVideoDecoder.stop           停止解码\n\n\n# 位置\n\n名称                                 功能说明\nwx.stopLocationUpdate              关闭监听实时位置变化，前后台都停止消息接收\nwx.startLocationUpdateBackground   开启小程序进入前后台时均接收位置消息，需引导用户开启授权\nwx.startLocationUpdate             开启小程序进入前台时接收位置消息\nwx.openLocation                    使用微信内置地图查看位置\nwx.onLocationChange                监听实时地理位置变化事件，需结合\n                                   wx.startLocationUpdateBackground、wx.startLocationUpdate使用\nwx.offLocationChange               取消监听实时地理位置变化事件\nwx.getLocation                     获取当前的地理位置、速度\nwx.choosePoi                       打开地图选择位置，支持模糊定位（精确到市）和精确定位混选\nwx.chooseLocation                  打开地图选择位置\n\n\n# 文件\n\n名称                        功能说明\nwx.saveFileToDisk         保存文件系统的文件到用户磁盘，仅在 PC 端支持\nwx.saveFile               保存文件到本地\nwx.removeSavedFile        删除本地缓存文件\nwx.openDocument           新开页面打开文档\nwx.getSavedFileList       获取该小程序下已保存的本地缓存文件列表\nwx.getSavedFileInfo       获取本地文件的文件信息\nwx.getFileSystemManager   获取全局唯一的文件管理器\nwx.getFileInfo            获取文件信息\n\n\n# FileSystemManager\n\n名称                                   功能说明\nFileSystemManager.access             判断文件/目录是否存在\nFileSystemManager.accessSync         FileSystemManager.access 的同步版本\nFileSystemManager.appendFile         在文件结尾追加内容\nFileSystemManager.appendFileSync     FileSystemManager.appendFile 的同步版本\nFileSystemManager.close              关闭文件\nFileSystemManager.closeSync          同步关闭文件\nFileSystemManager.copyFile           复制文件\nFileSystemManager.copyFileSync       FileSystemManager.copyFile 的同步版本\nFileSystemManager.fstat              获取文件的状态信息\nFileSystemManager.fstatSync          同步获取文件的状态信息\nFileSystemManager.ftruncate          对文件内容进行截断操作\nFileSystemManager.ftruncateSync      对文件内容进行截断操作\nFileSystemManager.getFileInfo        获取该小程序下的 本地临时文件 或 本地缓存文件 信息\nFileSystemManager.getSavedFileList   获取该小程序下已保存的本地缓存文件列表\nFileSystemManager.mkdir              创建目录\nFileSystemManager.mkdirSync          FileSystemManager.mkdir 的同步版本\nFileSystemManager.open               打开文件，返回文件描述符\nFileSystemManager.openSync           同步打开文件，返回文件描述符\nFileSystemManager.read               读文件\nFileSystemManager.readdir            读取目录内文件列表\nFileSystemManager.readdirSync        FileSystemManager.readdir 的同步版本\nFileSystemManager.readFile           读取本地文件内容\nFileSystemManager.readFileSync       FileSystemManager.readFile 的同步版本\nFileSystemManager.readSync           读文件\nFileSystemManager.readZipEntry       读取压缩包内的文件\nFileSystemManager.removeSavedFile    删除该小程序下已保存的本地缓存文件\nFileSystemManager.rename             重命名文件\nFileSystemManager.renameSync         FileSystemManager.rename 的同步版本\nFileSystemManager.rmdir              删除目录\nFileSystemManager.rmdirSync          FileSystemManager.rmdir 的同步版本\nFileSystemManager.saveFile           保存临时文件到本地\nFileSystemManager.saveFileSync       FileSystemManager.saveFile 的同步版本\nFileSystemManager.stat               获取文件 Stats 对象\nFileSystemManager.statSync           FileSystemManager.stat 的同步版本\nFileSystemManager.truncate           对文件内容进行截断操作\nFileSystemManager.truncateSync       对文件内容进行截断操作 (truncate 的同步版本)\nFileSystemManager.unlink             删除文件\nFileSystemManager.unlinkSync         FileSystemManager.unlink 的同步版本\nFileSystemManager.unzip              解压文件\nFileSystemManager.write              写入文件\nFileSystemManager.writeFile          写文件\nFileSystemManager.writeFileSync      FileSystemManager.writeFile 的同步版本\nFileSystemManager.writeSync          同步写入文件\nReadResult                           文件读取结果\n\n\n# Stats\n\n名称                  功能说明\nStats.isDirectory   判断当前文件是否一个目录\nStats.isFile        判断当前文件是否一个普通文件\nWriteResult         文件写入结果\n\n\n# 开放接口\n\n\n# 登录\n\n名称                功能说明\nwx.login          调用接口获取登录凭证（code）\nwx.checkSession   检查登录态是否过期\n\n\n# 帐号信息\n\n名称                      功能说明\nwx.getAccountInfoSync   获取当前帐号信息\n\n\n# 用户信息\n\n名称                  功能说明\nwx.getUserProfile   获取用户信息\nwx.getUserInfo      获取用户信息\nUserInfo            用户信息\n\n\n# 授权\n\n名称                           功能说明\nwx.authorizeForMiniProgram   仅小程序插件中能调用该接口，用法同 wx.authorize\nwx.authorize                 提前向用户发起授权请求\n\n\n# 设置\n\n名称                     功能说明\nwx.openSetting         调起客户端小程序设置界面，返回用户设置的操作结果\nwx.getSetting          获取用户的当前设置\nAuthSetting            用户授权设置信息，详情参考权限\nSubscriptionsSetting   订阅消息设置\n\n\n# 收货地址\n\n名称                 功能说明\nwx.chooseAddress   获取用户收货地址\n\n\n# 卡券\n\n名称            功能说明\nwx.openCard   查看微信卡包中的卡券\nwx.addCard    批量添加卡券\n\n\n# 发票\n\n名称                      功能说明\nwx.chooseInvoiceTitle   选择用户的发票抬头\nwx.chooseInvoice        选择用户已有的发票\n\n\n# 生物认证\n\n名称                                     功能说明\nwx.startSoterAuthentication            开始 SOTER 生物认证\nwx.checkIsSupportSoterAuthentication   获取本机支持的 SOTER 生物认证方式\nwx.checkIsSoterEnrolledInDevice        获取设备内是否录入如指纹等生物信息的接口\n\n\n# 微信运动\n\n名称                功能说明\nwx.shareToWeRun   分享数据到微信运动\nwx.getWeRunData   获取用户过去三十天微信运动步数\n\n\n# 订阅消息\n\n名称                           功能说明\nwx.requestSubscribeMessage   调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果\n\n\n# 微信红包\n\n名称                  功能说明\nwx.showRedPackage   拉取h5领取红包封面页\n\n\n# 收藏\n\n名称                       功能说明\nwx.addVideoToFavorites   收藏视频\nwx.addFileToFavorites    收藏文件\n\n\n# 车牌\n\n名称                      功能说明\nwx.chooseLicensePlate   选择车牌号\n\n\n# 视频号\n\n名称                             功能说明\nwx.reserveChannelsLive         预约视频号直播\nwx.openChannelsLive            打开视频号直播\nwx.openChannelsActivity        打开视频号视频\nwx.getChannelsLiveNoticeInfo   获取视频号直播预告信息\nwx.getChannelsLiveInfo         获取视频号直播信息\n\n\n# 微信群\n\n名称                     功能说明\nwx.getGroupEnterInfo   获取微信群聊场景下的小程序启动信息\n\n\n# 微信客服\n\n名称                           功能说明\nwx.openCustomerServiceChat   打开微信客服\n\n\n# 设备\n\n\n# 蓝牙-通用\n\n名称                                  功能说明\nwx.stopBluetoothDevicesDiscovery    停止搜寻附近的蓝牙外围设备\nwx.startBluetoothDevicesDiscovery   开始搜寻附近的蓝牙外围设备\nwx.openBluetoothAdapter             初始化蓝牙模块\nwx.onBluetoothDeviceFound           监听搜索到新设备的事件\nwx.onBluetoothAdapterStateChange    监听蓝牙适配器状态变化事件\nwx.offBluetoothDeviceFound          取消监听寻找到新设备的事件\nwx.offBluetoothAdapterStateChange   取消监听蓝牙适配器状态变化事件\nwx.makeBluetoothPair                蓝牙配对接口，仅安卓支持\nwx.getConnectedBluetoothDevices     根据主服务 UUID 获取已连接的蓝牙设备\nwx.getBluetoothDevices              获取在蓝牙模块生效期间所有搜索到的蓝牙设备\nwx.getBluetoothAdapterState         获取本机蓝牙适配器状态\nwx.closeBluetoothAdapter            关闭蓝牙模块\n\n\n# 蓝牙-低功耗中心设备\n\n名称                                      功能说明\nwx.writeBLECharacteristicValue          向蓝牙低功耗设备特征值中写入二进制数据\nwx.setBLEMTU                            协商设置蓝牙低功耗的最大传输单元 (Maximum Transmission Unit, MTU)\nwx.readBLECharacteristicValue           读取蓝牙低功耗设备特征值的二进制数据\nwx.onBLEConnectionStateChange           监听蓝牙低功耗连接状态的改变事件\nwx.onBLECharacteristicValueChange       监听蓝牙低功耗设备的特征值变化事件\nwx.offBLEConnectionStateChange          取消监听蓝牙低功耗连接状态的改变事件\nwx.offBLECharacteristicValueChange      取消监听蓝牙低功耗设备的特征值变化事件\nwx.notifyBLECharacteristicValueChange   启用蓝牙低功耗设备特征值变化时的 notify 功能，订阅特征\nwx.getBLEDeviceServices                 获取蓝牙低功耗设备所有服务 (service)\nwx.getBLEDeviceRSSI                     获取蓝牙低功耗设备的信号强度 (Received Signal Strength Indication, RSSI)\nwx.getBLEDeviceCharacteristics          获取蓝牙低功耗设备某个服务中所有特征 (characteristic)\nwx.createBLEConnection                  连接蓝牙低功耗设备\nwx.closeBLEConnection                   断开与蓝牙低功耗设备的连接\n\n\n# 蓝牙-低功耗外围设备\n\n名称                                          功能说明\nwx.onBLEPeripheralConnectionStateChanged    监听当前外围设备被连接或断开连接事件\nwx.offBLEPeripheralConnectionStateChanged   取消监听当前外围设备被连接或断开连接事件\nwx.createBLEPeripheralServer                建立本地作为蓝牙低功耗外围设备的服务端，可创建多个\n\n# BLEPeripheralServer\n\n名称                                                  功能说明\nBLEPeripheralServer.addService                      添加服务\nBLEPeripheralServer.close                           关闭当前服务端\nBLEPeripheralServer.offCharacteristicReadRequest    取消监听已连接的设备请求读当前外围设备的特征值事件\nBLEPeripheralServer.offCharacteristicSubscribed     取消监听特征订阅事件\nBLEPeripheralServer.offCharacteristicUnsubscribed   取消监听取消特征订阅事件\nBLEPeripheralServer.offCharacteristicWriteRequest   取消监听已连接的设备请求写当前外围设备的特征值事件\nBLEPeripheralServer.onCharacteristicReadRequest     监听已连接的设备请求读当前外围设备的特征值事件\nBLEPeripheralServer.onCharacteristicSubscribed      监听特征订阅事件，仅 iOS 支持\nBLEPeripheralServer.onCharacteristicUnsubscribed    监听取消特征订阅事件，仅 iOS 支持\nBLEPeripheralServer.onCharacteristicWriteRequest    监听已连接的设备请求写当前外围设备的特征值事件\nBLEPeripheralServer.removeService                   移除服务\nBLEPeripheralServer.startAdvertising                开始广播本地创建的外围设备\nBLEPeripheralServer.stopAdvertising                 停止广播\nBLEPeripheralServer.writeCharacteristicValue        往指定特征写入二进制数据值，并通知已连接的主机，从机的特征值已发生变化，该接口会处理是走回包还是走订阅\n\n\n# 蓝牙-信标(Beacon)\n\n名称                          功能说明\nwx.stopBeaconDiscovery      停止搜索附近的 Beacon 设备\nwx.startBeaconDiscovery     开始搜索附近的 Beacon 设备\nwx.onBeaconUpdate           监听 Beacon 设备更新事件，仅能注册一个监听\nwx.onBeaconServiceChange    监听 Beacon 服务状态变化事件，仅能注册一个监听\nwx.offBeaconUpdate          取消监听 Beacon 设备更新事件\nwx.offBeaconServiceChange   取消监听 Beacon 服务状态变化事件\nwx.getBeacons               获取所有已搜索到的 Beacon 设备\nBeaconInfo                  Beacon 设备\n\n\n# NFC\n\n名称                  功能说明\nwx.stopHCE          关闭 NFC 模块\nwx.startHCE         初始化 NFC 模块\nwx.sendHCEMessage   发送 NFC 消息\nwx.onHCEMessage     监听接收 NFC 设备消息事件，仅能注册一个监听\nwx.offHCEMessage    接收 NFC 设备消息事件，取消事件监听\nwx.getNFCAdapter    获取 NFC 实例\nwx.getHCEState      判断当前设备是否支持 HCE 能力\n\n# IsoDep\n\n名称                              功能说明\nIsoDep.close                    断开连接\nIsoDep.connect                  连接 NFC 标签\nIsoDep.getHistoricalBytes       获取复位信息\nIsoDep.getMaxTransceiveLength   获取最大传输长度\nIsoDep.isConnected              检查是否已连接\nIsoDep.setTimeout               设置超时时间\nIsoDep.transceive               发送数据\n\n# MifareClassic\n\n名称                                     功能说明\nMifareClassic.close                    断开连接\nMifareClassic.connect                  连接 NFC 标签\nMifareClassic.getMaxTransceiveLength   获取最大传输长度\nMifareClassic.isConnected              检查是否已连接\nMifareClassic.setTimeout               设置超时时间\nMifareClassic.transceive               发送数据\n\n# MifareUltralight\n\n名称                                        功能说明\nMifareUltralight.close                    断开连接\nMifareUltralight.connect                  连接 NFC 标签\nMifareUltralight.getMaxTransceiveLength   获取最大传输长度\nMifareUltralight.isConnected              检查是否已连接\nMifareUltralight.setTimeout               设置超时时间\nMifareUltralight.transceive               发送数据\n\n# Ndef\n\n名称                      功能说明\nNdef.close              断开连接\nNdef.connect            连接 NFC 标签\nNdef.isConnected        检查是否已连接\nNdef.offNdefMessage     取消监听 Ndef 消息\nNdef.onNdefMessage      监听 Ndef 消息\nNdef.setTimeout         设置超时时间\nNdef.writeNdefMessage   重写 Ndef 标签内容\n\n# NfcA\n\n名称                            功能说明\nNfcA.close                    断开连接\nNfcA.connect                  连接 NFC 标签\nNfcA.getAtqa                  获取ATQA信息\nNfcA.getMaxTransceiveLength   获取最大传输长度\nNfcA.getSak                   获取SAK信息\nNfcA.isConnected              检查是否已连接\nNfcA.setTimeout               设置超时时间\nNfcA.transceive               发送数据\n\n# NFCAdapter\n\n名称                               功能说明\nNFCAdapter.getIsoDep             获取IsoDep实例，实例支持ISO-DEP (ISO 14443-4)标准的读写\nNFCAdapter.getMifareClassic      获取MifareClassic实例，实例支持MIFARE Classic标签的读写\nNFCAdapter.getMifareUltralight   获取MifareUltralight实例，实例支持MIFARE Ultralight标签的读写\nNFCAdapter.getNdef               获取Ndef实例，实例支持对NDEF格式的NFC标签上的NDEF数据的读写\nNFCAdapter.getNfcA               获取NfcA实例，实例支持NFC-A (ISO 14443-3A)标准的读写\nNFCAdapter.getNfcB               获取NfcB实例，实例支持NFC-B (ISO 14443-3B)标准的读写\nNFCAdapter.getNfcF               获取NfcF实例，实例支持NFC-F (JIS 6319-4)标准的读写\nNFCAdapter.getNfcV               获取NfcV实例，实例支持NFC-V (ISO 15693)标准的读写\nNFCAdapter.offDiscovered         取消监听 NFC Tag\nNFCAdapter.onDiscovered          监听 NFC Tag\nNFCAdapter.startDiscovery        \nNFCAdapter.stopDiscovery         \n\n# NfcB\n\n名称                            功能说明\nNfcB.close                    断开连接\nNfcB.connect                  连接 NFC 标签\nNfcB.getMaxTransceiveLength   获取最大传输长度\nNfcB.isConnected              检查是否已连接\nNfcB.setTimeout               设置超时时间\nNfcB.transceive               发送数据\n\n# NfcF\n\n名称                            功能说明\nNfcF.close                    断开连接\nNfcF.connect                  连接 NFC 标签\nNfcF.getMaxTransceiveLength   获取最大传输长度\nNfcF.isConnected              检查是否已连接\nNfcF.setTimeout               设置超时时间\nNfcF.transceive               发送数据\n\n# NfcV\n\n名称                            功能说明\nNfcV.close                    断开连接\nNfcV.connect                  连接 NFC 标签\nNfcV.getMaxTransceiveLength   获取最大传输长度\nNfcV.isConnected              检查是否已连接\nNfcV.setTimeout               设置超时时间\nNfcV.transceive               发送数据\n\n\n# Wi-Fi\n\n名称                    功能说明\nwx.stopWifi           关闭 Wi-Fi 模块\nwx.startWifi          初始化 Wi-Fi 模块\nwx.setWifiList        设置 wifiList 中 AP 的相关信息\nwx.onWifiConnected    监听连接上 Wi-Fi 的事件\nwx.onGetWifiList      监听获取到 Wi-Fi 列表数据事件\nwx.offWifiConnected   取消监听连接上 Wi-Fi 的事件\nwx.offGetWifiList     取消监听获取到 Wi-Fi 列表数据事件\nwx.getWifiList        请求获取 Wi-Fi 列表\nwx.getConnectedWifi   获取已连接中的 Wi-Fi 信息\nwx.connectWifi        连接 Wi-Fi\nWifiInfo              Wifi 信息\n\n\n# 日历\n\n名称                          功能说明\nwx.addPhoneRepeatCalendar   向系统日历添加重复事件\nwx.addPhoneCalendar         向系统日历添加事件\n\n\n# 联系人\n\n名称                   功能说明\nwx.searchContacts    查找通讯录，匹配相近的手机号\nwx.chooseContact     拉起手机通讯录，选择联系人\nwx.addPhoneContact   添加手机通讯录联系人\n\n\n# 无障碍\n\n名称                            功能说明\nwx.checkIsOpenAccessibility   检测是否开启视觉无障碍功能\n\n\n# 电量\n\n名称                      功能说明\nwx.getBatteryInfoSync   wx.getBatteryInfo 的同步版本\nwx.getBatteryInfo       获取设备电量\n\n\n# 剪贴板\n\n名称                    功能说明\nwx.setClipboardData   设置系统剪贴板的内容\nwx.getClipboardData   获取系统剪贴板的内容\n\n\n# 网络\n\n名称                          功能说明\nwx.onNetworkStatusChange    监听网络状态变化事件\nwx.offNetworkStatusChange   取消监听网络状态变化事件，参数为空，则取消所有的事件监听\nwx.getNetworkType           获取网络类型\n\n\n# 加密\n\n名称                   功能说明\nwx.getRandomValues   获取密码学安全随机数\n\n\n# 屏幕\n\n名称                        功能说明\nwx.setScreenBrightness    设置屏幕亮度\nwx.setKeepScreenOn        设置是否保持常亮状态\nwx.onUserCaptureScreen    监听用户主动截屏事件\nwx.offUserCaptureScreen   用户主动截屏事件\nwx.getScreenBrightness    获取屏幕亮度\n\n\n# 键盘\n\n名称                           功能说明\nwx.onKeyboardHeightChange    监听键盘高度变化\nwx.offKeyboardHeightChange   取消监听键盘高度变化事件\nwx.hideKeyboard              在input、textarea等focus拉起键盘之后，手动调用此接口收起键盘\nwx.getSelectedTextRange      在input、textarea等focus之后，获取输入框的光标位置\n\n\n# 电话\n\n名称                 功能说明\nwx.makePhoneCall   拨打电话\n\n\n# 加速计\n\n名称                          功能说明\nwx.stopAccelerometer        停止监听加速度数据\nwx.startAccelerometer       开始监听加速度数据\nwx.onAccelerometerChange    监听加速度数据事件\nwx.offAccelerometerChange   取消监听加速度数据事件，参数为空，则取消所有的事件监听\n\n\n# 罗盘\n\n名称                    功能说明\nwx.stopCompass        停止监听罗盘数据\nwx.startCompass       开始监听罗盘数据\nwx.onCompassChange    监听罗盘数据变化事件\nwx.offCompassChange   取消监听罗盘数据变化事件，参数为空，则取消所有的事件监听\n\n\n# 设备方向\n\n名称                              功能说明\nwx.stopDeviceMotionListening    停止监听设备方向的变化\nwx.startDeviceMotionListening   开始监听设备方向的变化\nwx.onDeviceMotionChange         监听设备方向变化事件\nwx.offDeviceMotionChange        取消监听设备方向变化事件，参数为空，则取消所有的事件监听\n\n\n# 陀螺仪\n\n名称                      功能说明\nwx.stopGyroscope        停止监听陀螺仪数据\nwx.startGyroscope       开始监听陀螺仪数据\nwx.onGyroscopeChange    监听陀螺仪数据变化事件\nwx.offGyroscopeChange   取消监听陀螺仪数据变化事件\n\n\n# 内存\n\n名称                    功能说明\nwx.onMemoryWarning    监听内存不足告警事件\nwx.offMemoryWarning   取消监听内存不足告警事件\n\n\n# 扫码\n\n名称            功能说明\nwx.scanCode   调起客户端扫码界面进行扫码\n\n\n# 振动\n\n名称                功能说明\nwx.vibrateShort   使手机发生较短时间的振动（15 ms）\nwx.vibrateLong    使手机发生较长时间的振动（400 ms)\n\n\n# AI\n\n\n# 人脸识别\n\n名称                  功能说明\nwx.stopFaceDetect   停止人脸识别\nwx.initFaceDetect   初始化人脸识别\nwx.faceDetect       人脸识别，使用前需要通过 wx.initFaceDetect 进行一次初始化，推荐使用相机接口返回的帧数据\n\n\n# Worker\n\n名称                功能说明\nwx.createWorker   创建一个 Worker 线程\n\n\n# Worker\n\n名称                       功能说明\nWorker.onMessage         监听主线程/Worker 线程向当前线程发送的消息的事件\nWorker.onProcessKilled   监听\n                         worker线程被系统回收事件（当iOS系统资源紧张时，worker线程存在被系统回收的可能，开发者可监听此事件并重新创建一个worker）\nWorker.postMessage       向主线程/Worker 线程发送的消息\nWorker.terminate         结束当前 Worker 线程\n\n\n# WXML\n\n名称                              功能说明\nwx.createSelectorQuery          返回一个 SelectorQuery 对象实例\nwx.createIntersectionObserver   创建并返回一个 IntersectionObserver 对象实例\n\n\n# IntersectionObserver\n\n名称                                        功能说明\nIntersectionObserver.disconnect           停止监听\nIntersectionObserver.observe              指定目标节点并开始监听相交状态变化情况\nIntersectionObserver.relativeTo           使用选择器指定一个节点，作为参照区域之一\nIntersectionObserver.relativeToViewport   指定页面显示区域作为参照区域之一\n\n\n# MediaQueryObserver\n\n名称                              功能说明\nMediaQueryObserver.disconnect   停止监听\nMediaQueryObserver.observe      开始监听页面 media query 变化情况\n\n\n# NodesRef\n\n名称                            功能说明\nNodesRef.boundingClientRect   添加节点的布局位置的查询请求\nNodesRef.context              添加节点的 Context 对象查询请求\nNodesRef.fields               获取节点的相关信息\nNodesRef.node                 获取 Node 节点实例\nNodesRef.scrollOffset         添加节点的滚动位置查询请求\n\n\n# SelectorQuery\n\n名称                             功能说明\nSelectorQuery.exec             执行所有的请求\nSelectorQuery.in               将选择器的选取范围更改为自定义组件 component 内\nSelectorQuery.select           在当前页面下选择第一个匹配选择器 selector 的节点\nSelectorQuery.selectAll        在当前页面下选择匹配选择器 selector 的所有节点\nSelectorQuery.selectViewport   选择显示区域\n\n\n# 第三方平台\n\n名称                    功能说明\nwx.getExtConfigSync   wx.getExtConfig 的同步版本\nwx.getExtConfig       获取第三方平台自定义的数据字段\n\n\n# 广告\n\n名称                         功能说明\nwx.createRewardedVideoAd   创建激励视频广告组件\nwx.createInterstitialAd    创建插屏广告组件\n\n\n# InterstitialAd\n\n名称                        功能说明\nInterstitialAd.destroy    销毁插屏广告实例\nInterstitialAd.load       加载插屏广告\nInterstitialAd.offClose   取消监听插屏广告关闭事件\nInterstitialAd.offError   取消监听插屏错误事件\nInterstitialAd.offLoad    取消监听插屏广告加载事件\nInterstitialAd.onClose    监听插屏广告关闭事件\nInterstitialAd.onError    监听插屏错误事件\nInterstitialAd.onLoad     监听插屏广告加载事件\nInterstitialAd.show       显示插屏广告\n\n\n# RewardedVideoAd\n\n名称                         功能说明\nRewardedVideoAd.destroy    销毁激励视频广告实例\nRewardedVideoAd.load       加载激励视频广告\nRewardedVideoAd.offClose   取消监听用户点击 关闭广告 按钮的事件\nRewardedVideoAd.offError   取消监听激励视频错误事件\nRewardedVideoAd.offLoad    取消监听激励视频广告加载事件\nRewardedVideoAd.onClose    监听用户点击 关闭广告 按钮的事件\nRewardedVideoAd.onError    监听激励视频错误事件\nRewardedVideoAd.onLoad     监听激励视频广告加载事件\nRewardedVideoAd.show       显示激励视频广告",normalizedContent:"# api 参考\n\n> 在这里查看官方的最新文档\n\n> 以下标注 云调用 的接口可以使用微信云开发通过云函数免服务器直接发起云调用\n\n\n# 基础\n\n名称                       功能说明\nwx.env                   环境变量\nwx.caniuse               判断小程序的api，回调，参数，组件等是否在当前版本可用\nwx.base64toarraybuffer   将 base64 字符串转成 arraybuffer 对象\nwx.arraybuffertobase64   将 arraybuffer 对象转成 base64 字符串\n\n\n# 系统\n\n名称                      功能说明\nwx.getsysteminfosync    wx.getsysteminfo 的同步版本\nwx.getsysteminfoasync   异步获取系统信息\nwx.getsysteminfo        获取系统信息\n\n\n# 更新\n\n名称                    功能说明\nwx.updatewechatapp    更新客户端版本\nwx.getupdatemanager   获取全局唯一的版本更新管理器，用于管理小程序更新\n\n# updatemanager\n\n名称                               功能说明\nupdatemanager.applyupdate        强制小程序重启并使用新版本\nupdatemanager.oncheckforupdate   监听向微信后台请求检查更新结果事件\nupdatemanager.onupdatefailed     监听小程序更新失败事件\nupdatemanager.onupdateready      监听小程序有版本更新事件\n\n\n# 小程序\n\n# 生命周期\n\n名称                        功能说明\nwx.getlaunchoptionssync   获取小程序启动时的参数\nwx.getenteroptionssync    获取本次小程序启动时的参数\n\n# 应用级事件\n\n名称                             功能说明\nwx.onunhandledrejection        监听未处理的 promise 拒绝事件\nwx.onthemechange               监听系统主题改变事件\nwx.onpagenotfound              监听小程序要打开的页面不存在事件\nwx.onerror                     监听小程序错误事件\nwx.onaudiointerruptionend      监听音频中断结束事件\nwx.onaudiointerruptionbegin    监听音频因为受到系统占用而被中断开始事件\nwx.onappshow                   监听小程序切前台事件\nwx.onapphide                   监听小程序切后台事件\nwx.offunhandledrejection       取消监听未处理的 promise 拒绝事件\nwx.offthemechange              取消监听系统主题改变事件\nwx.offpagenotfound             取消监听小程序要打开的页面不存在事件\nwx.offerror                    取消监听小程序错误事件\nwx.offaudiointerruptionend     取消监听音频中断结束事件\nwx.offaudiointerruptionbegin   取消监听音频因为受到系统占用而被中断开始事件\nwx.offappshow                  取消监听小程序切前台事件\nwx.offapphide                  取消监听小程序切后台事件\n\n\n# 调试\n\n名称                         功能说明\nwx.setenabledebug          设置是否打开调试开关\nwx.getrealtimelogmanager   获取实时日志管理器对象\nwx.getlogmanager           获取日志管理器对象\n\n# logmanager\n\n名称                 功能说明\nlogmanager.debug   写 debug 日志\nlogmanager.info    写 info 日志\nlogmanager.log     写 log 日志\nlogmanager.warn    写 warn 日志\n\n# realtimelogmanager\n\n名称                                   功能说明\nrealtimelogmanager.addfiltermsg      添加过滤关键字，暂不支持在插件使用\nrealtimelogmanager.error             写 error 日志，暂不支持在插件使用\nrealtimelogmanager.getcurrentstate   实时日志会将一定时间间隔内缓存的日志聚合上报，如果该时间内缓存的内容超出限制，则会被丢弃\nrealtimelogmanager.in                设置实时日志page参数所在的页面，暂不支持在插件使用\nrealtimelogmanager.info              写 info 日志，暂不支持在插件使用\nrealtimelogmanager.setfiltermsg      设置过滤关键字，暂不支持在插件使用\nrealtimelogmanager.tag               获取给定标签的日志管理器实例，目前只支持在插件使用\nrealtimelogmanager.warn              写 warn 日志，暂不支持在插件使用\n\n# realtimetaglogmanager\n\n名称                                   功能说明\nrealtimetaglogmanager.addfiltermsg   添加过滤关键字\nrealtimetaglogmanager.error          写 error 日志\nrealtimetaglogmanager.info           写 info 日志\nrealtimetaglogmanager.setfiltermsg   设置过滤关键字\nrealtimetaglogmanager.warn           写 warn 日志\n\n\n# 性能\n\n名称                     功能说明\nwx.reportperformance   小程序测速上报\nwx.getperformance      获取当前小程序性能相关的信息\n\n# entrylist\n\n名称                           功能说明\nentrylist.getentries         该方法返回当前列表中的所有性能数据\nentrylist.getentriesbyname   获取当前列表中所有名称为 [name] 且类型为 [entrytype] 的性能数据\nentrylist.getentriesbytype   获取当前列表中所有类型为 [entrytype] 的性能数据\n\n# performance\n\n名称                             功能说明\nperformance.createobserver     创建全局性能事件监听器\nperformance.getentries         该方法返回当前缓冲区中的所有性能数据\nperformance.getentriesbyname   获取当前缓冲区中所有名称为 [name] 且类型为 [entrytype] 的性能数据\nperformance.getentriesbytype   获取当前缓冲区中所有类型为 [entrytype] 的性能数据\nperformance.setbuffersize      设置缓冲区大小， 默认缓冲 30 条性能数据\n\n# performanceobserver\n\n名称                               功能说明\nperformanceobserver.disconnect   停止监听\nperformanceobserver.observe      开始监听\n\n\n# 加密\n\n名称                        功能说明\nwx.getusercryptomanager   获取用户加密模块\n\n# usercryptomanager\n\n名称                                   功能说明\nusercryptomanager.getlatestuserkey   获取最新的用户加密密钥\nusercryptomanager.getrandomvalues    获取密码学安全随机数\n\n\n# 路由\n\n名称                功能说明\nwx.switchtab      跳转到 tabbar 页面，并关闭其他所有非 tabbar 页面\nwx.relaunch       关闭所有页面，打开到应用内的某个页面\nwx.redirectto     关闭当前页面，跳转到应用内的某个页面\nwx.navigateto     保留当前页面，跳转到应用内的某个页面\nwx.navigateback   关闭当前页面，返回上一页面或多级页面\n\n\n# eventchannel\n\n名称                  功能说明\neventchannel.emit   触发一个事件\neventchannel.off    取消监听一个事件\neventchannel.on     持续监听一个事件\neventchannel.once   监听一个事件一次，触发后失效\n\n\n# 跳转\n\n名称                           功能说明\nwx.navigatetominiprogram     打开另一个小程序\nwx.navigatebackminiprogram   返回到上一个小程序\nwx.exitminiprogram           退出当前小程序\n\n\n# 转发\n\n名称                      功能说明\nwx.updatesharemenu      更新转发属性\nwx.showsharemenu        显示当前页面的转发按钮\nwx.showshareimagemenu   打开分享图片弹窗，可以将图片发送给朋友、收藏或下载\nwx.sharevideomessage    转发视频到聊天\nwx.sharefilemessage     转发文件到聊天\nwx.oncopyurl            监听用户点击右上角菜单的「复制链接」按钮时触发的事件\nwx.offcopyurl           取消监听用户点击右上角菜单的「复制链接」按钮时触发的事件\nwx.hidesharemenu        隐藏当前页面的转发按钮\nwx.getshareinfo         获取转发详细信息\nwx.authprivatemessage   验证私密消息\n\n\n# 界面\n\n\n# 交互\n\n名称                            功能说明\nwx.showtoast                  显示消息提示框\nwx.showmodal                  显示模态对话框\nwx.showloading                显示 loading 提示框\nwx.showactionsheet            显示操作菜单\nwx.hidetoast                  隐藏消息提示框\nwx.hideloading                隐藏 loading 提示框\nwx.enablealertbeforeunload    开启小程序页面返回询问对话框\nwx.disablealertbeforeunload   关闭小程序页面返回询问对话框\n\n\n# 导航栏\n\n名称                            功能说明\nwx.shownavigationbarloading   在当前页面显示导航条加载动画\nwx.setnavigationbartitle      动态设置当前页面的标题\nwx.setnavigationbarcolor      设置页面导航条颜色\nwx.hidenavigationbarloading   在当前页面隐藏导航条加载动画\nwx.hidehomebutton             隐藏返回首页按钮\n\n\n# 背景\n\n名称                          功能说明\nwx.setbackgroundtextstyle   动态设置下拉背景字体、loading 图的样式\nwx.setbackgroundcolor       动态设置窗口的背景色\n\n\n# tab bar\n\n名称                     功能说明\nwx.showtabbarreddot    显示 tabbar 某一项的右上角的红点\nwx.showtabbar          显示 tabbar\nwx.settabbarstyle      动态设置 tabbar 的整体样式\nwx.settabbaritem       动态设置 tabbar 某一项的内容，2.7.0 起图片支持临时文件和网络文件\nwx.settabbarbadge      为 tabbar 某一项的右上角添加文本\nwx.removetabbarbadge   移除 tabbar 某一项右上角的文本\nwx.hidetabbarreddot    隐藏 tabbar 某一项的右上角的红点\nwx.hidetabbar          隐藏 tabbar\n\n\n# 字体\n\n名称                功能说明\nwx.loadfontface   动态加载网络字体，文件地址需为下载类型\n\n\n# 下拉刷新\n\n名称                        功能说明\nwx.stoppulldownrefresh    停止当前页面下拉刷新\nwx.startpulldownrefresh   开始下拉刷新\n\n\n# 滚动\n\n名称                功能说明\nwx.pagescrollto   将页面滚动到目标位置，支持选择器和滚动距离两种方式定位\n\n# scrollviewcontext\n\n名称                                 功能说明\nscrollviewcontext.scrollintoview   滚动至指定位置\nscrollviewcontext.scrollto         滚动至指定位置\n\n\n# 动画\n\n名称                   功能说明\nwx.createanimation   创建一个动画实例 animation\n\n# animation\n\n名称                          功能说明\nanimation.backgroundcolor   设置背景色\nanimation.bottom            设置 bottom 值\nanimation.export            导出动画队列\nanimation.height            设置高度\nanimation.left              设置 left 值\nanimation.matrix            同 transform-function matrix\nanimation.matrix3d          同 transform-function matrix3d\nanimation.opacity           设置透明度\nanimation.right             设置 right 值\nanimation.rotate            从原点顺时针旋转一个角度\nanimation.rotate3d          从 固定 轴顺时针旋转一个角度\nanimation.rotatex           从 x 轴顺时针旋转一个角度\nanimation.rotatey           从 y 轴顺时针旋转一个角度\nanimation.rotatez           从 z 轴顺时针旋转一个角度\nanimation.scale             缩放\nanimation.scale3d           缩放\nanimation.scalex            缩放 x 轴\nanimation.scaley            缩放 y 轴\nanimation.scalez            缩放 z 轴\nanimation.skew              对 x、y 轴坐标进行倾斜\nanimation.skewx             对 x 轴坐标进行倾斜\nanimation.skewy             对 y 轴坐标进行倾斜\nanimation.step              表示一组动画完成\nanimation.top               设置 top 值\nanimation.translate         平移变换\nanimation.translate3d       对 xyz 坐标进行平移变换\nanimation.translatex        对 x 轴平移\nanimation.translatey        对 y 轴平移\nanimation.translatez        对 z 轴平移\nanimation.width             设置宽度\n\n\n# 置顶\n\n名称                 功能说明\nwx.settopbartext   动态设置置顶栏文字内容\n\n\n# 自定义组件\n\n名称            功能说明\nwx.nexttick   延迟一部分操作到下一个时间片再执行\n\n\n# 菜单\n\n名称                                   功能说明\nwx.getmenubuttonboundingclientrect   获取菜单按钮（右上角胶囊按钮）的布局位置信息\n\n\n# 窗口\n\n名称                   功能说明\nwx.setwindowsize     设置窗口大小，该接口仅适用于 pc 平台，使用细则请参见指南\nwx.onwindowresize    监听窗口尺寸变化事件\nwx.offwindowresize   取消监听窗口尺寸变化事件\n\n\n# 网络\n\n\n# 发起请求\n\n名称           功能说明\nwx.request   发起 https 网络请求\n\n# requesttask\n\n名称                               功能说明\nrequesttask.abort                中断请求任务\nrequesttask.offheadersreceived   取消监听 http response header 事件\nrequesttask.onheadersreceived    监听 http response header 事件\n\n\n# 下载\n\n名称                功能说明\nwx.downloadfile   下载文件资源到本地\n\n# downloadtask\n\n名称                                功能说明\ndownloadtask.abort                中断下载任务\ndownloadtask.offheadersreceived   取消监听 http response header 事件\ndownloadtask.offprogressupdate    取消监听下载进度变化事件\ndownloadtask.onheadersreceived    监听 http response header 事件\ndownloadtask.onprogressupdate     监听下载进度变化事件\n\n\n# 上传\n\n名称              功能说明\nwx.uploadfile   将本地资源上传到服务器\n\n# uploadtask\n\n名称                              功能说明\nuploadtask.abort                中断上传任务\nuploadtask.offheadersreceived   取消监听 http response header 事件\nuploadtask.offprogressupdate    取消监听上传进度变化事件\nuploadtask.onheadersreceived    监听 http response header 事件\nuploadtask.onprogressupdate     监听上传进度变化事件\n\n\n# websocket\n\n名称                     功能说明\nwx.sendsocketmessage   通过 websocket 连接发送数据\nwx.onsocketopen        监听 websocket 连接打开事件\nwx.onsocketmessage     监听 websocket 接受到服务器的消息事件\nwx.onsocketerror       监听 websocket 错误事件\nwx.onsocketclose       监听 websocket 连接关闭事件\nwx.connectsocket       创建一个 websocket 连接\nwx.closesocket         关闭 websocket 连接\n\n# sockettask\n\n名称                     功能说明\nsockettask.close       关闭 websocket 连接\nsockettask.onclose     监听 websocket 连接关闭事件\nsockettask.onerror     监听 websocket 错误事件\nsockettask.onmessage   监听 websocket 接受到服务器的消息事件\nsockettask.onopen      监听 websocket 连接打开事件\nsockettask.send        通过 websocket 连接发送数据\n\n\n# mdns\n\n名称                                功能说明\nwx.stoplocalservicediscovery      停止搜索 mdns 服务\nwx.startlocalservicediscovery     开始搜索局域网下的 mdns 服务\nwx.onlocalserviceresolvefail      监听 mdns 服务解析失败的事件\nwx.onlocalservicelost             监听 mdns 服务离开的事件\nwx.onlocalservicefound            监听 mdns 服务发现的事件\nwx.onlocalservicediscoverystop    监听 mdns 服务停止搜索的事件\nwx.offlocalserviceresolvefail     取消监听 mdns 服务解析失败的事件\nwx.offlocalservicelost            取消监听 mdns 服务离开的事件\nwx.offlocalservicefound           取消监听 mdns 服务发现的事件\nwx.offlocalservicediscoverystop   取消监听 mdns 服务停止搜索的事件\n\n\n# tcp 通信\n\n名称                   功能说明\nwx.createtcpsocket   创建一个 tcp socket 实例\n\n# tcpsocket\n\n名称                     功能说明\ntcpsocket.close        关闭连接\ntcpsocket.connect      在给定的套接字上启动连接\ntcpsocket.offclose     取消监听一旦 socket 完全关闭就发出该事件\ntcpsocket.offconnect   取消监听当一个 socket 连接成功建立的时候触发该事件\ntcpsocket.offerror     取消监听当错误发生时触发\ntcpsocket.offmessage   取消监听当接收到数据的时触发该事件\ntcpsocket.onclose      监听一旦 socket 完全关闭就发出该事件\ntcpsocket.onconnect    监听当一个 socket 连接成功建立的时候触发该事件\ntcpsocket.onerror      监听当错误发生时触发\ntcpsocket.onmessage    监听当接收到数据的时触发该事件\ntcpsocket.write        在 socket 上发送数据\n\n\n# udp 通信\n\n名称                   功能说明\nwx.createudpsocket   创建一个 udp socket 实例\n\n# udpsocket\n\n名称                       功能说明\nudpsocket.bind           绑定一个系统随机分配的可用端口，或绑定一个指定的端口号\nudpsocket.close          关闭 udp socket 实例，相当于销毁\nudpsocket.connect        预先连接到指定的 ip 和 port，需要配合 write 方法一起使用\nudpsocket.offclose       取消监听关闭事件\nudpsocket.offerror       取消监听错误事件\nudpsocket.offlistening   取消监听开始监听数据包消息的事件\nudpsocket.offmessage     取消监听收到消息的事件\nudpsocket.onclose        监听关闭事件\nudpsocket.onerror        监听错误事件\nudpsocket.onlistening    监听开始监听数据包消息的事件\nudpsocket.onmessage      监听收到消息的事件\nudpsocket.send           向指定的 ip 和 port 发送消息\nudpsocket.setttl         设置 ip_ttl 套接字选项，用于设置一个 ip 数据包传输时允许的最大跳步数\nudpsocket.write          用法与 send 方法相同，如果没有预先调用 connect 则与 send 无差异（注意即使调用了 connect\n                         也需要在本接口填入地址和端口参数）\n\n\n# 支付\n\n名称                       功能说明\nwx.requestpayment        发起微信支付\nwx.requestorderpayment   创建自定义版交易组件订单，并发起支付\n\n\n# 数据缓存\n\n名称                      功能说明\nwx.setstoragesync       wx.setstorage 的同步版本\nwx.setstorage           将数据存储在本地缓存中指定的 key 中\nwx.revokebufferurl      根据 url 销毁存在内存中的数据\nwx.removestoragesync    wx.removestorage 的同步版本\nwx.removestorage        从本地缓存中移除指定 key\nwx.getstoragesync       wx.getstorage 的同步版本\nwx.getstorageinfosync   wx.getstorageinfo 的同步版本\nwx.getstorageinfo       异步获取当前storage的相关信息\nwx.getstorage           从本地缓存中异步获取指定 key 的内容\nwx.createbufferurl      根据传入的 buffer 创建一个唯一的 url 存在内存中\nwx.clearstoragesync     wx.clearstorage 的同步版本\nwx.clearstorage         清理本地数据缓存\n\n\n# 周期性更新\n\n名称                           功能说明\nwx.setbackgroundfetchtoken   设置自定义登录态，在周期性拉取数据时带上，便于第三方服务器验证请求合法性\nwx.onbackgroundfetchdata     监听收到 backgroundfetch 数据时的回调\nwx.getbackgroundfetchtoken   获取设置过的自定义登录态\nwx.getbackgroundfetchdata    拉取 backgroundfetch 客户端缓存数据\n\n\n# 数据分析\n\n名称                   功能说明\nwx.reportmonitor     自定义业务数据监控上报接口\nwx.reportevent       事件上报\nwx.reportanalytics   自定义分析数据上报接口\nwx.getexptinfosync   给定实验参数数组，获取对应的实验参数值\n\n\n# 画布\n\n名称                         功能说明\nwx.createoffscreencanvas   创建离屏 canvas 实例\nwx.createcanvascontext     创建 canvas 的绘图上下文 canvascontext 对象\nwx.canvastotempfilepath    把当前画布指定区域的内容导出生成指定大小的图片\nwx.canvasputimagedata      将像素数据绘制到画布\nwx.canvasgetimagedata      获取 canvas 区域隐含的像素数据\n\n\n# canvas\n\n名称                             功能说明\ncanvas.cancelanimationframe    取消由 requestanimationframe 添加到计划中的动画帧请求\ncanvas.createimage             创建一个图片对象\ncanvas.createimagedata         创建一个 imagedata 对象\ncanvas.createpath2d            创建 path2d 对象\ncanvas.getcontext              该方法返回 canvas 的绘图上下文\ncanvas.requestanimationframe   在下次进行重绘时执行\ncanvas.todataurl               返回一个包含图片展示的 data uri\n\n\n# canvascontext\n\n名称                                     功能说明\ncanvascontext.arc                      创建一条弧线\ncanvascontext.arcto                    根据控制点和半径绘制圆弧路径\ncanvascontext.beginpath                开始创建一个路径\ncanvascontext.beziercurveto            创建三次方贝塞尔曲线路径\ncanvascontext.clearrect                清除画布上在该矩形区域内的内容\ncanvascontext.clip                     从原始画布中剪切任意形状和尺寸\ncanvascontext.closepath                关闭一个路径\ncanvascontext.createcirculargradient   创建一个圆形的渐变颜色\ncanvascontext.createlineargradient     创建一个线性的渐变颜色\ncanvascontext.createpattern            对指定的图像创建模式的方法，可在指定的方向上重复元图像\ncanvascontext.draw                     将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中\ncanvascontext.drawimage                绘制图像到画布\ncanvascontext.fill                     对当前路径中的内容进行填充\ncanvascontext.fillrect                 填充一个矩形\ncanvascontext.filltext                 在画布上绘制被填充的文本\ncanvascontext.lineto                   增加一个新点，然后创建一条从上次指定点到目标点的线\ncanvascontext.measuretext              测量文本尺寸信息\ncanvascontext.moveto                   把路径移动到画布中的指定点，不创建线条\ncanvascontext.quadraticcurveto         创建二次贝塞尔曲线路径\ncanvascontext.rect                     创建一个矩形路径\ncanvascontext.restore                  恢复之前保存的绘图上下文\ncanvascontext.rotate                   以原点为中心顺时针旋转当前坐标轴\ncanvascontext.save                     保存绘图上下文\ncanvascontext.scale                    在调用后，之后创建的路径其横纵坐标会被缩放\ncanvascontext.setfillstyle             设置填充色\ncanvascontext.setfontsize              设置字体的字号\ncanvascontext.setglobalalpha           设置全局画笔透明度\ncanvascontext.setlinecap               设置线条的端点样式\ncanvascontext.setlinedash              设置虚线样式\ncanvascontext.setlinejoin              设置线条的交点样式\ncanvascontext.setlinewidth             设置线条的宽度\ncanvascontext.setmiterlimit            设置最大斜接长度\ncanvascontext.setshadow                设定阴影样式\ncanvascontext.setstrokestyle           设置描边颜色\ncanvascontext.settextalign             设置文字的对齐\ncanvascontext.settextbaseline          设置文字的竖直对齐\ncanvascontext.settransform             使用矩阵重新设置（覆盖）当前变换的方法\ncanvascontext.stroke                   画出当前路径的边框\ncanvascontext.strokerect               画一个矩形(非填充)\ncanvascontext.stroketext               给定的 (x, y) 位置绘制文本描边的方法\ncanvascontext.transform                使用矩阵多次叠加当前变换的方法\ncanvascontext.translate                对当前坐标系的原点 (0, 0) 进行变换\n\n\n# canvasgradient\n\n名称                            功能说明\ncanvasgradient.addcolorstop   添加颜色的渐变点\ncolor                         颜色\nimage                         图片对象\nimagedata                     imagedata 对象\n\n\n# offscreencanvas\n\n名称                            功能说明\noffscreencanvas.createimage   创建一个图片对象\noffscreencanvas.getcontext    该方法返回 offscreencanvas 的绘图上下文\npath2d                        canvas 2d api 的接口 path2d\n                              用来声明路径，此路径稍后会被canvasrenderingcontext2d 对象使用\nrenderingcontext              canvas 绘图上下文\n\n\n# 媒体\n\n\n# 地图\n\n名称                    功能说明\nwx.createmapcontext   创建 map 上下文 mapcontext 对象\n\n# mapcontext\n\n名称                               功能说明\nmapcontext.addcustomlayer        添加个性化图层\nmapcontext.addgroundoverlay      创建自定义图片图层，图片会随着地图缩放而缩放\nmapcontext.addmarkers            添加 marker\nmapcontext.fromscreenlocation    获取屏幕上的点对应的经纬度，坐标原点为地图左上角\nmapcontext.getcenterlocation     获取当前地图中心的经纬度\nmapcontext.getregion             获取当前地图的视野范围\nmapcontext.getrotate             获取当前地图的旋转角\nmapcontext.getscale              获取当前地图的缩放级别\nmapcontext.getskew               获取当前地图的倾斜角\nmapcontext.includepoints         缩放视野展示所有经纬度\nmapcontext.initmarkercluster     初始化点聚合的配置，未调用时采用默认配置\nmapcontext.movealong             沿指定路径移动 marker，用于轨迹回放等场景\nmapcontext.movetolocation        将地图中心移置当前定位点，此时需设置地图组件 show-location 为true\nmapcontext.on                    监听地图事件\nmapcontext.openmapapp            拉起地图app选择导航\nmapcontext.removecustomlayer     移除个性化图层\nmapcontext.removegroundoverlay   移除自定义图片图层\nmapcontext.removemarkers         移除 marker\nmapcontext.setcenteroffset       设置地图中心点偏移，向后向下为增长，屏幕比例范围(0.25~0.75)，默认偏移为[0.5, 0.5]\nmapcontext.setlocmarkericon      设置定位点图标，支持网络路径、本地路径、代码包路径\nmapcontext.toscreenlocation      获取经纬度对应的屏幕坐标，坐标原点为地图左上角\nmapcontext.translatemarker       平移marker，带动画\nmapcontext.updategroundoverlay   更新自定义图片图层\n\n\n# 图片\n\n名称                          功能说明\nwx.saveimagetophotosalbum   保存图片到系统相册\nwx.previewmedia             预览图片和视频\nwx.previewimage             在新页面中全屏预览图片\nwx.getimageinfo             获取图片信息\nwx.compressimage            压缩图片接口，可选压缩质量\nwx.choosemessagefile        从客户端会话选择文件\nwx.chooseimage              从本地相册选择图片或使用相机拍照\n\n\n# 视频\n\n名称                          功能说明\nwx.savevideotophotosalbum   保存视频到系统相册\nwx.openvideoeditor          打开视频编辑器\nwx.getvideoinfo             获取视频详细信息\nwx.createvideocontext       创建 video 上下文 videocontext 对象\nwx.compressvideo            压缩视频接口\nwx.choosevideo              拍摄视频或从手机相册中选视频\nwx.choosemedia              拍摄或从手机相册中选择图片或视频\n\n# videocontext\n\n名称                                       功能说明\nvideocontext.exitbackgroundplayback      退出后台音频播放模式\nvideocontext.exitfullscreen              退出全屏\nvideocontext.exitpictureinpicture        退出小窗，该方法可在任意页面调用\nvideocontext.hidestatusbar               隐藏状态栏，仅在ios全屏下有效\nvideocontext.pause                       暂停视频\nvideocontext.play                        播放视频\nvideocontext.playbackrate                设置倍速播放\nvideocontext.requestbackgroundplayback   进入后台音频播放模式\nvideocontext.requestfullscreen           进入全屏\nvideocontext.seek                        跳转到指定位置\nvideocontext.senddanmu                   发送弹幕\nvideocontext.showstatusbar               显示状态栏，仅在ios全屏下有效\nvideocontext.stop                        停止视频\n\n\n# 音频\n\n名称                            功能说明\nwx.stopvoice                  结束播放语音\nwx.setinneraudiooption        设置 inneraudiocontext 的播放选项\nwx.playvoice                  开始播放语音\nwx.pausevoice                 暂停正在播放的语音\nwx.getavailableaudiosources   获取当前支持的音频输入源\nwx.createwebaudiocontext      创建 webaudio 上下文\nwx.createmediaaudioplayer     创建媒体音频播放器对象 mediaaudioplayer 对象，可用于播放视频解码器 videodecoder\n                              输出的音频\nwx.createinneraudiocontext    创建内部 audio 上下文 inneraudiocontext 对象\nwx.createaudiocontext         创建 audio 上下文 audiocontext 对象\n\n# audiobuffer\n\n名称                            功能说明\naudiobuffer.copyfromchannel   从audiobuffer的指定频道复制到数组终端\naudiobuffer.copytochannel     从指定数组复制样本到audiobuffer的特定通道\naudiobuffer.getchanneldata    返回一个 float32array，包含了带有频道的pcm数据，由频道参数定义（有0代表第一个频道）\n\n# audiocontext\n\n名称                    功能说明\naudiocontext.pause    暂停音频\naudiocontext.play     播放音频\naudiocontext.seek     跳转到指定位置\naudiocontext.setsrc   设置音频地址\n\n# inneraudiocontext\n\n名称                                功能说明\ninneraudiocontext.destroy         销毁当前实例\ninneraudiocontext.offcanplay      取消监听音频进入可以播放状态的事件\ninneraudiocontext.offended        取消监听音频自然播放至结束的事件\ninneraudiocontext.offerror        取消监听音频播放错误事件\ninneraudiocontext.offpause        取消监听音频暂停事件\ninneraudiocontext.offplay         取消监听音频播放事件\ninneraudiocontext.offseeked       取消监听音频完成跳转操作的事件\ninneraudiocontext.offseeking      取消监听音频进行跳转操作的事件\ninneraudiocontext.offstop         取消监听音频停止事件\ninneraudiocontext.offtimeupdate   取消监听音频播放进度更新事件\ninneraudiocontext.offwaiting      取消监听音频加载中事件\ninneraudiocontext.oncanplay       监听音频进入可以播放状态的事件\ninneraudiocontext.onended         监听音频自然播放至结束的事件\ninneraudiocontext.onerror         监听音频播放错误事件\ninneraudiocontext.onpause         监听音频暂停事件\ninneraudiocontext.onplay          监听音频播放事件\ninneraudiocontext.onseeked        监听音频完成跳转操作的事件\ninneraudiocontext.onseeking       监听音频进行跳转操作的事件\ninneraudiocontext.onstop          监听音频停止事件\ninneraudiocontext.ontimeupdate    监听音频播放进度更新事件\ninneraudiocontext.onwaiting       监听音频加载中事件\ninneraudiocontext.pause           暂停\ninneraudiocontext.play            播放\ninneraudiocontext.seek            跳转到指定位置\ninneraudiocontext.stop            停止\n\n# mediaaudioplayer\n\n名称                                   功能说明\nmediaaudioplayer.addaudiosource      添加音频源\nmediaaudioplayer.destroy             销毁播放器\nmediaaudioplayer.removeaudiosource   移除音频源\nmediaaudioplayer.start               启动播放器\nmediaaudioplayer.stop                停止播放器\n\n# webaudiocontext\n\n名称                                         功能说明\nwebaudiocontext.close                      关闭webaudiocontext\nwebaudiocontext.createbiquadfilter         创建一个biquadfilternode\nwebaudiocontext.createbuffer               创建一个audiobuffer，代表着一段驻留在内存中的短音频\nwebaudiocontext.createbuffersource         创建一个buffersourcenode实例，通过audiobuffer对象来播放音频数据\nwebaudiocontext.createchannelmerger        创建一个channelmergernode\nwebaudiocontext.createchannelsplitter      创建一个channelsplitternode\nwebaudiocontext.createconstantsource       创建一个constantsourcenode\nwebaudiocontext.createdelay                创建一个delaynode\nwebaudiocontext.createdynamicscompressor   创建一个dynamicscompressornode\nwebaudiocontext.creategain                 创建一个gainnode\nwebaudiocontext.createiirfilter            创建一个iirfilternode\nwebaudiocontext.createoscillator           创建一个oscillatornode\nwebaudiocontext.createpanner               创建一个pannernode\nwebaudiocontext.createperiodicwave         创建一个periodicwavenode\nwebaudiocontext.createscriptprocessor      创建一个scriptprocessornode\nwebaudiocontext.createwaveshaper           创建一个waveshapernode\nwebaudiocontext.decodeaudiodata            异步解码一段资源为audiobuffer\nwebaudiocontext.resume                     同步恢复已经被暂停的webaudiocontext上下文\nwebaudiocontext.suspend                    同步暂停webaudiocontext上下文\nwebaudiocontextnode                        一类音频处理模块，不同的node具备不同的功能，如gainnode(音量调整)等\n\n\n# 背景音频\n\n名称                                 功能说明\nwx.stopbackgroundaudio             停止播放音乐\nwx.seekbackgroundaudio             控制音乐播放进度\nwx.playbackgroundaudio             使用后台播放器播放音乐\nwx.pausebackgroundaudio            暂停播放音乐\nwx.onbackgroundaudiostop           监听音乐停止事件\nwx.onbackgroundaudioplay           监听音乐播放事件\nwx.onbackgroundaudiopause          监听音乐暂停事件\nwx.getbackgroundaudioplayerstate   获取后台音乐播放状态\nwx.getbackgroundaudiomanager       获取全局唯一的背景音频管理器\n\n# backgroundaudiomanager\n\n名称                                    功能说明\nbackgroundaudiomanager.oncanplay      监听背景音频进入可播放状态事件\nbackgroundaudiomanager.onended        监听背景音频自然播放结束事件\nbackgroundaudiomanager.onerror        监听背景音频播放错误事件\nbackgroundaudiomanager.onnext         监听用户在系统音乐播放面板点击下一曲事件（仅ios）\nbackgroundaudiomanager.onpause        监听背景音频暂停事件\nbackgroundaudiomanager.onplay         监听背景音频播放事件\nbackgroundaudiomanager.onprev         监听用户在系统音乐播放面板点击上一曲事件（仅ios）\nbackgroundaudiomanager.onseeked       监听背景音频完成跳转操作事件\nbackgroundaudiomanager.onseeking      监听背景音频开始跳转操作事件\nbackgroundaudiomanager.onstop         监听背景音频停止事件\nbackgroundaudiomanager.ontimeupdate   监听背景音频播放进度更新事件，只有小程序在前台时会回调\nbackgroundaudiomanager.onwaiting      监听音频加载中事件\nbackgroundaudiomanager.pause          暂停音乐\nbackgroundaudiomanager.play           播放音乐\nbackgroundaudiomanager.seek           跳转到指定位置\nbackgroundaudiomanager.stop           停止音乐\n\n\n# 实时音视频\n\n名称                           功能说明\nwx.createlivepushercontext   创建 live-pusher 上下文 livepushercontext 对象\nwx.createliveplayercontext   创建 live-player 上下文 liveplayercontext 对象\n\n# liveplayercontext\n\n名称                                          功能说明\nliveplayercontext.exitfullscreen            退出全屏\nliveplayercontext.exitpictureinpicture      退出小窗，该方法可在任意页面调用\nliveplayercontext.mute                      静音\nliveplayercontext.pause                     暂停\nliveplayercontext.play                      播放\nliveplayercontext.requestfullscreen         进入全屏\nliveplayercontext.requestpictureinpicture   进入小窗\nliveplayercontext.resume                    恢复\nliveplayercontext.snapshot                  截图\nliveplayercontext.stop                      停止\n\n# livepushercontext\n\n名称                               功能说明\nlivepushercontext.pause          暂停推流\nlivepushercontext.pausebgm       暂停背景音\nlivepushercontext.playbgm        播放背景音\nlivepushercontext.resume         恢复推流\nlivepushercontext.resumebgm      恢复背景音\nlivepushercontext.sendmessage    发送sei消息\nlivepushercontext.setbgmvolume   设置背景音音量\nlivepushercontext.setmicvolume   设置麦克风音量\nlivepushercontext.snapshot       快照\nlivepushercontext.start          开始推流，同时开启摄像头预览\nlivepushercontext.startpreview   开启摄像头预览\nlivepushercontext.stop           停止推流，同时停止摄像头预览\nlivepushercontext.stopbgm        停止背景音\nlivepushercontext.stoppreview    关闭摄像头预览\nlivepushercontext.switchcamera   切换前后摄像头\nlivepushercontext.toggletorch    切换手电筒\n\n\n# 录音\n\n名称                      功能说明\nwx.stoprecord           停止录音\nwx.startrecord          开始录音\nwx.getrecordermanager   获取全局唯一的录音管理器 recordermanager\n\n# recordermanager\n\n名称                                    功能说明\nrecordermanager.onerror               监听录音错误事件\nrecordermanager.onframerecorded       监听已录制完指定帧大小的文件事件\nrecordermanager.oninterruptionbegin   监听录音因为受到系统占用而被中断开始事件\nrecordermanager.oninterruptionend     监听录音中断结束事件\nrecordermanager.onpause               监听录音暂停事件\nrecordermanager.onresume              监听录音继续事件\nrecordermanager.onstart               监听录音开始事件\nrecordermanager.onstop                监听录音结束事件\nrecordermanager.pause                 暂停录音\nrecordermanager.resume                继续录音\nrecordermanager.start                 开始录音\nrecordermanager.stop                  停止录音\n\n\n# 相机\n\n名称                       功能说明\nwx.createcameracontext   创建 camera 上下文 cameracontext 对象\n\n# cameracontext\n\n名称                            功能说明\ncameracontext.oncameraframe   获取 camera 实时帧数据\ncameracontext.setzoom         设置缩放级别\ncameracontext.startrecord     开始录像\ncameracontext.stoprecord      结束录像\ncameracontext.takephoto       拍摄照片\n\n# cameraframelistener\n\n名称                          功能说明\ncameraframelistener.start   开始监听帧数据\ncameraframelistener.stop    停止监听帧数据\n\n\n# 富文本\n\n名称   功能说明\n     \n\n# editorcontext\n\n名称                               功能说明\neditorcontext.blur               编辑器失焦，同时收起键盘\neditorcontext.clear              清空编辑器内容\neditorcontext.format             修改样式\neditorcontext.getcontents        获取编辑器内容\neditorcontext.getselectiontext   获取编辑器已选区域内的纯文本内容\neditorcontext.insertdivider      插入分割线\neditorcontext.insertimage        插入图片\neditorcontext.inserttext         覆盖当前选区，设置一段文本\neditorcontext.redo               恢复\neditorcontext.removeformat       清除当前选区的样式\neditorcontext.scrollintoview     使得编辑器光标处滚动到窗口可视区域内\neditorcontext.setcontents        初始化编辑器内容，html和delta同时存在时仅delta生效\neditorcontext.undo               撤销\n\n\n# 音视频合成\n\n名称                        功能说明\nwx.createmediacontainer   创建音视频处理容器，最终可将容器中的轨道合成一个视频\n\n# mediacontainer\n\n名称                                 功能说明\nmediacontainer.addtrack            将音频或视频轨道添加到容器\nmediacontainer.destroy             将容器销毁，释放资源\nmediacontainer.export              将容器内的轨道合并并导出视频文件\nmediacontainer.extractdatasource   将传入的视频源分离轨道\nmediacontainer.removetrack         将音频或视频轨道从容器中移除\nmediatrack                         可通过 mediacontainer.extractdatasource 返回\n\n\n# 实时语音\n\n名称                              功能说明\nwx.updatevoipchatmuteconfig     更新实时语音静音设置\nwx.subscribevoipvideomembers    订阅视频画面成员\nwx.onvoipvideomemberschanged    监听实时语音通话成员视频状态变化事件\nwx.onvoipchatstatechanged       监听房间状态变化事件\nwx.onvoipchatspeakerschanged    监听实时语音通话成员通话状态变化事件\nwx.onvoipchatmemberschanged     监听实时语音通话成员在线状态变化事件\nwx.onvoipchatinterrupted        监听被动断开实时语音通话事件\nwx.offvoipvideomemberschanged   取消监听实时语音通话成员视频状态变化事件\nwx.offvoipchatstatechanged      取消监听房间状态变化事件\nwx.offvoipchatmemberschanged    取消监听实时语音通话成员在线状态变化事件\nwx.offvoipchatinterrupted       取消监听被动断开实时语音通话事件\nwx.joinvoipchat                 加入 (创建) 实时语音通话，更多信息可见 实时语音指南\nwx.exitvoipchat                 退出（销毁）实时语音通话\n\n\n# 画面录制器\n\n名称                       功能说明\nwx.createmediarecorder   创建 webgl 画面录制器，可逐帧录制在 webgl 上渲染的画面并导出视频文件\n\n# mediarecorder\n\n名称                           功能说明\nmediarecorder.destroy        销毁录制器\nmediarecorder.off            取消监听录制事件\nmediarecorder.on             注册监听录制事件的回调函数\nmediarecorder.pause          暂停录制\nmediarecorder.requestframe   请求下一帧录制，在 callback 里完成一帧渲染后开始录制当前帧\nmediarecorder.resume         恢复录制\nmediarecorder.start          开始录制\nmediarecorder.stop           结束录制\n\n\n# 视频解码器\n\n名称                      功能说明\nwx.createvideodecoder   创建视频解码器，可逐帧获取解码后的数据\n\n# videodecoder\n\n名称                          功能说明\nvideodecoder.getframedata   获取下一帧的解码数据\nvideodecoder.off            取消监听录制事件\nvideodecoder.on             注册监听录制事件的回调函数\nvideodecoder.remove         移除解码器\nvideodecoder.seek           跳到某个时间点解码\nvideodecoder.start          开始解码\nvideodecoder.stop           停止解码\n\n\n# 位置\n\n名称                                 功能说明\nwx.stoplocationupdate              关闭监听实时位置变化，前后台都停止消息接收\nwx.startlocationupdatebackground   开启小程序进入前后台时均接收位置消息，需引导用户开启授权\nwx.startlocationupdate             开启小程序进入前台时接收位置消息\nwx.openlocation                    使用微信内置地图查看位置\nwx.onlocationchange                监听实时地理位置变化事件，需结合\n                                   wx.startlocationupdatebackground、wx.startlocationupdate使用\nwx.offlocationchange               取消监听实时地理位置变化事件\nwx.getlocation                     获取当前的地理位置、速度\nwx.choosepoi                       打开地图选择位置，支持模糊定位（精确到市）和精确定位混选\nwx.chooselocation                  打开地图选择位置\n\n\n# 文件\n\n名称                        功能说明\nwx.savefiletodisk         保存文件系统的文件到用户磁盘，仅在 pc 端支持\nwx.savefile               保存文件到本地\nwx.removesavedfile        删除本地缓存文件\nwx.opendocument           新开页面打开文档\nwx.getsavedfilelist       获取该小程序下已保存的本地缓存文件列表\nwx.getsavedfileinfo       获取本地文件的文件信息\nwx.getfilesystemmanager   获取全局唯一的文件管理器\nwx.getfileinfo            获取文件信息\n\n\n# filesystemmanager\n\n名称                                   功能说明\nfilesystemmanager.access             判断文件/目录是否存在\nfilesystemmanager.accesssync         filesystemmanager.access 的同步版本\nfilesystemmanager.appendfile         在文件结尾追加内容\nfilesystemmanager.appendfilesync     filesystemmanager.appendfile 的同步版本\nfilesystemmanager.close              关闭文件\nfilesystemmanager.closesync          同步关闭文件\nfilesystemmanager.copyfile           复制文件\nfilesystemmanager.copyfilesync       filesystemmanager.copyfile 的同步版本\nfilesystemmanager.fstat              获取文件的状态信息\nfilesystemmanager.fstatsync          同步获取文件的状态信息\nfilesystemmanager.ftruncate          对文件内容进行截断操作\nfilesystemmanager.ftruncatesync      对文件内容进行截断操作\nfilesystemmanager.getfileinfo        获取该小程序下的 本地临时文件 或 本地缓存文件 信息\nfilesystemmanager.getsavedfilelist   获取该小程序下已保存的本地缓存文件列表\nfilesystemmanager.mkdir              创建目录\nfilesystemmanager.mkdirsync          filesystemmanager.mkdir 的同步版本\nfilesystemmanager.open               打开文件，返回文件描述符\nfilesystemmanager.opensync           同步打开文件，返回文件描述符\nfilesystemmanager.read               读文件\nfilesystemmanager.readdir            读取目录内文件列表\nfilesystemmanager.readdirsync        filesystemmanager.readdir 的同步版本\nfilesystemmanager.readfile           读取本地文件内容\nfilesystemmanager.readfilesync       filesystemmanager.readfile 的同步版本\nfilesystemmanager.readsync           读文件\nfilesystemmanager.readzipentry       读取压缩包内的文件\nfilesystemmanager.removesavedfile    删除该小程序下已保存的本地缓存文件\nfilesystemmanager.rename             重命名文件\nfilesystemmanager.renamesync         filesystemmanager.rename 的同步版本\nfilesystemmanager.rmdir              删除目录\nfilesystemmanager.rmdirsync          filesystemmanager.rmdir 的同步版本\nfilesystemmanager.savefile           保存临时文件到本地\nfilesystemmanager.savefilesync       filesystemmanager.savefile 的同步版本\nfilesystemmanager.stat               获取文件 stats 对象\nfilesystemmanager.statsync           filesystemmanager.stat 的同步版本\nfilesystemmanager.truncate           对文件内容进行截断操作\nfilesystemmanager.truncatesync       对文件内容进行截断操作 (truncate 的同步版本)\nfilesystemmanager.unlink             删除文件\nfilesystemmanager.unlinksync         filesystemmanager.unlink 的同步版本\nfilesystemmanager.unzip              解压文件\nfilesystemmanager.write              写入文件\nfilesystemmanager.writefile          写文件\nfilesystemmanager.writefilesync      filesystemmanager.writefile 的同步版本\nfilesystemmanager.writesync          同步写入文件\nreadresult                           文件读取结果\n\n\n# stats\n\n名称                  功能说明\nstats.isdirectory   判断当前文件是否一个目录\nstats.isfile        判断当前文件是否一个普通文件\nwriteresult         文件写入结果\n\n\n# 开放接口\n\n\n# 登录\n\n名称                功能说明\nwx.login          调用接口获取登录凭证（code）\nwx.checksession   检查登录态是否过期\n\n\n# 帐号信息\n\n名称                      功能说明\nwx.getaccountinfosync   获取当前帐号信息\n\n\n# 用户信息\n\n名称                  功能说明\nwx.getuserprofile   获取用户信息\nwx.getuserinfo      获取用户信息\nuserinfo            用户信息\n\n\n# 授权\n\n名称                           功能说明\nwx.authorizeforminiprogram   仅小程序插件中能调用该接口，用法同 wx.authorize\nwx.authorize                 提前向用户发起授权请求\n\n\n# 设置\n\n名称                     功能说明\nwx.opensetting         调起客户端小程序设置界面，返回用户设置的操作结果\nwx.getsetting          获取用户的当前设置\nauthsetting            用户授权设置信息，详情参考权限\nsubscriptionssetting   订阅消息设置\n\n\n# 收货地址\n\n名称                 功能说明\nwx.chooseaddress   获取用户收货地址\n\n\n# 卡券\n\n名称            功能说明\nwx.opencard   查看微信卡包中的卡券\nwx.addcard    批量添加卡券\n\n\n# 发票\n\n名称                      功能说明\nwx.chooseinvoicetitle   选择用户的发票抬头\nwx.chooseinvoice        选择用户已有的发票\n\n\n# 生物认证\n\n名称                                     功能说明\nwx.startsoterauthentication            开始 soter 生物认证\nwx.checkissupportsoterauthentication   获取本机支持的 soter 生物认证方式\nwx.checkissoterenrolledindevice        获取设备内是否录入如指纹等生物信息的接口\n\n\n# 微信运动\n\n名称                功能说明\nwx.sharetowerun   分享数据到微信运动\nwx.getwerundata   获取用户过去三十天微信运动步数\n\n\n# 订阅消息\n\n名称                           功能说明\nwx.requestsubscribemessage   调起客户端小程序订阅消息界面，返回用户订阅消息的操作结果\n\n\n# 微信红包\n\n名称                  功能说明\nwx.showredpackage   拉取h5领取红包封面页\n\n\n# 收藏\n\n名称                       功能说明\nwx.addvideotofavorites   收藏视频\nwx.addfiletofavorites    收藏文件\n\n\n# 车牌\n\n名称                      功能说明\nwx.chooselicenseplate   选择车牌号\n\n\n# 视频号\n\n名称                             功能说明\nwx.reservechannelslive         预约视频号直播\nwx.openchannelslive            打开视频号直播\nwx.openchannelsactivity        打开视频号视频\nwx.getchannelslivenoticeinfo   获取视频号直播预告信息\nwx.getchannelsliveinfo         获取视频号直播信息\n\n\n# 微信群\n\n名称                     功能说明\nwx.getgroupenterinfo   获取微信群聊场景下的小程序启动信息\n\n\n# 微信客服\n\n名称                           功能说明\nwx.opencustomerservicechat   打开微信客服\n\n\n# 设备\n\n\n# 蓝牙-通用\n\n名称                                  功能说明\nwx.stopbluetoothdevicesdiscovery    停止搜寻附近的蓝牙外围设备\nwx.startbluetoothdevicesdiscovery   开始搜寻附近的蓝牙外围设备\nwx.openbluetoothadapter             初始化蓝牙模块\nwx.onbluetoothdevicefound           监听搜索到新设备的事件\nwx.onbluetoothadapterstatechange    监听蓝牙适配器状态变化事件\nwx.offbluetoothdevicefound          取消监听寻找到新设备的事件\nwx.offbluetoothadapterstatechange   取消监听蓝牙适配器状态变化事件\nwx.makebluetoothpair                蓝牙配对接口，仅安卓支持\nwx.getconnectedbluetoothdevices     根据主服务 uuid 获取已连接的蓝牙设备\nwx.getbluetoothdevices              获取在蓝牙模块生效期间所有搜索到的蓝牙设备\nwx.getbluetoothadapterstate         获取本机蓝牙适配器状态\nwx.closebluetoothadapter            关闭蓝牙模块\n\n\n# 蓝牙-低功耗中心设备\n\n名称                                      功能说明\nwx.writeblecharacteristicvalue          向蓝牙低功耗设备特征值中写入二进制数据\nwx.setblemtu                            协商设置蓝牙低功耗的最大传输单元 (maximum transmission unit, mtu)\nwx.readblecharacteristicvalue           读取蓝牙低功耗设备特征值的二进制数据\nwx.onbleconnectionstatechange           监听蓝牙低功耗连接状态的改变事件\nwx.onblecharacteristicvaluechange       监听蓝牙低功耗设备的特征值变化事件\nwx.offbleconnectionstatechange          取消监听蓝牙低功耗连接状态的改变事件\nwx.offblecharacteristicvaluechange      取消监听蓝牙低功耗设备的特征值变化事件\nwx.notifyblecharacteristicvaluechange   启用蓝牙低功耗设备特征值变化时的 notify 功能，订阅特征\nwx.getbledeviceservices                 获取蓝牙低功耗设备所有服务 (service)\nwx.getbledevicerssi                     获取蓝牙低功耗设备的信号强度 (received signal strength indication, rssi)\nwx.getbledevicecharacteristics          获取蓝牙低功耗设备某个服务中所有特征 (characteristic)\nwx.createbleconnection                  连接蓝牙低功耗设备\nwx.closebleconnection                   断开与蓝牙低功耗设备的连接\n\n\n# 蓝牙-低功耗外围设备\n\n名称                                          功能说明\nwx.onbleperipheralconnectionstatechanged    监听当前外围设备被连接或断开连接事件\nwx.offbleperipheralconnectionstatechanged   取消监听当前外围设备被连接或断开连接事件\nwx.createbleperipheralserver                建立本地作为蓝牙低功耗外围设备的服务端，可创建多个\n\n# bleperipheralserver\n\n名称                                                  功能说明\nbleperipheralserver.addservice                      添加服务\nbleperipheralserver.close                           关闭当前服务端\nbleperipheralserver.offcharacteristicreadrequest    取消监听已连接的设备请求读当前外围设备的特征值事件\nbleperipheralserver.offcharacteristicsubscribed     取消监听特征订阅事件\nbleperipheralserver.offcharacteristicunsubscribed   取消监听取消特征订阅事件\nbleperipheralserver.offcharacteristicwriterequest   取消监听已连接的设备请求写当前外围设备的特征值事件\nbleperipheralserver.oncharacteristicreadrequest     监听已连接的设备请求读当前外围设备的特征值事件\nbleperipheralserver.oncharacteristicsubscribed      监听特征订阅事件，仅 ios 支持\nbleperipheralserver.oncharacteristicunsubscribed    监听取消特征订阅事件，仅 ios 支持\nbleperipheralserver.oncharacteristicwriterequest    监听已连接的设备请求写当前外围设备的特征值事件\nbleperipheralserver.removeservice                   移除服务\nbleperipheralserver.startadvertising                开始广播本地创建的外围设备\nbleperipheralserver.stopadvertising                 停止广播\nbleperipheralserver.writecharacteristicvalue        往指定特征写入二进制数据值，并通知已连接的主机，从机的特征值已发生变化，该接口会处理是走回包还是走订阅\n\n\n# 蓝牙-信标(beacon)\n\n名称                          功能说明\nwx.stopbeacondiscovery      停止搜索附近的 beacon 设备\nwx.startbeacondiscovery     开始搜索附近的 beacon 设备\nwx.onbeaconupdate           监听 beacon 设备更新事件，仅能注册一个监听\nwx.onbeaconservicechange    监听 beacon 服务状态变化事件，仅能注册一个监听\nwx.offbeaconupdate          取消监听 beacon 设备更新事件\nwx.offbeaconservicechange   取消监听 beacon 服务状态变化事件\nwx.getbeacons               获取所有已搜索到的 beacon 设备\nbeaconinfo                  beacon 设备\n\n\n# nfc\n\n名称                  功能说明\nwx.stophce          关闭 nfc 模块\nwx.starthce         初始化 nfc 模块\nwx.sendhcemessage   发送 nfc 消息\nwx.onhcemessage     监听接收 nfc 设备消息事件，仅能注册一个监听\nwx.offhcemessage    接收 nfc 设备消息事件，取消事件监听\nwx.getnfcadapter    获取 nfc 实例\nwx.gethcestate      判断当前设备是否支持 hce 能力\n\n# isodep\n\n名称                              功能说明\nisodep.close                    断开连接\nisodep.connect                  连接 nfc 标签\nisodep.gethistoricalbytes       获取复位信息\nisodep.getmaxtransceivelength   获取最大传输长度\nisodep.isconnected              检查是否已连接\nisodep.settimeout               设置超时时间\nisodep.transceive               发送数据\n\n# mifareclassic\n\n名称                                     功能说明\nmifareclassic.close                    断开连接\nmifareclassic.connect                  连接 nfc 标签\nmifareclassic.getmaxtransceivelength   获取最大传输长度\nmifareclassic.isconnected              检查是否已连接\nmifareclassic.settimeout               设置超时时间\nmifareclassic.transceive               发送数据\n\n# mifareultralight\n\n名称                                        功能说明\nmifareultralight.close                    断开连接\nmifareultralight.connect                  连接 nfc 标签\nmifareultralight.getmaxtransceivelength   获取最大传输长度\nmifareultralight.isconnected              检查是否已连接\nmifareultralight.settimeout               设置超时时间\nmifareultralight.transceive               发送数据\n\n# ndef\n\n名称                      功能说明\nndef.close              断开连接\nndef.connect            连接 nfc 标签\nndef.isconnected        检查是否已连接\nndef.offndefmessage     取消监听 ndef 消息\nndef.onndefmessage      监听 ndef 消息\nndef.settimeout         设置超时时间\nndef.writendefmessage   重写 ndef 标签内容\n\n# nfca\n\n名称                            功能说明\nnfca.close                    断开连接\nnfca.connect                  连接 nfc 标签\nnfca.getatqa                  获取atqa信息\nnfca.getmaxtransceivelength   获取最大传输长度\nnfca.getsak                   获取sak信息\nnfca.isconnected              检查是否已连接\nnfca.settimeout               设置超时时间\nnfca.transceive               发送数据\n\n# nfcadapter\n\n名称                               功能说明\nnfcadapter.getisodep             获取isodep实例，实例支持iso-dep (iso 14443-4)标准的读写\nnfcadapter.getmifareclassic      获取mifareclassic实例，实例支持mifare classic标签的读写\nnfcadapter.getmifareultralight   获取mifareultralight实例，实例支持mifare ultralight标签的读写\nnfcadapter.getndef               获取ndef实例，实例支持对ndef格式的nfc标签上的ndef数据的读写\nnfcadapter.getnfca               获取nfca实例，实例支持nfc-a (iso 14443-3a)标准的读写\nnfcadapter.getnfcb               获取nfcb实例，实例支持nfc-b (iso 14443-3b)标准的读写\nnfcadapter.getnfcf               获取nfcf实例，实例支持nfc-f (jis 6319-4)标准的读写\nnfcadapter.getnfcv               获取nfcv实例，实例支持nfc-v (iso 15693)标准的读写\nnfcadapter.offdiscovered         取消监听 nfc tag\nnfcadapter.ondiscovered          监听 nfc tag\nnfcadapter.startdiscovery        \nnfcadapter.stopdiscovery         \n\n# nfcb\n\n名称                            功能说明\nnfcb.close                    断开连接\nnfcb.connect                  连接 nfc 标签\nnfcb.getmaxtransceivelength   获取最大传输长度\nnfcb.isconnected              检查是否已连接\nnfcb.settimeout               设置超时时间\nnfcb.transceive               发送数据\n\n# nfcf\n\n名称                            功能说明\nnfcf.close                    断开连接\nnfcf.connect                  连接 nfc 标签\nnfcf.getmaxtransceivelength   获取最大传输长度\nnfcf.isconnected              检查是否已连接\nnfcf.settimeout               设置超时时间\nnfcf.transceive               发送数据\n\n# nfcv\n\n名称                            功能说明\nnfcv.close                    断开连接\nnfcv.connect                  连接 nfc 标签\nnfcv.getmaxtransceivelength   获取最大传输长度\nnfcv.isconnected              检查是否已连接\nnfcv.settimeout               设置超时时间\nnfcv.transceive               发送数据\n\n\n# wi-fi\n\n名称                    功能说明\nwx.stopwifi           关闭 wi-fi 模块\nwx.startwifi          初始化 wi-fi 模块\nwx.setwifilist        设置 wifilist 中 ap 的相关信息\nwx.onwificonnected    监听连接上 wi-fi 的事件\nwx.ongetwifilist      监听获取到 wi-fi 列表数据事件\nwx.offwificonnected   取消监听连接上 wi-fi 的事件\nwx.offgetwifilist     取消监听获取到 wi-fi 列表数据事件\nwx.getwifilist        请求获取 wi-fi 列表\nwx.getconnectedwifi   获取已连接中的 wi-fi 信息\nwx.connectwifi        连接 wi-fi\nwifiinfo              wifi 信息\n\n\n# 日历\n\n名称                          功能说明\nwx.addphonerepeatcalendar   向系统日历添加重复事件\nwx.addphonecalendar         向系统日历添加事件\n\n\n# 联系人\n\n名称                   功能说明\nwx.searchcontacts    查找通讯录，匹配相近的手机号\nwx.choosecontact     拉起手机通讯录，选择联系人\nwx.addphonecontact   添加手机通讯录联系人\n\n\n# 无障碍\n\n名称                            功能说明\nwx.checkisopenaccessibility   检测是否开启视觉无障碍功能\n\n\n# 电量\n\n名称                      功能说明\nwx.getbatteryinfosync   wx.getbatteryinfo 的同步版本\nwx.getbatteryinfo       获取设备电量\n\n\n# 剪贴板\n\n名称                    功能说明\nwx.setclipboarddata   设置系统剪贴板的内容\nwx.getclipboarddata   获取系统剪贴板的内容\n\n\n# 网络\n\n名称                          功能说明\nwx.onnetworkstatuschange    监听网络状态变化事件\nwx.offnetworkstatuschange   取消监听网络状态变化事件，参数为空，则取消所有的事件监听\nwx.getnetworktype           获取网络类型\n\n\n# 加密\n\n名称                   功能说明\nwx.getrandomvalues   获取密码学安全随机数\n\n\n# 屏幕\n\n名称                        功能说明\nwx.setscreenbrightness    设置屏幕亮度\nwx.setkeepscreenon        设置是否保持常亮状态\nwx.onusercapturescreen    监听用户主动截屏事件\nwx.offusercapturescreen   用户主动截屏事件\nwx.getscreenbrightness    获取屏幕亮度\n\n\n# 键盘\n\n名称                           功能说明\nwx.onkeyboardheightchange    监听键盘高度变化\nwx.offkeyboardheightchange   取消监听键盘高度变化事件\nwx.hidekeyboard              在input、textarea等focus拉起键盘之后，手动调用此接口收起键盘\nwx.getselectedtextrange      在input、textarea等focus之后，获取输入框的光标位置\n\n\n# 电话\n\n名称                 功能说明\nwx.makephonecall   拨打电话\n\n\n# 加速计\n\n名称                          功能说明\nwx.stopaccelerometer        停止监听加速度数据\nwx.startaccelerometer       开始监听加速度数据\nwx.onaccelerometerchange    监听加速度数据事件\nwx.offaccelerometerchange   取消监听加速度数据事件，参数为空，则取消所有的事件监听\n\n\n# 罗盘\n\n名称                    功能说明\nwx.stopcompass        停止监听罗盘数据\nwx.startcompass       开始监听罗盘数据\nwx.oncompasschange    监听罗盘数据变化事件\nwx.offcompasschange   取消监听罗盘数据变化事件，参数为空，则取消所有的事件监听\n\n\n# 设备方向\n\n名称                              功能说明\nwx.stopdevicemotionlistening    停止监听设备方向的变化\nwx.startdevicemotionlistening   开始监听设备方向的变化\nwx.ondevicemotionchange         监听设备方向变化事件\nwx.offdevicemotionchange        取消监听设备方向变化事件，参数为空，则取消所有的事件监听\n\n\n# 陀螺仪\n\n名称                      功能说明\nwx.stopgyroscope        停止监听陀螺仪数据\nwx.startgyroscope       开始监听陀螺仪数据\nwx.ongyroscopechange    监听陀螺仪数据变化事件\nwx.offgyroscopechange   取消监听陀螺仪数据变化事件\n\n\n# 内存\n\n名称                    功能说明\nwx.onmemorywarning    监听内存不足告警事件\nwx.offmemorywarning   取消监听内存不足告警事件\n\n\n# 扫码\n\n名称            功能说明\nwx.scancode   调起客户端扫码界面进行扫码\n\n\n# 振动\n\n名称                功能说明\nwx.vibrateshort   使手机发生较短时间的振动（15 ms）\nwx.vibratelong    使手机发生较长时间的振动（400 ms)\n\n\n# ai\n\n\n# 人脸识别\n\n名称                  功能说明\nwx.stopfacedetect   停止人脸识别\nwx.initfacedetect   初始化人脸识别\nwx.facedetect       人脸识别，使用前需要通过 wx.initfacedetect 进行一次初始化，推荐使用相机接口返回的帧数据\n\n\n# worker\n\n名称                功能说明\nwx.createworker   创建一个 worker 线程\n\n\n# worker\n\n名称                       功能说明\nworker.onmessage         监听主线程/worker 线程向当前线程发送的消息的事件\nworker.onprocesskilled   监听\n                         worker线程被系统回收事件（当ios系统资源紧张时，worker线程存在被系统回收的可能，开发者可监听此事件并重新创建一个worker）\nworker.postmessage       向主线程/worker 线程发送的消息\nworker.terminate         结束当前 worker 线程\n\n\n# wxml\n\n名称                              功能说明\nwx.createselectorquery          返回一个 selectorquery 对象实例\nwx.createintersectionobserver   创建并返回一个 intersectionobserver 对象实例\n\n\n# intersectionobserver\n\n名称                                        功能说明\nintersectionobserver.disconnect           停止监听\nintersectionobserver.observe              指定目标节点并开始监听相交状态变化情况\nintersectionobserver.relativeto           使用选择器指定一个节点，作为参照区域之一\nintersectionobserver.relativetoviewport   指定页面显示区域作为参照区域之一\n\n\n# mediaqueryobserver\n\n名称                              功能说明\nmediaqueryobserver.disconnect   停止监听\nmediaqueryobserver.observe      开始监听页面 media query 变化情况\n\n\n# nodesref\n\n名称                            功能说明\nnodesref.boundingclientrect   添加节点的布局位置的查询请求\nnodesref.context              添加节点的 context 对象查询请求\nnodesref.fields               获取节点的相关信息\nnodesref.node                 获取 node 节点实例\nnodesref.scrolloffset         添加节点的滚动位置查询请求\n\n\n# selectorquery\n\n名称                             功能说明\nselectorquery.exec             执行所有的请求\nselectorquery.in               将选择器的选取范围更改为自定义组件 component 内\nselectorquery.select           在当前页面下选择第一个匹配选择器 selector 的节点\nselectorquery.selectall        在当前页面下选择匹配选择器 selector 的所有节点\nselectorquery.selectviewport   选择显示区域\n\n\n# 第三方平台\n\n名称                    功能说明\nwx.getextconfigsync   wx.getextconfig 的同步版本\nwx.getextconfig       获取第三方平台自定义的数据字段\n\n\n# 广告\n\n名称                         功能说明\nwx.createrewardedvideoad   创建激励视频广告组件\nwx.createinterstitialad    创建插屏广告组件\n\n\n# interstitialad\n\n名称                        功能说明\ninterstitialad.destroy    销毁插屏广告实例\ninterstitialad.load       加载插屏广告\ninterstitialad.offclose   取消监听插屏广告关闭事件\ninterstitialad.offerror   取消监听插屏错误事件\ninterstitialad.offload    取消监听插屏广告加载事件\ninterstitialad.onclose    监听插屏广告关闭事件\ninterstitialad.onerror    监听插屏错误事件\ninterstitialad.onload     监听插屏广告加载事件\ninterstitialad.show       显示插屏广告\n\n\n# rewardedvideoad\n\n名称                         功能说明\nrewardedvideoad.destroy    销毁激励视频广告实例\nrewardedvideoad.load       加载激励视频广告\nrewardedvideoad.offclose   取消监听用户点击 关闭广告 按钮的事件\nrewardedvideoad.offerror   取消监听激励视频错误事件\nrewardedvideoad.offload    取消监听激励视频广告加载事件\nrewardedvideoad.onclose    监听用户点击 关闭广告 按钮的事件\nrewardedvideoad.onerror    监听激励视频错误事件\nrewardedvideoad.onload     监听激励视频广告加载事件\nrewardedvideoad.show       显示激励视频广告",charsets:{cjk:!0}}],themeConfig:{sidebar:{"/frontend-network/":[{title:"前端网络",path:"/frontend-network/web-intro",collapsable:!1,children:["/frontend-network/web-intro","/frontend-network/webpage-rendering","/frontend-network/browser-workflow","/frontend-network/dns","/frontend-network/http-protocol","/frontend-network/web-security"]}],"/mp/":[{title:"小程序基础",path:"/mp/get-started/environment-config",collapsable:!1,children:["/mp/get-started/environment-config","/mp/get-started/program-structure","/mp/get-started/miniprogram-framework","/mp/get-started/app-instance","/mp/get-started/page","/mp/get-started/data-binding","/mp/get-started/conditional-render","/mp/get-started/list-render","/mp/get-started/style-wxss","/mp/get-started/event-binding","/mp/get-started/form-binding"]},{title:"组件化编程",path:"/mp/component-programming/summary",collapsable:!1,children:["/mp/component-programming/summary","/mp/component-programming/template-style","/mp/component-programming/constructor","/mp/component-programming/communicate-and-events","/mp/component-programming/lifecycle","/mp/component-programming/mixins","/mp/component-programming/relations-component","/mp/component-programming/data-observer"]},{title:"API 能力",path:"/mp/api-ability/api",collapsable:!1,children:["/mp/api-ability/api"]}],"/vue3-deep-dive/":[{title:"Vue3 Deep Dive",path:"/vue3-deep-dive/intro",collapsable:!1,children:["/vue3-deep-dive/intro","/vue3-deep-dive/rendering-mechanism","/vue3-deep-dive/use-render-function","/vue3-deep-dive/compiler-and-renderer-api","/vue3-deep-dive/creating-a-mount-function"]}],"/private/0yyy0qaq==/majiang":[{title:"基础概念",path:"/private/0yyy0qaq==/majiang/ch01",collapsable:!1,children:["/private/0yyy0qaq==/majiang/ch01"]}]},sidebarDepth:2}};t(304);Eo.component("Badge",(function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,417))})),Eo.component("CodeBlock",(function(){return Promise.all([t.e(0),t.e(6)]).then(t.bind(null,403))})),Eo.component("CodeGroup",(function(){return Promise.all([t.e(0),t.e(7)]).then(t.bind(null,402))}));t(305);var ds=[{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{}],ps=[];function fs(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(177);function ms(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function hs(n,e,t){return e&&ms(n.prototype,e),t&&ms(n,t),n}t(168);t(159);function vs(n,e){return(vs=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(160);function gs(n){return(gs=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var xs=t(165),ys=t.n(xs);function bs(n,e){return!e||"object"!==ys()(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function ws(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=gs(n);if(e){var o=gs(this).constructor;t=Reflect.construct(r,arguments,o)}else t=r.apply(this,arguments);return bs(this,t)}}var ks=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&vs(n,e)}(t,n);var e=ws(t);function t(){return fs(this,t),e.apply(this,arguments)}return t}(function(){function n(){fs(this,n),this.store=new Eo({data:{state:{}}})}return hs(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Eo.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(ks.prototype,{getPageAsyncComponent:Bi,getLayoutAsyncComponent:Wi,getAsyncComponent:Hi,getVueComponent:Vi});var Ss={install:function(n){var e=new ks;n.$vuepress=e,n.prototype.$vuepress=e}};function Cs(n){n.beforeEach((function(e,t,r){if(Ts(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var o=e.path.replace(/\/$/,"")+".html";Ts(n,o)?r(o):r()}else r();else{var a=e.path+"/",i=e.path+".html";Ts(n,i)?r(i):Ts(n,a)?r(a):r()}}))}function Ts(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var js={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return qi("pageKey",e),Eo.component(e)||Eo.component(e,Bi(e)),Eo.component(e)?n(e):n("")}},_s={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Ms={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},As=(t(307),t(308),Object(ss.a)(Ms,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Is(){return(Is=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,o,a;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:us.routerBase||us.base,Cs(r=new Ci({base:t,mode:"history",fallback:!1,routes:ls,scrollBehavior:function(n,e,t){return t||(n.hash?!Eo.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),o={},n.prev=4,n.next=7,Promise.all(ds.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Eo,options:o,router:r,siteData:us,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return a=new Eo(Object.assign(o,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ps.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:a,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Eo.config.productionTip=!1,Eo.use(Ci),Eo.use(Ss),Eo.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Eo;Ti(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),o=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),i={};return Object.keys(a).reduce((function(n,e){return e.startsWith("$")&&(n[e]=a[e].get),n}),i),{computed:i}}((function(n){return function(){function e(){fs(this,e)}return hs(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var o in r)"/"===o?e=r[o]:0===this.$page.path.indexOf(o)&&(n=r[o]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),us)),Eo.component("Content",js),Eo.component("ContentSlotsDistributor",_s),Eo.component("OutboundLink",As),Eo.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Eo.component("Layout",Wi("Layout")),Eo.component("NotFound",Wi("NotFound")),Eo.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.8.2",hash:"c5783dd"},function(n){return Is.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);