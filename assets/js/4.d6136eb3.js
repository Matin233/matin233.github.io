(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{378:function(t,p,e){t.exports=e.p+"assets/img/image-20211022155021550.7bf290b6.png"},379:function(t,p,e){t.exports=e.p+"assets/img/image-20211022155926502.e58a55da.png"},380:function(t,p,e){t.exports=e.p+"assets/img/image-20211022160650529.77278ab7.png"},381:function(t,p,e){t.exports=e.p+"assets/img/image-20211022162056467.81797cc5.png"},382:function(t,p,e){t.exports=e.p+"assets/img/image-20211022163832340.ca9f72be.png"},383:function(t,p,e){t.exports=e.p+"assets/img/image-20211022164146732.ff9b6c56.png"},415:function(t,p,e){"use strict";e.r(p);var a=e(44),s=Object(a.a)({},(function(){var t=this,p=t.$createElement,a=t._self._c||p;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"创建-mount-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建-mount-函数"}},[t._v("#")]),t._v(" 创建 Mount 函数")]),t._v(" "),a("p",[t._v("第一件事就是 h 函数。很简单，因为我们真的只是把三个参数放进一个对象。更有趣的是，我们如何在这里实现这个挂载函数。现在有很多假设，我们只是想让这更简单。")]),t._v(" "),a("p",[t._v("首先让我们假设一切都是一个元素。第二件事是，我们还假设调用参数总是一样的顺序，所以如果你没有任何 props，您必须显式地传递 null。")]),t._v(" "),a("p",[t._v("我们知道我们假设这总是一个元素节点。所以 vnode.tag 会告诉我们它是什么样的元素。所以当我们挂载一个虚拟 DOM 树时，我们正在创建相应的真实 DOM 节点。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(378),alt:"image-20211022155021550"}})]),t._v(" "),a("p",[t._v("现在，我们接下来要做的就是把它插入容器。中间有一些事情我们还需要处理，包括 props 和 children，所以如果 vnode 有 props，我们得反复检查 props 把它们分别放在元素上作为 DOM property 或 attribute。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(379),alt:"image-20211022155926502"}})]),t._v(" "),a("p",[t._v("在实际执行中，我们必须考虑很多事情，例如检查是否应该设置作为 property 或 attribute 或者是一个事件监听者。但为了简单起见，我们假设一切都是 attribute，如果你有一个 id，它就会作为元素的 attribute 或者一个 class 被设置，在这种情况下，我们这里确实有一个 class。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(380),alt:"image-20211022160650529"}})]),t._v(" "),a("p",[t._v("如果我们有孩子，我们再次做一个假设。我们假设孩子是一个字符串或虚拟节点数组，这样可以使我们的算法更容易处理。")]),t._v(" "),a("p",[t._v("我们会说如果"),a("code",[t._v("vnode.children")]),t._v("等于字符串。如果我们有 child 在这里，我们能做的是...但是如果我们有一个 vNode 数组，这里我们知道这只能是子 vnode。这是我们可以进行一点递归的区域，因为我们已经有了挂载功能。所以我们可以说"),a("code",[t._v("mount(child)")]),t._v("，child 是 vnode。然后我们需要给它一个容器，是我们刚刚创建的元素，现在我们已经完成了一个非常基本的挂载功能。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(381),alt:"image-20211022162056467"}})]),t._v(" "),a("p",[t._v("以上就是 mount 的部分了。")]),t._v(" "),a("p",[t._v("下一个练习是关于 patch 的部分，即更新虚拟 DOM。")]),t._v(" "),a("p",[t._v("对于要构建的应用程序，最初的挂载就是创造一些东西。以前没有以及随后的更新，我们希望尽可能多地重用。所以我们只修改其中的内容，而不是重新创建它们。")]),t._v(" "),a("p",[t._v("所以如果我们有一个叫 patch 的东西。patch 函数将接收我们称之为n1，n2。n1 代表旧的虚拟 DOM，之前的快照，基本上表示当前屏幕上的内容。n2 将是新的快照，它代表了我们希望屏幕更新的内容。")]),t._v(" "),a("p",[t._v("是的，所以这是我们的工作，或者是 patch 函数的工作——找出它需要执行的，将屏幕更新到所需的状态的，最小数量的 DOM 操作。")]),t._v(" "),a("p",[t._v("我们已经渲染了原始组件，它渲染了一次模板，把它变成了虚拟 DOM，然后一个响应式属性被更新，所以它触发了重新渲染，重新生成另一个表示形式虚拟 DOM。")]),t._v(" "),a("p",[t._v("现在我们有两个虚拟 DOM，我们需要对两者进行比较。")]),t._v(" "),a("p",[t._v("这是另一个快照")]),t._v(" "),a("p",[a("img",{attrs:{src:e(382),alt:"image-20211022163832340"}})]),t._v(" "),a("p",[t._v("想象一下我们点击按钮，按钮改变了我们的组件状态。基本上说这个类现在应该是绿色的，并且应该修改这段文字。")]),t._v(" "),a("p",[t._v("我们希望 DOM 反映更新后的状态，所以它（patch）将执行所有的需要更新的 DOM 操作")]),t._v(" "),a("p",[t._v("所以在我们这么做之前，我们需要对我们的算法做些小小的改变。")]),t._v(" "),a("p",[a("img",{attrs:{src:e(383),alt:"image-20211022164146732"}})]),t._v(" "),a("p",[t._v("我们存储了相应的实际 DOM 元素到 vnode 本身，所以现在当你看到以前的 vDOM 时，您可以使用"),a("code",[t._v(".el")]),t._v("访问旧的真实 DOM 树。所以有了这个改变，我们应该把一切都准备好了。")])])}),[],!1,null,null,null);p.default=s.exports}}]);